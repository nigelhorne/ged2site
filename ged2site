#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015-2020, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# TODO: Geo::Coder::GeocodeFarm, once github issue 1 has been fixed
# TODO: Investigate BGS
# TODO: Finish XML
# TODO: Can I use a kdTree to determine events or residences close by each other?
# TODO: note if a child was orphaned by both parents dying before they were 16
# TODO: add male and female average lifespan to the facts
# TODO: finish -x option to create a blog of differences over time of
#	changes to the tree
# TODO: look at census records to note the different places that a person's children
#	were born and note if the residences of the person don't include those places
# TODO: Create occupations database

# -d:	Download copies of objects rather than link to them, useful if the
#	objects are on pay sites such as FMP

# For the Simile Timeline format see
#	http://www.simile-widgets.org/wiki/Timeline_EventSources
# For visjs see
#	http://visjs.org/docs/timeline/

use strict;
use warnings;
use utf8;

no lib '.';

my @modules;

# Install Pre-requisites
BEGIN {
	@modules = (
		'Config::Auto',
		'File::Basename', 'File::Copy', 'File::Temp', 'File::Print::Many',
		'Geo::Coder::List 0.26', 'Gedcom', 'Genealogy::Gedcom::Date',
		'Date::Parse', 'Geo::Coder::List', 'Geo::Coder::Free',
		'IPC::System::Simple', 'Geo::Coder::Ovi', 'String::Compare',
		'Genealogy::Gedcom::Date',
		'Geo::Coder::DataScienceToolkit',
		# 'Geo::Coder::Free::OpenAddresses',
		'Geo::Coder::RandMcnally', 'Geo::Coder::US::Census',
		'Geo::Coder::OSM', 'Geo::Coder::XYZ', 'Geo::Coder::CA',
		'Geo::Coder::OpenCage', 'Geo::Coder::Google',
		'Geo::Coder::GooglePlaces',
		'Geo::Coder::Bing', 'Lingua::EN::ABC',
		'Geo::Parser::Text', 'GIS::Distance',
		'HTML::Entities', 'Image::Info', 'JSON',
		'List::Util',
		'LWP::Simple', 'MIME::Base64',
		'DateTime', 'DateTime::Duration',
		'DateTime::Format::Genealogy', 'DateTime::Format::Natural',
		# 'Geo-Coder-PlaceFinder-0.1.tar.gz'
		'Class::Simple::Cached', 'Class::Simple::Readonly::Cached',
		'HTML::GoogleMaps::V3 0.13',
		'Sort::Key::DateTime', 'Text::Names', 'Text::Names::GB',
		'Term::ANSIColor',
		'URI', 'URI::Find::Schemeless',
		'XML::Dumper', 'XML::Twig', 'Locale::CA', 'Locale::US', 'CHI', 'Class::Simple',
		# 'Geo::StreetAddress::US',
		'Getopt::Std', 'Lingua::EN::NameCase', 'Lingua::EN::NameParse',
		'Lingua::EN::Numbers::Ordinate', 'Lingua::EN::Inflect',
		'Locale::Object::Country',
		'Unicode::Diacritic::Strip', 'URI::Find::Schemeless',
	);

	my @needfull;
	foreach my $module(@modules) {
		eval "use $module";
		if($@) {
			push @needfull, $module;
		}
	}
	# Fix for this module not being found
	eval 'use Geo::Coder::PlaceFinder';
	if($@) {
		push @needfull, 'F/FR/FRIFFIN/Geo-Coder-PlaceFinder-0.1.tar.gz'
	}

	if(scalar(@needfull)) {
		my $list = join(' ', @needfull);
		print "Installing $list\n";
		system("cpan -i $list");
	}

	# FIXME
	$SIG{__WARN__} = sub {
		my $warning = shift;
		if(($warning !~ /Subroutine Geo::Coder::OpenCage::ua redefined at/) &&
		   ($warning !~ /Subroutine HTML::GoogleMaps::V3::_text_to_point redefined at/) &&
		   ($warning !~ /Subroutine Gedcom::Individual::relationship redefined at/)) {
			if($warning =~ /^Use of uninitialized value/) {
				die $warning;
			}
			warn $warning;
		}
	};
}

foreach my $module(@modules) {
	my $version;
	if($module =~ /(.+)\s(.+)$/) {
		$module = $1;
		$version = $2;
	}
	if($module =~ /.+\/(.+)/) {
		$module = $1;
	}
	eval "require $module";
	if($@) {
		die $@;
	}
	$module->import();
	# if($version && ($module::VERSION < $version)) {
		# die "$module: need $version got ", $module::VERSIOn;
	# }
}

use autodie qw(:all);
# use warnings::unused;

# BEGIN {
	# *CORE::GLOBAL::die = \&main::die;
# }

# use Lingua::EN::AddressParse;
# use Memoize;
use Class::Simple::Cached 0.03;
use Class::Simple::Readonly::Cached 0.02;
use POSIX;

my %opts;
getopts('cdfFG:g:h:J:lL:mwWvx:', \%opts);

die "Usage: $0 [ -c ] [ -d ] [ -F ] [ -f ] [ -g google-search-verification ] [ -h home-person-name ] [ -l ] [ -L max_records ] [ -m [-G Google-Maps-GeoLocation-key ] [ -J Google-Maps-JavaScript-key ] ] [ -w [ -W ] ] [ -x current_people.xml ] filename [ filename2 ]\n" unless($ARGV[0]);

use	constant	MAX_INDEX => 0;	# Debugging, set this to the number of records to print.
					# Set to 0 to run on the entire database

my $gedcal;
if(-x '/usr/bin/gedcom') {
	$gedcal = '/usr/bin/gedcom';
} elsif(-x '/usr/local/bin/gedcom') {
	$gedcal = '/usr/local/bin/gedcom';
} elsif(-x '../gedcom/gedcom') {
	$gedcal = '../gedcom/gedcom';
}

@modules = ();
if($opts{'d'} || $opts{'m'} || $opts{'w'}) {
	push @modules, 'File::Spec';

	if($opts{'m'} || $opts{'w'}) {
		push @modules, 'Geo::Coder::Free::Local';
		if($opts{'w'}) {
			push @modules,
				'Geo::Coder::Postcodes',
				'LWP::UserAgent::Cached', 'Genealogy::ChroniclingAmerica', 'Locale::Country';
		}
	}
}
if($opts{'d'} || $opts{'m'}) {
	push @modules, 'HTTP::Cache::Transparent';
}
if($opts{'m'} || $opts{'w'}) {
	push @modules, 'LWP::UserAgent::Throttled', 'Geo::GeoNames';
}
if($gedcal || !$opts{'w'}) {
	push @modules, 'String::ProgressBar';
}
if($opts{'F'}) {
	push @modules, ' Image::Magick::Thumbnail';
}

my @needfull;
foreach my $module(@modules) {
	eval "require $module";
	if($@) {
		push @needfull, $module;
	} else {
		$module->import();
	}
}
if(scalar(@needfull)) {
	system('cpan -i ' . join(' ', @needfull));
}

foreach my $module(@modules) {
	my $version;
	if($module =~ /(.+)\s(.+)$/) {
		$module = $1;
		$version = $2;
	}
	eval "require $module";
	if($@) {
		die $@;
	}
	$module->import();
	# if($version && ($module::VERSION < $version)) {
		# die "$module: need $version got ", $module::VERSIOn;
	# }
}

my $me;
my @myancestors;
my @mydescendents;
my %warned;
my %printed;
my %places;
my $surnames;
my %censuses;
my %twins;
my %all_military;
my %all_occupations;
my %images;
my %all_locations;
my %all_events;	# Maps events to people
my %all_dates;	# Maps dates to the hashref from Genealogy::Gedcom::Date
my %name_date;	# Maps first names to quarter century
my %changes;	# If the -x option is given, tracks changes between the previous run and this run
my $facts;
my $pi = atan2(1,1) * 4;

binmode(STDOUT, ':utf8');

# Help OSM to match
my %location_mappings = (
	'Coventry, Warwickshire, England' => 'Coventry, England',
	'Minster, Sheppey, Kent' => 'Minster, Swale, Kent',
	'Bromley, Kent, Endland' => 'Bromley, London, England',
	'Croydon, Surrey, Endland' => 'Croydon, London, England',
	'Thornton Heath, Surrey, Endland' => 'Thornton Heath, London, England',
	'Edinburgh, Midlothian, Scotland' => 'Edinburgh, Scotland',
);

my $nameparser = Lingua::EN::NameParse->new(extended_titles => 1);
my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);
$ged = Class::Simple::Cached->new(object => $ged, cache => CHI->new(driver => 'RawMemory', datastore => {}));
my $dfn = DateTime::Format::Natural->new();
my $dfg = DateTime::Format::Genealogy->new();
my $date_parser = Genealogy::Gedcom::Date->new();
my $oneday = DateTime::Duration->new(days => 1);
my $tenmonths = DateTime::Duration->new(months => 10);
my $sixteenyears = DateTime::Duration->new(years => 16);
my $fortyyears = DateTime::Duration->new(years => 40);
# my $fetcher;
my $year_1000 = DateTime->new(year => 1000, month => 1, day => 1);

my $config;

eval { $config = Config::Auto::parse() };

my %gp_args = (apiver => 3);
my $geolocation_key;
if($opts{'G'}) {
	$geolocation_key = $opts{'G'};
} elsif($ENV{'GMAP_KEY'}) {	# Compatibility with various CPAN modules
	$geolocation_key = $ENV{'GMAP_KEY'};
} elsif($config && $config->{'google_maps_geolocation_key'}) {
	$geolocation_key = $config->{'google_maps_gelocation_key'};
}
$gp_args{'key'} = $geolocation_key;
$gp_args{'api_key'} = $geolocation_key;

my $javascript_key;
if($opts{'J'}) {
	$javascript_key = $opts{'J'};
} elsif($config && $config->{'google_maps_javascript_key'}) {
	$javascript_key = $config->{'google_maps_javascript_key'};
}

my $geocoder;
my $textgeocoder;
my $freegeocoder;

if($opts{'m'} || $opts{'w'}) {
	my $l = $ENV{'LANG'};
	if(defined($l) && ($l =~ /^([a-z]{2})/i)) {
		$gp_args{'language'} = lc($1);
	}

	# my $geocoder = Geo::Coder::List->new(cache => CHI->new(driver => 'Memcached', servers => [ '192.168.1.15:11211', '127.0.0.1:11211' ]));
	my $cachedir;
	if(my $e = $ENV{'CACHEDIR'}) {
		$cachedir = File::Spec->catfile($e, basename($0));
	} else {
		$cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', basename($0));
	}
	$geocoder = Geo::Coder::List->new(cache => CHI->new(driver => 'File', root_dir => $cachedir));
	$geocoder->push(Geo::Coder::Free::Local->new());

	if(my $oa = $ENV{'OPENADDR_HOME'}) {
		$freegeocoder = Geo::Coder::Free->new(openaddr => $oa);
		# $geocoder->push({ regex => qr/,[\w\s]+,[\w\s]+$/, geocoder => $freegeocoder });
		# $geocoder->push({ regex => qr/,\s*(USA|US|United States|Canada|Australia)+$/, geocoder => Geo::Coder::Free::OpenAddresses->new(openaddr => $oa) })
			# ->push({ regex => qr/^[\w\s\-]+?,[\w\s]+,[\w\s]+?$/, geocoder => Geo::Coder::Free->new() });
		# US, Canada and Australia are full
		# Counties and towns in the UK are full
		$geocoder->push({ regex => qr/,\s*(USA|US|United States|Canada|Australia)\s*$/, geocoder => $freegeocoder })
			->push({ regex => qr/^([\w\s]+,)?\s*[\w\s]+,\s*[\w\s]+\s*$/, geocoder => $freegeocoder });
	} else {
		$freegeocoder = Geo::Coder::Free->new();
		$geocoder->push({ regex => qr/^[\w\s\-]+?,[\w\s]+,[\w\s]+?$/, geocoder => $freegeocoder })
			# E.g. 'Nebraska, USA'
			->push({ regex => qr/^[\w\s]+,\s*(UK|England|Canada|USA|US|United States)$/i, geocoder => $freegeocoder });
	}
	$geocoder->push({ regex => qr/^[\w\s]+,\s*[\w\s]+,\s*(UK|England|Wales|Scotland)$/i, geocoder => $freegeocoder });

	if(my $username = $ENV{'GEONAMES_USER'}) {
		$geocoder->push(Geo::GeoNames->new(username => $username));
	}
	if($geolocation_key) {
		# DST isn't that good for the UK
		# $geocoder->push({ regex => qr/(UK|United Kingdom|England|USA|US|United States|Wales)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
		$geocoder->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
			->push({ regex => qr/^\d.+?,.+?,\s*(USA|US|United States)$/i, geocoder => Geo::Coder::US::Census->new() })
			->push({ limit => 100, regex => qr/(Canada|USA|US|United States)$/i, geocoder => Geo::Coder::CA->new() })
			->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::RandMcnally->new() })
			->push(Geo::Coder::OSM->new())
			->push({ regex => qr/^[\w\s-]+,\s*[\w\s]+,\s*(UK|United Kingdom|England|Wales)$/i, geocoder => Geo::Coder::Postcodes->new() })
			->push(Geo::Coder::Ovi->new())
			->push({ limit => 100, geocoder => Geo::Coder::GooglePlaces->new(%gp_args) })
			->push({ limit => 200, geocoder => Geo::Coder::XYZ->new()})
			->push(Geo::Coder::Google->new());
	} else {
		# DST isn't that good for the UK
		# $geocoder->push({ regex => qr/(UK|United Kingdom|England|USA|US|United States|Wales)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
		$geocoder->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
			->push({ regex => qr/^\d.+?,.+?,\s*(USA|US|United States)$/i, geocoder => Geo::Coder::US::Census->new() })
			->push({ limit => 100, regex => qr/(Canada|USA|US|United States)$/i, geocoder => Geo::Coder::CA->new() })
			->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::RandMcnally->new() })
			->push({ regex => qr/^[\w\s-]+,\s*[\w\s]+,\s*(UK|United Kingdom|England|Wales)$/i, geocoder => Geo::Coder::Postcodes->new() })
			->push(Geo::Coder::OSM->new())
			# ->push({ limit => 200, geocoder => Geo::Coder::XYZ->new()})
			->push(Geo::Coder::Ovi->new());
			# ->push(Geo::Coder::Google->new())
			# ->push(Geo::Coder::GooglePlaces->new());
	}
	if(my $key = $ENV{'GEO_CODER_OPENCAGE_API_KEY'}) {
		$geocoder->push({ limit => 200, geocoder => Geo::Coder::OpenCage->new(api_key => $key) });
	}
	if(my $key = $ENV{BMAP_KEY}) {
		$geocoder->push(Geo::Coder::Bing->new(key => $key));
	}

	my $ua = LWP::UserAgent::Throttled->new(agent => basename($0), keep_alive => 1);
	$ua->env_proxy(1);

	# TODO: throttle other geocoders
	$ua->throttle({
		'nominatim.openstreetmap.org' => 1,
		'geocode.xyz' => 2,
		'geocoder.ca' => 1,
		'opencagedata.com' => 1,
		'api.postcodes.io' => 1,
		'where.desktop.mos.svc.ovi.com' => 1,
		'geocoding.geo.census.gov' => 1,
		'a2ageo.rmservers.com' => 1,
		'dev.virtualearth.net' => 1,	# Bing
		'api.geonames.org' => 1,
		'yboss.yahooapis.com' => 1,	# Geo::Coder::PlaceFinder
	});

	# G::C::GooglePlaces
	$ua->throttle({ 'maps.googleapis.com' => 0.1 }) unless($geolocation_key);
	$ua->ssl_opts(verify_hostname => 0);	# prevent "Can't connect to geocode.xyz:443 (certificate verify failed)"
	$geocoder->ua($ua);

	# Geo::Coder::PlaceFinder doesn't support the ua() method
	if((my $ckey = $ENV{'YAHOO_CONSUMER'}) && (my $skey = $ENV{'YAHOO_SECRET'})) {
		$geocoder->push(Geo::Coder::PlaceFinder->new(consumer_key => $ckey, secret_key => $skey, ua => $ua));
	}

	# $textgeocoder = Geo::Parser::Text->new('https://geocoder.ca');
	$textgeocoder = Geo::Parser::Text->new('https://geocode.xyz');
}

# FIXME: Do this properly
my %censusmaps = (
	'1841 England Census' => '1841 UK Census',
	'1841 England, Wales & Scotland Census - Findmypast' => '1841 UK Census',
	'1851 England Census' => '1851 UK Census',
	'1851 Wales Census' => '1851 UK Census',
	'1851 Census' => '1851 UK Census',
	'1851 England, Wales & Scotland Census - Findmypast' => '1851 UK Census',
	'1851 United Kingdom Census Sample' => '1851 UK Census',
	'1861 England Census' => '1861 UK Census',
	'1861 England, Wales & Scotland Census - Findmypast' => '1861 UK Census',
	'1871 England Census' => '1871 UK Census',
	'1871 England, Wales & Scotland Census - Findmypast' => '1871 UK Census',
	'1871 Wales Census' => '1871 UK Census',
	'1881 England Census' => '1881 UK Census',
	'1881 England, Wales & Scotland Census - Findmypast' => '1881 UK Census',
	'1881 Isle of Man Census' => '1881 Isle of Man Census',
	'1881 Wales Census' => '1881 UK Census',
	'1891 England Census' => '1891 UK Census',
	'1891 England, Wales & Scotland Census - Findmypast' => '1891 UK Census',
	'1891 Wales Census' => '1891 UK Census',
	'1901 England Census' => '1901 UK Census',
	'1901 Wales Census' => '1901 UK Census',
	'1901 England, Wales & Scotland Census - Findmypast' => '1901 UK Census',
	'1911 England Census' => '1911 UK Census',
	'1911 England Census Summary Books' => '1911 UK Census',
	'1911 Census for England & Wales - Findmypast' => '1911 UK Census',
	'1911 Wales Census' => '1911 UK Census',

	'1851 Census of Canada East, Canada West, New Brunswick, and Nova Scotia' => '1851 Canadian Census',
	'1861 Census of Canada' => '1861 Canadian Census',
	'Canada Census 1861 - Findmypast' => '1861 Canadian Census',
	'1871 Census of Canada' => '1871 Canadian Census',
	'Canada Census 1871 - Findmypast' => '1871 Canadian Census',
	'Kent County, New Brunswick Census, 1871: Eight Subdistricts' => '1871 Canadian Census',
	'1881 Census of Canada' => '1881 Canadian Census',
	'1881 Canada Census' => '1881 Canadian Census',
	'Canada Census 1881 - Findmypast' => '1881 Canadian Census',
	'1891 Census of Canada' => '1891 Canadian Census',
	'Canada Census 1891 - Findmypast' => '1891 Canadian Census',
	'1901 Census of Canada' => '1901 Canadian Census',
	'Canada Census 1901 - Findmypast' => '1901 Canadian Census',
	'1906 Canada Census of Manitoba, Saskatchewan, and Alberta' => '1906 Canadian Census',
	'Canada Census 1911 - Findmypast' => '1911 Canadian Census',
	'1911 Census of Canada' => '1911 Canadian Census',
	'1916 Canada Census of Manitoba, Saskatchewan, and Alberta' => '1916 Canadian Census',
	'1921 Census of Canada' => '1921 Canadian Census',

	'1850 United States Federal Census' => '1850 US Census',
	'US Census 1850 - Findmypast' => '1850 US Census',
	'Us Census 1850 - Findmypast' => '1850 US Census',	# Strange...

	'New York, State Census, 1855' => '1855 New York Census',

	'1860 United States Federal Census' => '1860 US Census',
	'US Census 1860 - Findmypast' => '1860 US Census',
	'Nebraska, State Census Collection, 1860-1885' => '1860 US Census',

	'New York, State Census, 1865' => '1865 New York Census',

	'US Census 1870 - Findmypast' => '1870 US Census',
	'1870 United States Federal Census' => '1870 US Census',

	'New York, State Census, 1875' => '1875 New York Census',

	'1880 United States Federal Census' => '1880 US Census',
	'US Census 1880 - Findmypast' => '1880 US Census',
	'Us Census 1880 - Findmypast' => '1880 US Census',

	'US Census 1900 - Findmypast' => '1900 US Census',
	'1900 United States Federal Census' => '1900 US Census',

	'New York, State Census, 1905' => '1905 New York Census',

	'1910 United States Federal Census' => '1910 US Census',
	'US Census 1910 - Findmypast' => '1910 US Census',

	'1920 United States Federal Census' => '1920 US Census',
	'US Census 1920 - Findmypast' => '1920 US Census',

	'New York, State Census, 1925' => '1925 US State Censuses',
	'South Dakota, State Census, 1925' => '1925 US State Censuses',

	'US Census 1930 - Findmypast' => '1930 US Census',
	'1930 United States Federal Census' => '1930 US Census',

	'South Dakota, State Census, 1935' => '1935 US Census',

	'US Census 1940 - Findmypast' => '1940 US Census',
	'1940 United States Federal Census' => '1940 US Census',
);

# sub realdie
# {
	# CORE::die (@_);
# }

# sub die {
	# my @arg = shift;
# 
	# print STDERR "@arg\n" if($arg[0]);
# 
	# my $i = 0;
	# while((my @call_details = (caller($i++)))) {
		# print STDERR $call_details[1], ':', $call_details[2], ' in function ', $call_details[3], "\n";
	# }
# 
	# realdie @arg;
# }

# $ged->validate();

my $home = $opts{h};
if((!defined($home)) && defined($config)) {
	$home = $config->{'home'};
	if(ref($home) eq 'ARRAY') {
		$home = join(' ', @{$home});
	}
}

if($home) {
	$me = $ged->get_individual($home);
	if((!defined($me)) || !ref($me)) {
		die "$0: Can't find '$opts{h}' in $ARGV[0]";
	}
}

my $dot;
my $jpegtran;
my $jpegoptim;
if($opts{'F'}) {
	if(-x '/usr/bin/dot') {
		$dot = '/usr/bin/dot';
	} elsif(-x '/usr/local/bin/dot') {
		$dot = '/usr/local/bin/dot';
	} elsif(-x '/sw/bin/dot') {
		$dot = '/sw/bin/dot';
	}

	if(!defined($dot)) {
		complain(warning => 'Graphviz not found, no family trees');
	} else {
		print "Using $dot\n" if($opts{'v'});
	}
}

for my $dir('dynamic-site/databases', 'dynamic-site/img', 'static-site') {
	if(-d $dir) {
		File::Path::rmtree($dir);
	}
}

my @dirlist = ('static-site', 'dynamic-site/databases');
if($dot || $opts{'d'}) {
	push @dirlist, 'static-site/img';
	push @dirlist, 'dynamic-site/img';
	push @dirlist, 'thumbs';

	if(-x '/usr/bin/jpegtran') {
		$jpegtran = '/usr/bin/jpegtran';
	} elsif(-x '/usr/local/bin/jpegtran') {
		$jpegtran = '/usr/local/bin/jpegtran';
	} elsif(-x '/opt/local/bin/jpegtran') {
		$jpegtran = '/opt/local/bin/jpegtran';
	} elsif(-x '/sw/bin/jpegtran') {
		$jpegtran = '/sw/bin/jpegtran';
	}
	if(-x '/usr/bin/jpegoptim') {
		$jpegoptim = '/usr/bin/jpegoptim';
	} elsif(-x '/usr/local/bin/jpegoptim') {
		$jpegoptim = '/usr/local/bin/jpegoptim';
	} elsif(-x '/sw/bin/jpegoptim') {
		$jpegoptim = '/sw/bin/jpegoptim';
	}
}

if($gedcal) {
	push @dirlist, 'static-site/calendar';
}

foreach my $dir(@dirlist) {
	mkdir $dir if(!-d $dir);
}

my $browser;
my $cached_browser;

if($opts{'d'} || $opts{'m'}) {
	$browser = LWP::UserAgent->new();
	$browser->env_proxy(1);
	my $cachedir;
	if(my $e = $ENV{'CACHEDIR'}) {
		$cachedir = File::Spec->catfile($e, 'http-cache-transparent');
	} else {
		$cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'http-cache-transparent');
	}

	if(!-d $cachedir) {
		mkdir $cachedir || die "$cachedir: $!";
	}
	HTTP::Cache::Transparent::init({
		BasePath => $cachedir,
		Verbose => $opts{'v'} ? 1 : 0,
		NoUpdate => 24 * 60 * 60,
	});
}

# my @everyone = $ged->individuals();
my @everyone = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } $ged->individuals();
my $total = scalar(@everyone);
if($total == 0) {
	die "$0: gedcom file is empty";
}
my $index = 0;

my $pr;
my $us = Locale::US->new();
my $ca = Locale::CA->new();
my $dtl = DateTime::Locale->load($ENV{'LANG'});
my $language;
if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^fr/)) {
	$language = 'French';
} else {
	$language = 'English';
}

if($opts{'w'}) {
	my $cachedir;
	if(my $e = $ENV{'CACHEDIR'}) {
		$cachedir = File::Spec->catfile($e, 'lwp');
	} else {
		$cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'lwp');
	}
	if(!-d $cachedir) {
		mkdir $cachedir || die "$cachedir: $!";
	}
	$cached_browser = LWP::UserAgent::Cached->new(cache_dir => $cachedir,
		agent => basename($0),
		keep_alive => 1
	);
	$cached_browser->env_proxy(1);

	if(!defined($ENV{'CLICOLOR'})) {
		$opts{'W'} = 1;
	}
} else {
	$pr = String::ProgressBar->new(max => $total, length => 60);
}

my $key = delete $opts{'g'};	# Ensure it's not stored in the XML file

my $current_people = delete $opts{'x'};
if($current_people) {
	# Creating a changelog only works if the many of the options are the same
	my $xml = XML::Twig->new();
	$xml->parsefile($current_people);
	my %prev_opts;
	foreach my $key($xml->root()->first_child('opts')->first_child('hashref')->children()) {
		if($key->name() eq 'item') {
			$prev_opts{$key->{'att'}->{'key'}} = $key->first_child()->pcdata();
		}
	}
	my $ok = 1;
	for my $opt('c', 'd', 'h') {
		if(defined($opts{$opt}) ne defined($prev_opts{$opt})) {
			$ok = 0;
			last;
		}
		if(defined($opts{$opt}) && ($opts{$opt} ne $prev_opts{$opt})) {
			$ok = 0;
			last;
		}
	}
	if(!$ok) {
		die "Runtime options aren't the same as given in $current_people\n";
	}
	$current_people = $xml;
}

open(my $xml, '>', 'dynamic-site/databases/people.xml');
print $xml "<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n<table>\n";
my $string = XML::Dumper->new()->pl2xml(\%opts);
$string =~ s/perldata/opts/g;
print $xml "\t$string";
########
# print $xml "\n</table>\n"; exit;
########
open(my $csv, '>', 'dynamic-site/databases/people.csv');
print $csv "entry!title!home!alive!bio!father!mother!children!citations!notes!media!family_tree!map_head!map_body!dob!dod!profile_thumbnail!marriages!sex!birth_coords!death_coords!birth_country!death_country!warnings\n";

open(my $timeline_xml, '>', 'dynamic-site/timeline.xml');
print $timeline_xml "<?xml version=\"1.0\"?>\n",
	"<data date-time-format=\"iso8601\">\n";

open(my $visjs, '>', 'dynamic-site/visjs.html');
print $visjs <<'HEADER';
<!DOCTYPE HTML>
<html lang="en" dir="ltr">
<head>
	<meta charset="utf8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="description" content="Blood relatives timeline - A ged2site webpage">
	<title>Blood Relatives' Timeline</title>

	<link rel="stylesheet" href="/css/web.css" type="text/css" media="screen">
  <style type="text/css">
    body, html {
	font-family: sans-serif;
	font-size: 10px;
    }
  </style>

  <script async type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.19.1/vis.min.js"></script>
  <link async href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.19.1/vis.min.css" rel="stylesheet" type="text/css" />
  <style type="text/css">
	/* Limit the width of the biography box */
	/*div.vis-tooltip { font-size:10px; white-space: normal; width: 30em; word-wrap: break-word; }*/
	div.vis-tooltip {
		font-size: 10px;
		white-space: normal;
		width: 30em;
		max-width: 300px;
		word-wrap: break-word;
		padding: 5px;
	}
  </style>
</head>
<body>
	<h1>Blood Relatives' Timeline</h1>
	<p><font size=+1>
		Click and move the mouse to move around the timeline.
		Only people with known birth dates are shown.
	</font></p>

	<div id="visualization">
	    <div class="menu">
		<input type="button" id="zoomIn" value="Zoom In"/>
		<input type="button" id="zoomOut" value="Zoom Out"/>
		<input type="button" id="moveLeft" value="Scroll Left"/>
		<input type="button" id="moveRight" value="Scroll Right"/>
	    </div>
	</div>

<script type="text/javascript">
  // DOM element where the Timeline will be attached
  var container = document.getElementById('visualization');

  // Create a DataSet (allows two way data-binding)
	var items = new vis.DataSet([
HEADER

# TODO: Add a -p option to do something like this - it's useful in debugging
# foreach my $person($ged->get_individual('Dolly Cowell')) {
# foreach my $person($ged->get_individual('Ruth Marie Bixler')) {

foreach my $person(@everyone) {
	$index++;
	if(!$opts{'w'}) {
		$| = 1;
		$pr->update($index);
		$pr->write();
		$| = 0;
	}
	if(!$printed{$person->xref()}) {
		# FIXME: change &eacute; to e
		print $xml "\n\t<person person_id=\"$index\">";
		print_person({ person => $person });
		print $xml "\n\t</person>";
		print $csv "\n";
		if($opts{'v'}) {
			my $log = $geocoder->log();
			$geocoder->flush();
			foreach my $l(@{$log}) {
				print $l->{location}, ': ' if($l->{'location'});
				if($l->{geocoder}) {
					if($l->{error}) {
						print $l->{timetaken}, 's with ',  $l->{geocoder}, '(', $l->{error}, ')';
					} else {
						print $l->{timetaken}, 's with ',  $l->{geocoder};
					}
				} else {
					print 'cached';
				}
				print ', wantarray ', $l->{wantarray}, "\n";
			}
		}
	}
	last if($opts{'L'} && ($index == $opts{'L'}));
	last if(MAX_INDEX && ($index >= MAX_INDEX));
}
print $xml "\n</table>\n";
close $xml;
close $csv;

print $timeline_xml "</data>\n";
close $timeline_xml;

print $visjs <<'FOOTER';
	]);

  // Configuration for the Timeline
  // var options = { zoomable: false, horizontalScroll: true, verticalScroll: true, autoResize: true, height: '500px', min: '1500', max: '2017' };
  var timelineHeight = Math.round($(window).height() * 0.85) + 'px';
var options = {
    zoomKey: 'ctrlKey',
    verticalScroll: true,
    min: '1500',
    max: '2017',
    height: timelineHeight
};

  // Create a Timeline
  var timeline = new vis.Timeline(container, items, options);

    /**
     * Move the timeline a given percentage to left or right
     * @param {Number} percentage   For example 0.1 (left) or -0.1 (right)
     */
    function move (percentage) {
	var range = timeline.getWindow();
	var interval = range.end - range.start;

	timeline.setWindow({
	    start: range.start.valueOf() - interval * percentage,
	    end:   range.end.valueOf()   - interval * percentage
	});
    }

    // attach events to the navigation buttons
    document.getElementById('zoomIn').onclick   = function () { timeline.zoomIn( 0.2); };
    document.getElementById('zoomOut').onclick  = function () { timeline.zoomOut( 0.2); };
    document.getElementById('moveLeft').onclick = function () { move( 0.2); };
	document.getElementById('moveRight').onclick = function () { move(-0.2); };
</script>
</body>
</html>
FOOTER

close $visjs;

if(!$opts{'w'}) {
	print "\n$index records processed\n";
}

my $name;
if($me) {
	$name = 'of ' . $me->as_string(nee => 1);
} else {
	$name = 'on this site';
}

if(scalar(%censuses)) {
	print "Creating census index\n";
	open(my $html, '>', 'static-site/censuses.html');
	print $html "<html><head><title>Censuses in the Family Tree $name</title>",
		"</head><body><center><h1>Censuses in the Family Tree $name</h1></center><br><ul>";

	open($csv, '>', 'dynamic-site/databases/censuses.psv');
	print $csv "entry|census|person\n";

	$index = 1;
	foreach my $census(sort keys(%censuses)) {
		my $filename = $census;
		$filename =~ tr/ /_/;
		print $html "<li><a href=\"$filename.html\">$census</a></li>";

		open(my $chtml, '>', "static-site/$filename.html");
		print $chtml "<html><head><title>The Family Tree $name - $census</title>",
			'</head>',
			"<body><center><h1>The Family Tree $name - $census</h1>";
		if($me) {
			print $chtml '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
		}
		print $chtml ' | [ <a href="surnames.html">Surnames Index</a> ]';
		if($opts{'w'}) {
			print $chtml ' | [ <a href="todo.html">Errors</a> ]';
		}
		if($gedcal) {
			print $chtml ' | [ <a href="calendar/index.html">Calendar</a> ]';
		}
		print $chtml ' | [ <a href="censuses.html">Census Index</a> ]',
			' | [ <a href="history.html">Family History</a> ]</center><br>',
			'<ul>';

		foreach my $name(sort keys %{$censuses{$census}}) {
			print $chtml '<li>',
				'<a href="', make_filename_from_person(person => $censuses{$census}->{$name}), '">',
				$name,
				'</a></li>';
			print $csv "$index|\"$census\"|\"", $censuses{$census}->{$name}->xref(), "\"\n";
			$index++;
		}

		print $chtml '</ul></body></html>';
		close $chtml;
	}
	print $html '</ul></body></html>';
	close $html;
	close $csv;

	undef %censuses;
}

if(scalar(%all_locations)) {
	print "Creating locations database\n";

	open($csv, '>', 'dynamic-site/databases/locations.csv');
	print $csv "entry!location!person!year!date\n";

	$index = 1;

	open(my $locations_xml, '>', 'dynamic-site/databases/locations.xml');
	print $locations_xml "<locations>\n\t<maps>\n";
	my ($head, $body);
	foreach my $year(sort keys(%all_locations)) {
		my %markers;
		foreach my $l(@{$all_locations{$year}}) {
			my $place = place(record => $l->{'residence'}, nopreposition => 1);
			$place =~ s/^\s*//;
			push @{$markers{$place}}, $l;
			print $csv "$index!$place!",
				$l->{'person'}->as_string({ middle_names => 1, include_years => 1 }), '!',
				"$year!",
				$l->{'date'}, "\n";
			$index++;
		}

		# Create a map of where everyone lived in each year
		my %args = (geocoder => $geocoder);
		if($javascript_key) {
			$args{'api_key'} = $javascript_key;
		}
		my $map = HTML::GoogleMaps::V3->new(%args);
		foreach my $place(keys %markers) {
			my @annotations = @{$markers{$place}};
			my $html;
			my $previous_date;
			foreach my $annotation(@annotations) {
				my $date = $annotation->{'date'};
				my $person = $annotation->{'person'};
				if($previous_date && ($date eq $previous_date)) {
					if($html) {
						$html .= ', ';
					}
				} else {
					if($html) {
						$html .= '<br>';
					}
					$html .= "$date: ";
					$previous_date = $date;
				}
				$html .= '<a href="?page=people&amp;entry=' . $person->xref() . '">' . $person->as_string() . '</a>';
			}
			add_marker(map => $map, place => HTML::Entities::decode($place), annotation => $html);
		}
		($head, $body) = $map->onload_render();
		$head =~ s/\n\n*/\n/g;
		$head =~ s/http:/https:/;
		$head =~ s/</&lt;/g;
		$head =~ s/>/&gt;/g;
		print $locations_xml "\t\t<map>\n\t\t\t<year>$year</year>\n\t\t\t<head>$head\n\t\t\t</head>\n\t\t</map>\n";
	}
	close $csv;

	$body =~ s/</&lt;/g;
	$body =~ s/>/&gt;/g;
	print $locations_xml "\t</maps>\n\t<body>$body</body>\n</locations>\n";
	close $locations_xml;

	undef %all_locations;
}

if(scalar(%all_military)) {
	print "Creating military records\n";
	open($csv, '>', 'dynamic-site/databases/military.csv');
	print $csv "entry!person!date!place!notes\n";

	$index = 1;
	foreach my $xref(sort keys(%all_military)) {
		foreach my $entry(@{$all_military{$xref}}) {
			print $csv "$index!$xref!", $entry->{'date'} || '', '!', $entry->{'place'} || '', '!', $entry->{'notes'} || '', "\n";
			$index++;
		}
	}
	close $csv;

	undef %all_military;
}

if(scalar(%all_occupations)) {
	print "Creating occupations records\n";
	open($csv, '>', 'dynamic-site/databases/occupations.csv');
	print $csv "entry!people\n";

	foreach my $occupation(sort keys(%all_occupations)) {
		print $csv "$occupation!",
			join(',', @{$all_occupations{$occupation}}),
			"\n";
	}
	close $csv;

	undef %all_occupations;
}

if(scalar(%changes)) {
	print "Adding to change blog\n";

	# Keep a copy in the current directory so that it's not trashed
	# when the databases directory is cleared

	open(my $log, '>>', 'changes.psv');

	my $date = DateTime->now(time_zone => 'local')->ymd('');
	while(my $person = shift(@{$changes{'added_people'}})) {
		print $log "$date|\"",
			$person->xref(),
			"\"|\"Added new person\"\n";
	}
	while(my $change = shift(@{$changes{'changes'}})) {
		print $log "$date|\"",
			$change->person()->xref(),
			'"|"',
			$change->change(),
			"\"\n";
	}

	close($log);
	copy('changes.psv', 'dynamic-site/databases/changes.psv');
}

if(scalar(%twins)) {
	print "Creating twins index\n";

	open($csv, '>', 'dynamic-site/databases/twins.csv');
	print $csv "entry!twin\n";

	foreach my $twin(sort keys(%twins)) {
		print $csv "$twin!$twins{$twin}\n";
	}
	close $csv;
}

print "Creating surname index\n";
open(my $html, '>', 'static-site/surnames.html');
print $html "<html><head><title>Surnames in the Family Tree $name</title>",
	"</head><body><center><h1>Surnames in the Family Tree $name</h1>";
if($me) {
	print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
}
print $html ' | [ <a href="surnames.html">Surnames Index</a> ]',
	' | [ <a href="censuses.html">Census Index</a> ]',
	' | [ <a href="calendar/index.html">Calendar</a> ]';
if($opts{'w'}) {
	print $html ' | [ <a href="todo.html">Errors</a> ]';
}
print $html ' | [ <a href="history.html">Family History</a> ]</center><br><ul>';

open($csv, '>', 'dynamic-site/databases/surnames.csv');
print $csv "entry!surname!person\n";
$index = 1;

foreach my $surname(sort keys %{$surnames}) {
	my $filename = $surname;
	if($filename eq '') {
		$filename = 'UNKNOWN';
	}
	print $html "<li><a href=\"$filename.html\">$filename</a> (";
	# FIXME: "Implicit scalar context for hash in null operation"
	my $count = scalar(keys %{$surnames->{$surname}});
	if($count == 1) {
		print $html '1 person';
	} else {
		print $html "$count people";
	}
	print $html ')</li>';

	open(my $shtml, '>', "static-site/$filename.html");
	print $shtml "<html><head><title>The Family Tree $name - $surname</title>",
		'</head>',
		"<body><center><h1>The Family Tree $name - $surname</h1>";
	if($me) {
		print $shtml '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	if($gedcal) {
		print $shtml ' | [ <a href="calendar/index.html">Calendar</a> ]';
	}
	print $shtml ' | [ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="history.html">Family History</a> ]';
	if($opts{'w'}) {
		print $shtml ' | [ <a href="todo.html">Errors</a> ]';
	}
	print $shtml ' | [ <a href="censuses.html">Census Index</a> ]</center><br>',
		'<ul>';

	foreach my $person(sort keys %{$surnames->{$surname}}) {
		# print "\t$person maps to ", $surnames->{$surname}->{$person}, "\n";
		print $shtml '<li>',
			'<a href="', make_filename_from_person(person => $surnames->{$surname}->{$person}), "\">$person</a>",
			'</li>';
		print $csv "$index!$filename!", $surnames->{$surname}->{$person}->xref(), "\n";
		$index++;
	}

	print $shtml '</ul></body></html>';
	close $shtml;
}

close $csv;
print $html '</ul></body></html>';
close $html;

undef $surnames;

if((!defined($key)) && defined($config)) {
	$key = $config->{'google_verification'};
}
if($key) {
	open($html, '>', "static-site/$key.html");
	print $html "google-site-verification: $key.html";
	close $html;
	if(-r "dynamic-site/$key.html") {
		unlink "dynamic-site/$key.html";
	}
	if($^O eq 'MSWin32') {
		copy("static-site/$key.html", "dynamic-site/$key.html");
	} else {
		link "static-site/$key.html", "dynamic-site/$key.html";
	}
}

if(open($csv, '>', 'dynamic-site/databases/names.csv')) {
	# Ready for HTML::TagCloud
	print $csv "entry!name!count!sex!people\n";
	$index = 1;

	foreach my $date(sort keys %name_date) {
		foreach my $firstname(sort keys %{$name_date{$date}}) {
			my $count = scalar(@{$name_date{$date}{$firstname}});
			my $sex = Text::Names::guessGender($firstname) || Text::Names::GB::guessGender($firstname) || '?';
			my $people = join('--', @{$name_date{$date}{$firstname}});
			print $csv "$date!$firstname!$count!$sex!$people\n";
		}
	}
	close $csv;
}

# Output the warnings last, so that all are included
if($opts{'w'}) {
	open(my $html, '>', 'static-site/todo.html');
	print $html "<html><head><title>Errors in the Family Tree $name</title>",
		"</head><body><center><h1>Errors in the Family Tree $name</h1>";
	if($me) {
		print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	print $html ' | [ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="censuses.html">Census Index</a> ]',
		' | [ <a href="calendar/index.html">Calendar</a> ]',
		' | [ <a href="history.html">Family History</a> ]</center><br>';

	open(my $csv, '>', 'dynamic-site/databases/todo.csv');
	print $csv "entry!person!title!summary!error\n";
	my $index = 1;

	foreach my $person(@everyone) {
		if($person->{'warnings'}) {
			print $html '<h2>',
				'<a href="', make_filename_from_person(person => $person), '">', $person->as_string(include_years => 1), '</a></h2>',
				map { HTML::Entities::encode($_) . '<br>' } @{$person->{'warnings'}};
			my %seen_warnings;
			foreach my $warning(@{$person->{'warnings'}}) {
				next if($seen_warnings{$warning});
				my $summary;
				if($warning =~ /^\[\d+\]: no citation title/) {
					$summary = 'Citation Title Missing';
				} elsif($warning =~ /^(.+) date .+ has no citations/) {
					$summary = "$1 date without citation";
				} elsif($warning =~ /^(.+) place .+ has no citations/) {
					$summary = "$1 place without citation";
				} elsif($warning =~ /^Residence record for .+ contains no citation$/) {
					$summary = 'Residence Without Citation';
				} elsif($warning =~ /^Contains a residence .+ without a date/) {
					$summary = 'Residence Without a Date';
				} elsif($warning =~ /.+in notes is not found$/) {
					$summary = 'URL in notes not found';
				} elsif($warning =~ /^Unhandled event type:/) {
					$summary = 'Unhandled Event Type';
				} elsif($warning =~ /^Census information missing between /) {
					$summary = 'Missing Census';
				} elsif($warning eq '1939 UK register information missing') {
					$summary = 'Missing Census';
				} elsif($warning =~ /^Check the gender of the record/) {
					$summary = 'Possibly Wrong Gender';
				} elsif($warning =~ /^Two residence records for/) {
					$summary = 'Residence Records for the Same Date that Don\'t Match';
				} elsif($warning =~ /^Year of baptism .+ is before the year of birth /) {
					$summary = 'Baptism Before Birth';
				} elsif($warning =~ /^Year of residence .+ is after the year of death /) {
					$summary = 'Residence After Death';
				} elsif($warning =~ /^Born less than 10 months before sibling /) {
					$summary = 'Born Under 10 Months Before Sibling';
				} elsif($warning =~ /^married when less than 16 years old/) {
					$summary = 'Under Age 16 When Married';
				} elsif($warning =~ /^unknown sex/) {
					$summary = 'Sex Not Specified';
				} elsif($warning =~ /^married, but no husband relationship/) {
					$summary = 'Husband Relationship Missing';
				} elsif($warning =~ /^Departure record without destination/) {
					$summary = 'Departure Without Destination';
				} elsif($warning =~ /^Census information not used to approximate a date of birth/) {
					$summary = 'Date of Birth not Calculated';
				} elsif($warning =~ /^Census information not used to determine a parent/) {
					$summary = 'Parent not Determined from Census';
				} elsif($warning =~ /^Baptism information not used to determine a parent/) {
					$summary = 'Parent not Determined from Baptism';
				} elsif($warning =~ /^Unknown state in/) {
					$summary = 'Unknown US State';
				} elsif($warning =~ /^Residence information in/) {
					$summary = 'Child\'s Location is Known but Parent\'s is not';
				} elsif($warning =~ /^Unknown birth location/) {
					$summary = 'Birth location not found';
				} elsif($warning =~ /^Unknown death location/) {
					$summary = 'Death location not found';
				} elsif($warning =~ /\sisn't found$/) {
					$summary = 'Location not found';
				} elsif($warning =~ /^Something is wrong with the date /) {
					$summary = 'Inconsistent date';
				} elsif($warning =~ /^born before parent was born/) {
					$summary = 'Born before Parent was born';
				} elsif($warning =~ /^Date of residence .+ is after date of death/) {
					$summary = 'Date of Residence After Date of Death';
				} elsif($warning =~ /^Location for the event /) {
					$summary = 'Location is empty';
				} elsif($warning =~ /^Parent .+ is listed in the residence for .+ but this child is not/) {
					$summary = 'Parent\'s Location is Known but Child\'s is not';
				} elsif($warning =~ /^The census for year \d{4} has been cited,/) {
					$summary = 'Census exists but no residence added';
				} elsif($warning =~ /^Residence record for .+ contains no location/) {
					$summary = 'Residence Record Missing Location';
				} elsif($warning =~ /^Census for \d{4} after year of death/) {
					$summary = 'Census after death';
				} elsif($warning =~ /not living at same address as spouse/) {
					$summary = 'Spouses not at same address';
				} elsif($warning =~ /listed in the residence for .+, but spouse.+is not/i) {
					$summary = 'Spouse location is missing';
				} elsif($warning =~ /residence is very close probably should be recorded as the same address/i) {
					$summary = 'Possible address errors';
				} elsif($warning =~ /residence is same location probably should be recorded as the same address/i) {
					$summary = 'Possible address errors';
				} elsif($warning =~ /^http.+ not found$/) {
					$summary = 'Website in notes is not found';
				} elsif($warning =~ /^Duplicate residence on /) {
					$summary = 'Duplicate Residence';
				} elsif($warning =~ /^Changing 'United States' to 'USA' in /) {
					$summary = 'Change &quot;United States&quot; to &quot;USA&quot;';
				} elsif($warning =~ /Location for .+ differs from /) {
					$summary = 'Inconsistent location';
				} elsif($warning =~ /Date of residence \(.+\sdiffers from\s/i) {
					$summary = 'Date of Residence Differs From Parent\'s';
				} elsif($warning =~ /^Country not included in country,/) {
					$summary = 'Country missing or misspelt';
				} elsif($warning =~ /^Can't parse the name - assuming first name:  /) {
					$summary = "Can't parse the name";
				} elsif($warning =~ /^Check out https?:\/\/chroniclingamerica.loc.gov/) {
					# FIXME: Lots of false positives
					next;
				} else {
					$summary = $warning;
				}
				print $csv "$index!",
					$person->xref(), '!',
					$person->as_string(include_years => 1),
					"!$summary!",
					HTML::Entities::encode($warning),
					"\n";
				$seen_warnings{$warning} = $index;
				$index++;
			}
		}
	}
	close $csv;
	close $html;
}

$ged = undef;

if($gedcal) {
	print "Creating calendar\n";
	if(open(my $fout, '>', 'static-site/calendar/index.html')) {
		print $fout "<html><head><title>Genealogy Calendar $name</title></head>",
			"<body><center><h1>Genealogy Calendar $name</h1>";
		if($me) {
			print $fout '[ <a href="../', make_filename_from_person(person => $me), '">Home</a> ]';
		}
		print $fout ' | [ <a href="../surnames.html">Surnames Index</a> ]',
			' | [ <a href="../censuses.html">Census Index</a> ]';
		if($opts{'w'}) {
			print $fout ' | [ <a href="todo.html">Errors</a> ]';
		}
		print $fout ' | [ <a href="../history.html">Family History</a> ]</center><br><ul>';
		my $pr = String::ProgressBar->new(max => 12, length => 60);
		foreach my $month(1..12) {
			if(open(my $fin, '-|', "$gedcal -dHLm $month '$ARGV[0]'")) {
				$| = 1;
				$pr->update($month);
				$pr->write();
				$| = 0;
				print $fout "<li><a href=\"$month.html\">", @{$dtl->month_format_wide()}[$month - 1], '</a></li>';
				open(my $mout, '>', "static-site/calendar/$month.html");
				while(<$fin>) {
					print $mout $_;
				}
				close $fin;
			}
		}
		print "\n";
		print $fout '</ul></body></html>';
	}
}

if(open(my $fout, '>', 'static-site/history.html')) {
	print "Creating family history page\n";
	print $fout "<html><head><title>Family History $name</title></head>",
		"<body><center><h1>Family History $name</h1>";
	if($me) {
		print $fout '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	print $fout ' | [ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="censuses.html">Census Index</a> ]';
	if($opts{'w'}) {
		print $fout ' | [ <a href="todo.html">Errors</a> ]';
	}
	print $fout ' | [ <a href="calendar/index.html">Calendar</a> ]</center><br>',
		'<ul>';
	my @sorted_events = Sort::Key::DateTime::dtkeysort { $all_events{$_}->{'date'} } keys %all_events;
	my $year;
	open(my $csv, '>', 'dynamic-site/databases/history.csv');
	print $csv "entry!year!month!day!person!title!event\n";
	my $index = 1;
	while(my $e = shift @sorted_events) {
		$e = $all_events{$e};
		my $date = $e->{'date'};
		if(!(defined($year)) || ($date->year() != $year)) {
			$year = $date->year();
			if($year) {
				print $fout '</ul>';
			}
			print $fout "<h2>$year</h2><ul>";
		}
		my $person = $e->{'person'};
		my $string = $person->as_string();
		$string =~ s/'/\&apos;/g;
		print $fout '<li>', @{$dtl->month_format_wide()}[$date->month() - 1], ' ',
			$date->day(), ': <a href="',
			make_filename_from_person(person => $person), '">',
			$person->as_string(), '</a>: ', $e->{'event'}, '</li>';
		print $csv "$index!$year!",
			$date->month(), '!',
			$date->day(), '!',
			$person->xref(), '!',
			"$string!",
			$e->{'event'}, "\n";
		$index++;
	}
	close $csv;
	print $fout '</ul></body></html>';
	close $fout;
}

if($facts && open(my $json, '>', 'dynamic-site/databases/facts.json')) {
	if(my $fb = $facts->{'first_birth'}) {
		$facts->{'first_birth'}->{'date'} = $fb->{'date'}->strftime('%x');
	}
	if(my $oa = delete $facts->{'oldest_age'}->{'age'}) {
		$facts->{'oldest_age'}->{'years'} = $oa->years();
		$facts->{'oldest_age'}->{'months'} = $oa->months();
		$facts->{'oldest_age'}->{'days'} = $oa->days();
	}
	print $json encode_json($facts);
	close $json;
}

sub print_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# Gather the information on this person
	my $person = $params{'person'};

	# $fetcher = Data::Fetch->new();	# Throw away old values from the cache

	my $dob = dateofbirth($person);

	# ACOM starts approximate dates with "Abt." instead of "ABT".
	if(defined($dob) && length($dob) && ($dob ne '?')) {
		$dob =~ tr/\.\-/  /;
		$dob =~ s/\s{2,}/ /gs;
		# FIXME: ../../../gedcoms/gl120368.ged puts dates *inside*
		#	brackets
		$dob =~ s/\(.+$//;	# some people put information in brackets after the date
		if($dob =~ /^About[:\s](.+)/i) {
			$dob = "ABT$1";
		} elsif($dob =~ /^Bet\s[a-z]{3}.+([a-z]{3}\s+.*)/i) {	# Bet Jun-Jul 1860
			$dob = "ABT $1";
		} elsif($dob =~ /^(.+)\s*\?/i) {
			$dob = "ABT$1";
		}
		if(length($dob) && ($dob !~ /^[\d\sA-Z\/]+$/i) && ($dob !~ /^Abt\./)) {
			if($dob =~ /(\d{4})\s*(.+)/) {
				my $d = $1;
				my $t = $2;
				# Allow 1914-1918
				if($t !~ /\d{3,4}$/) {
					$dob = "ABT$d";
					if(place({ person => $person, place => $t })) {
						complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the location record" });
					} else {
						complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the note field" });
					}
				}
			} elsif($dob !~ /\d{1,2}$/) {	# Dates can begin with a letter in the US
				complain({ person => $person, warning => "Invalid character in date of birth $dob" });
				$dob = undef;
			}
		}
	}

	print 'Processing ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

	my @siblings = $person->siblings();
	my $mother = $person->mother();
	my $father = $person->father();
	my @spouses = $person->spouse();

	# TODO: Properly chart which spouse a child comes from
	if($opts{'w'}) {
		my $family;
		foreach my $f($person->fams()) {
			if($f->number_of_children()) {
				$family = $f;
				last;
			}
		}

		if((!$family) && (scalar(@siblings) == 0) && (!$mother) && !$father) {
			if(scalar(@spouses) == 0) {
				# This person isn't connected to anyone
				# TODO: catch "islands" of people connected to each other, but nobody else
				complain({ person => $person, warning => 'Not connected to the tree' });
			} elsif(scalar(@spouses) == 1) {
				my $spouse = $spouses[0];
				my $sf;
				foreach my $f($spouse->fams()) {
					if($f->number_of_children()) {
						$sf = $f;
						last;
					}
				}
				my @ss = $spouse->spouse();
				if((!$sf) && (!$spouse->mother()) && (!$spouse->father()) && (!$spouse->siblings()) && (scalar(@ss) == 1)) {
					complain({ person => $person, warning => 'Spouses connect to each other but no-one else' });
				}
			}
		}
		if((!$family) && (scalar(@siblings) == 1) && (scalar(@spouses) == 0) && (!$mother) && !$father) {
			my $sibling = $siblings[0];
			my $sf;
			foreach my $f($sibling->fams()) {
				if($f->number_of_children()) {
					$sf = $f;
					last;
				}
			}
			my @ss = $sibling->spouse();
			if((!$sf) && (!$sibling->mother()) && (!$sibling->father()) && (scalar(@ss) == 0)) {
				complain({ person => $person, warning => 'Siblings connect to each other but no-one else' });
			}
		}

		# FIXME: needs to only complain about more than two biological parents
		my @parents = $person->parents();
		if(scalar(@parents) > 2) {
			complain({ person => $person, warning => 'Has more than two parents' });
		}
	}

	my $year = (localtime)[5];
	$year += 1900 if($year < 1900);

	my $yob;	# Year of birth
	if($dob && ($dob =~ /.*?(\d{3,4})/)) {
		$yob = $1;
	} elsif($dob) {
		if(($dob eq 'UNKNOWN') || ($dob eq '?')) {
			$dob = undef;
		} elsif($opts{'w'} && !$warned{$person}) {
			complain({ person => $person, warning => "Invalid date of birth $dob" });
			$warned{$person} = 1;
		}
	}

	my $dateofdeath = dateofdeath($person);

	my $yod;	# Year of death
	if($dateofdeath && ($dateofdeath =~ /.*?(\d{3,4})/)) {
		$yod = $1;
	}

	my $name = $person->name();
	$name =~ s/\///g;
	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	my $firstname = $name_components{'given_name_1'} // $name_components{'initials_1'};
	# my $surname = $name_components{'surname_2'} || $name_components{'surname_1'};
	my $surname = ucfirst(lc($person->surname())); # RT109786

	if((!defined($firstname)) && ($name =~ /(.+)\s(.+)/)) {
		$firstname = $1;
		if(!defined($surname)) {
			$surname = $2;
		}
		complain({ person => $person, warning => "Can't parse the name - assuming first name: $firstname, last name: $surname" });
	}

	if($firstname && ($firstname =~ /\d/)) {
		complain({ person => $person, warning => 'First name contains a digit' });
	}
	if($surname && ($surname =~ /\d/)) {
		complain({ person => $person, warning => 'Last name contains a digit' });
	}

	# Ensure last name isn't used if the first name isn't known
	if($yob && $firstname && $person->given_names()) {
		push @{$name_date{floor($yob / 25)}{$firstname}}, $person->xref();
	}

	my $is_alive = is_alive(person => $person);
	my $title;
	if($is_alive && !$opts{'l'}) {
		print $csv $person->xref(), '!',
			$person->as_string({ middle_names => 1, title => 1 }), '!';
		$title = $firstname;
	} else {
		print $csv $person->xref(), '!',
			$person->as_string({ include_years => 1, middle_names => 1, title => 1 }), '!';
		$title = $person->as_string({
			include_years => 1,
			nee => 1,
			middle_names => 1,
			title => 1,
		});
	}

	print "Starting output\n" if($opts{'v'});

	open(my $html, '>', 'static-site/' . make_filename_from_person(person => $person));
	my $xtitle = $title;
	$xtitle =~ s/&eacute;/&#233;/g;
	$xtitle =~ s/\xc3\xab/&#235;/g;	# eumlaut
	print $xml "\n\t\t<entry>", $person->xref(),
		"</entry>\n\t\t<title>$xtitle</title>";
	if($firstname) {
		$firstname =~ s/\xc3\xab/&#235;/g;	# eumlaut
		print $xml "\n\t\t<first_name>$firstname</first_name>";
	}
	if($surname) {
		print $xml "\n\t\t<surname>$surname</surname>";
	}

	if($me && ($person->xref() eq $me->xref())) {
		my $name = $person->as_string(nee => 1);

		open(my $html, '>', 'static-site/index.html');
		print $html "<html><head><title>The Family Tree $name</title>",
			'<meta http-equiv="Refresh" content="1;URL=', make_filename_from_person(person => $person), '">';
		if(my $lang = $ENV{'LANG'}) {
			$lang =~ s/\.UTF-8//;
			$lang =~ tr/_/-/;
			$lang = lc($lang);
			print $html "<meta http-equiv=\"Content-Language\" content=\"$lang\">";
		}
		print $html '</head>',
			"<body><h1>The Family Tree $name</h1><a href=\"", make_filename_from_person(person => $person), "\">$name</a></body></html>";
		close $html;
		print $xml "\n\t\t<home>1</home>";
		print $csv '1!';
	} else {
		print $csv '0!';
	}

	if($opts{'m'}) {
		print $html "<html><head><title>$title</title></head><body onload=\"html_googlemaps_initialize()\"><center><h1>$title</h1>";
	} else {
		if($geolocation_key) {
			die "$0: -G makes no sense without -m";
		}
		print $html "<html><head><title>$title</title></head><body><center><h1>$title</h1>";
	}
	if(defined($me)) {
		print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	if($gedcal) {
		print $html ' | [ <a href="calendar/index.html">Calendar</a> ]';
	}
	print $html ' | [ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="censuses.html">Census Index</a> ]';
	if($opts{'w'}) {
		print $html ' | [ <a href="todo.html">Errors</a> ]';
	}
	print $html ' | [ <a href="history.html">Family History</a> ]</center><p>';

	my $bio;
	my $fullbio;

	if($is_alive && !$opts{'l'}) {
		print $xml "\n\t\t<alive>1</alive>";
		print $csv '1!';
		my $str = '<i>This is the record of a living person, so not much data will be shown.</i></p><p>';
		print $html $str;
		print $csv $str;
		print "Living person\n" if($opts{'v'});
	} else {
		print $csv '0!';
		$surnames->{$surname}->{$title} = $person;
	}

	my ($birth_dt, $marriage_dt, $death_dt);
	my $birth = $person->get_record('birth');
	my $dateofbirth = dateofbirth($person);

	my $placeofbirth = get_value({ person => $person, value => 'birth place' });
	if((!$placeofbirth) && $birth) {
		$placeofbirth = $birth->place();
	}

	if($placeofbirth && ($placeofbirth =~ /[,\.]\s*$/) && ($placeofbirth ne 'U.S.A.')) {
		complain({ person => $person, warning => "Trailing punctuation in birth location, '$placeofbirth'" });
		$placeofbirth =~ s/\s*[,\.]\s*$//;
	}

	my $placeofdeath = get_value({ person => $person, value => 'death place' });
	my $death = $person->get_record('death');
	if((!$placeofdeath) && $death) {
		$placeofdeath = $death->place();
	}

	if($placeofdeath && ($placeofdeath =~ /\s\s/)) {
		complain({ person => $person, warning => 'Removing successive spaces from place of death' });
		$placeofdeath =~ s/\s\s+/ /g;
	}

	if($placeofdeath && ($placeofdeath =~ /,\s*$/)) {
		complain({ person => $person, warning => 'Trailing comma in death location' });
		$placeofdeath =~ s/\s*,\s*$//;
	}
	if($placeofdeath && ($placeofdeath =~ /^,/)) {
		complain({ person => $person, warning => 'Leading comma in death location' });
		1 while($placeofdeath =~ s/^,\s*//g);
	}

	if($is_alive && ($placeofdeath || $dateofdeath)) {
		die "BUG: $title is marked as alive yet we have death information";
	}

	if($opts{'w'}) {
		my $name = $person->name();
		$name =~ s/\///g;
		$nameparser->parse($name);
		my %name_components = $nameparser->components();
		my $firstname = $name_components{'given_name_1'} // $name_components{'initials_1'};
		if($firstname && (my $lastname = $name_components{'surname_1'})) {
			my %chronicling_params = ( ua => $cached_browser );
			if($dateofbirth && ($dateofbirth =~ /(\d{4})$/)) {
				if($1 <= 1789) {
					$chronicling_params{'date_of_birth'} = 1789;
				} else {
					$chronicling_params{'date_of_birth'} = $1;
				}
			}
			if($dateofdeath && ($dateofdeath =~ /(\d{4})$/)) {
				if($1 >= 1963) {
					$chronicling_params{'date_of_death'} = 1963;
				} else {
					$chronicling_params{'date_of_death'} = $1;
				}
			}
			if($firstname) {
				$chronicling_params{'firstname'} = $firstname;
				if($lastname) {
					$chronicling_params{'lastname'} = $lastname;
				}
			}
			my $stateofbirth;
			if($placeofbirth && (($placeofbirth =~ /USA$/) || ($placeofbirth =~ /United States$/)) && ($placeofbirth =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
				$stateofbirth = uc($1);
				if($us->{code2state}{$stateofbirth}) {
					$stateofbirth = $us->{code2state}{$stateofbirth};
				} elsif(!$us->{state2code}{$stateofbirth}) {
					complain({ person => $params{'person'}, warning => "Unknown state '$stateofbirth' in birth place $placeofbirth" });
				}
				$chronicling_params{'state'} = ucfirst(lc($stateofbirth));
				chronicling_america($person, \%chronicling_params);

			}
			if($placeofdeath && (($placeofdeath =~ /USA$/) || ($placeofdeath =~ /United States$/)) && ($placeofdeath =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
				my $stateofdeath = uc($1);
				if($us->{code2state}{$stateofdeath}) {
					$stateofdeath = $us->{code2state}{$stateofdeath};
				} elsif(!$us->{state2code}{$stateofdeath}) {
					complain({ person => $params{'person'}, warning => "Unknown state '$stateofdeath' in death place $placeofbirth" });
				}
				if((!defined($stateofbirth)) || (lc($stateofdeath) ne lc($stateofbirth))) {
					$chronicling_params{'state'} = ucfirst(lc($stateofdeath));
					# TODO: married and maiden names, could be two searches
					chronicling_america($person, \%chronicling_params);
				}
			}
		}
	}
	my %citations;
	my $citationcount = 0;
	my @birthcitations;
	my @deathcitations;
	if($opts{'c'}) {
		if($birth) {
			if($opts{'w'}) {
				foreach my $s($birth->source()) {
					if(!defined(get_source({ gedcom => $ged, person => $person, source => $s }))) {
						complain({ person => $person, warning => 'Citation is missing a source' });
					}
				}
			}
			my @s = sort { (get_source({ gedcom => $ged, person => $person, source => $a }) && get_source({ gedcom => $ged, person => $person, source => $b })) ? get_source({ gedcom => $ged, person => $person, source => $a })->title() cmp get_source({ gedcom => $ged, person => $person, source => $b })->title() : 0 } $birth->source();
			if(scalar(@s)) {
				my $previous;
				foreach my $src(@s) {
					# $src = $ged->get_source($src) unless ref($src);
					$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
					if(defined($src) && (my $title = $src->title())) {
						next if($previous && ($title eq $previous));
						$previous = $title;
						push @birthcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
			} elsif($opts{'w'} && ($opts{'l'} || !$is_alive)) {
				if($dateofbirth) {
					red_warning({ person => $person, warning => "Birth date ($dateofbirth) has no citations" });
				} elsif($placeofbirth) {
					complain({ person => $person, warning => "Birth place ($placeofbirth) has no citations" });
				} else {
					complain({ person => $person, warning => 'Birth record has no citations' });
				}
			}
		}
		if($death) {
			my @s = $death->source();
			if(scalar(@s)) {
				foreach my $src(@s) {
					$src = $ged->get_source($src) unless ref($src);
					my $seen;
					foreach my $bc(@birthcitations) {
						if($src eq $citations{$bc}) {
							push @deathcitations, $bc;
							$seen++;
							last;
						}
					}
					if(!$seen) {
						push @deathcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
			} elsif($opts{'l'} || !is_alive(person => $person)) {
				if($dateofdeath) {
					# my $dateismissing = 0;
					# my @objects = $person->obje();
					# foreach my $o(@objects) {
						# my $obje;
						# if(ref($o) eq 'Gedcom::Record') {
							# $obje = $o;	# e.g. Ancestry
						# } else {
							# $obje = $ged->resolve_xref($o);	# e.g. FMP
						# }
						# foreach my $item($obje->items()) {
							# next if($item->tag() ne '_DATE');
							# if($item->value() eq $dateofdeath) {
								# $dateismissing = 0;
								# last;
							# }
						# }
					# }
					# if($dateismissing) {
						complain({ person => $person, warning => "Death date ($dateofdeath) has no citations" });
					# }
				} elsif($placeofdeath) {
					complain({ person => $person, warning => "Death place ($placeofdeath) has no citations" });
				} else {
					complain({ person => $person, warning => 'Death record exists with no date or place' });
				}
			}
		}
	}

	# $fetcher->prime(object => $person, message => 'sex')->prime(object => $person, message => 'pronoun');

	my $baptism = $person->get_record('baptism');
	my $dateofbaptism = get_value({ person => $person, value => 'baptism date' });
	if((!$dateofbaptism) && $baptism) {
		$dateofbaptism = $baptism->date();
	}
	my $placeofbaptism = get_value({ person => $person, value => 'baptism place' });
	if((!$placeofbaptism) && $baptism) {
		$placeofbaptism = $baptism->place();
	}

	my @events = $person->event();

	my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage');
	if((!defined($marriage)) && scalar(@spouses)) {
		$marriage = $spouses[0]->get_record('marriage');
		if((!defined($marriage)) && scalar(@spouses)) {
			if(scalar(@events) == 1) {
				my $event = $person->event();
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN');
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					}
				}
				if((ref($event) eq 'Gedcom::Record') &&
				  ($event->type() eq 'Custom Marriage')) {
					# FindMyPast
					$marriage = $event;
				}
			} else {
				foreach my $event(@events) {
					if((ref($event) eq 'Gedcom::Record') &&
					  ($event->type() eq 'Custom Marriage')) {
						# FindMyPast
						$marriage = $event;
						last;
					}
				}
			}
		}
	}
	my $placeofmarriage = get_value({ person => $person, value => 'marriage place' });
	if((!$placeofmarriage) && $marriage) {
		$placeofmarriage = $marriage->place();
	}
	if($placeofmarriage && ($placeofmarriage =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'Scot') {
			complain({ person => $person, warning => "$c: marriage country should be Scotland'" });
			$placeofmarriage .= 'land';
		}
	}

	my $burial;
	my $dateofburial;
	my $placeofburial;
	my $cremation;
	my $dateofcremation;
	my $placeofcremation;
	if($burial = $person->get_record('burial')) {
		$dateofburial = get_value({ person => $person, value => 'burial date' });
		if(!$dateofburial) {
			$dateofburial = $burial->date();
		}
		$placeofburial = get_value({ person => $person, value => 'burial place' });
		if(!$placeofburial) {
			$placeofburial = $burial->place();
		}
	} elsif($cremation = $person->get_record('cremation')) {
		$dateofcremation = get_value({ person => $person, value => 'cremation date' });
		if(!$dateofcremation) {
			$dateofcremation = $cremation->date();
		}
		$placeofcremation = get_value({ person => $person, value => 'cremation place' });
		if(!$placeofcremation) {
			$placeofcremation = $cremation->place();
		}
	}

	if($is_alive && ($placeofburial || $dateofburial)) {
		die "BUG: $title is marked as alive yet we have burial information";
	}

	# Don't match date ranges
	if($dateofbirth && ($dateofbirth !~ /\d{4}.+\d{4}/) &&
	  ($birth_dt = $dfg->parse_datetime(date => $dateofbirth, quiet => 1))) {
		if(defined($facts->{'first_birth'})) {
			if($birth_dt < $facts->{'first_birth'}->{'date'}) {
				$facts->{'first_birth'}->{'date'} = $birth_dt;
				$facts->{'first_birth'}->{'xref'} = $person->xref();
			}
		} else {
			$facts->{'first_birth'}->{'date'} = $birth_dt;
			$facts->{'first_birth'}->{'xref'} = $person->xref();
		}

		if($birth_dt && (my $spouse = $spouses[0])) {
			my $sdob = dateofbirth($spouse);
			if($sdob && (my $sbirth_dt = date_to_datetime(date => $sdob))) {
				if($sbirth_dt > ($birth_dt + $fortyyears)) {
					complain({
						person => $person,
						warning => 'Spouse born more than 40 years after date of birth'
					});
				} elsif($birth_dt > ($sbirth_dt + $fortyyears)) {
					complain({
						person => $person,
						warning => 'Born more than 40 years after date of birth of spouse'
					});
				}
			}
		}
	}

	my $dateofmarriage = get_value({ person => $person, value => 'marriage date' });
	if((!$dateofmarriage) && $marriage) {
		$dateofmarriage = $marriage->date();
	}
	if($dateofmarriage && ($dateofmarriage =~ /\d$/)) {
		$marriage_dt = $dfg->parse_datetime(date => $dateofmarriage, quiet => 1);
	}

	if($birth_dt && $marriage_dt && $opts{'w'} && ($marriage_dt < ($birth_dt + $sixteenyears))) {
		complain({
			person => $person,
			warning => 'married when less than 16 years old'
		});
	}
	# Don't match date ranges
	if($dateofdeath && ($dateofdeath !~ /\d{4}.+\d{4}/)) {
		$death_dt = $dfg->parse_datetime(date => $dateofdeath, quiet => 1);
	}

	if($birth_dt && $death_dt) {
		my $age_at_death = $death_dt - $birth_dt;
		if(defined($facts->{'oldest_age'})) {
			# FIXME: Handle when there are more than one person with this age
			# FIXME: add base_datetime argument
			if(DateTime::Duration->compare($age_at_death, $facts->{'oldest_age'}->{'age'}) > 0) {
				$facts->{'oldest_age'}->{'age'} = $age_at_death;
				$facts->{'oldest_age'}->{'xref'} = $person->xref();
			}
		} else {
			$facts->{'oldest_age'}->{'age'} = $age_at_death;
			$facts->{'oldest_age'}->{'xref'} = $person->xref();
		}
	}

	if($opts{'l'} || !$is_alive) {
		# RT114091
		if($birth_dt && ($birth_dt >= $year_1000)) {
			$all_events{'B' . $person->xref()} = { person => $person, event => 'Birth', date => $birth_dt };
		}
		if($marriage_dt && ($marriage_dt >= $year_1000)) {
			$all_events{'M' . $person->xref()} = { person => $person, event => 'Marriage', date => $marriage_dt };
		}
		if($death_dt && ($death_dt >= $year_1000)) {
			$all_events{'D' . $person->xref()} = { person => $person, event => 'Death', date => $death_dt };
		}
	}

	my %place_records;

	if($placeofbirth) {
		$place_records{'Birth'} = $birth;
	}
	if($placeofbaptism) {
		if($ENV{'LANG'} =~ /^en_US/) {
			$place_records{'Baptized'} = $baptism;
		} else {
			$place_records{'Baptised'} = $baptism;
		}
	}
	if($placeofmarriage) {
		$place_records{'Marriage'} = $marriage;
	}
	if($placeofdeath) {
		$place_records{'Death'} = $death;
	}
	if($placeofburial) {
		$place_records{'Burial'} = $burial;
	}

	my $marriagecitation;
	my @burialcitations;
	if($opts{'c'}) {
		if($marriage) {
			print "Check marriage source\n" if($opts{'v'});
			if(my $src = $marriage->source()) {
				$src = $ged->get_source($src) unless ref($src);
				# FIXME:  Only looks for matches in the first citations
				if(!defined($src)) {
					my $src = $marriage->source();
					complain({ person => $person, warning => "marriage citation can't find source $src" });
				} elsif($birthcitations[0] && ($citations{$birthcitations[0]} eq $src)) {
					$marriagecitation = $birthcitations[0];
				} elsif($birthcitations[1] && ($citations{$birthcitations[1]} eq $src)) {
					$marriagecitation = $birthcitations[1];
				} elsif($deathcitations[0] && ($citations{$deathcitations[0]} eq $src)) {
					$marriagecitation = $deathcitations[0];
				} else {
					$marriagecitation = ++$citationcount;
					$citations{$marriagecitation} = $src;
				}
			} elsif($opts{'w'} && ($opts{'l'} || !$is_alive)) {
				if($dateofmarriage) {
					red_warning({ person => $person, warning => "Marriage date ($dateofmarriage) has no citations" });
				} elsif($placeofmarriage) {
					red_warning({ person => $person, warning => "Marriage place ($placeofmarriage) has no citations" });
				} else {
					red_warning({ person => $person, warning => 'Marriage record has no citations' });
				}
			}
		}
		if($burial) {
			print "Check burial source\n" if($opts{'v'});
			my @s = $burial->source();
			if(scalar(@s)) {
				foreach my $src(@s) {
					$src = $ged->get_source($src) unless ref($src);
					if(!defined($src)) {
						my $src = $burial->source();
						complain({ person => $person, warning => "burial citation can't find source $src" });
						next;
					}
					my $seen;
					foreach my $dc(@deathcitations) {
						if($src eq $citations{$dc}) {
							push @burialcitations, $dc;
							$seen++;
							last;
						}
					}
					if(!$seen) {
						if($marriagecitation && ($citations{$marriagecitation} eq $src)) {
							push @burialcitations, $marriagecitation;
						} else {
							push @burialcitations, ++$citationcount;
							$citations{$citationcount} = $src;
						}
					}
				}
			} elsif($opts{'w'} && ($opts{'l'} || !$is_alive)) {
				if($dateofburial) {
					complain({ person => $person, warning => "Burial date ($dateofburial) has no citations" });
				} elsif($dateofcremation) {
					complain({ person => $person, warning => "Cremation date ($dateofcremation) has no citations" });
				} elsif($placeofburial) {
					complain({ person => $person, warning => "Burial place ($placeofburial) has no citations" });
				} else {
					complain({ person => $person, warning => "Cremation place ($placeofcremation) has no citations" });
				}
			}
		}
	}

	my $pronoun = $person->pronoun();
	my $sex = $person->sex();

	$facts->{'count'}++;
	$facts->{'sex'}->{$sex}++;

	if($opts{'w'} && $firstname) {
		# FIXME: This throws up a number of false positives
		my $guess;
		if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
			$guess = Text::Names::guessGender($firstname);
		} else {
			$guess = Text::Names::GB::guessGender($firstname);
		}
		if($sex && $guess && ($sex ne $guess)) {
			my $error = 1;
			if(my $middle_name = $name_components{'middle_name'}) {
				if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
					$guess = Text::Names::guessGender($middle_name);
				} else {
					$guess = Text::Names::GB::guessGender($middle_name);
				}
				if($guess && ($sex eq $guess)) {
					$error = 0;
				}
			}
			if($error) {
				complain({ person => $person, warning => 'Check the gender of the record' });
			}
		}
	}
	my @children = map { $_->children() } $person->fams();
	my $numberofchildren = scalar(@children);

	if($opts{'w'} && $numberofchildren) {
		foreach my $child(@children) {
			if($child->xref() eq $person->xref()) {
				complain({ person => $person, warning => 'person is own parent' });
				# Avoid loops in G::I::Relationship
				return;
			}
		}
	}

	print "numberofchildren = $numberofchildren\n" if($opts{'v'});

	my $relationship;
	my $spouserelationship;
	my $spouse;
	my %places_printed;

	if($dateofbirth && $opts{'w'} && scalar(@siblings)) {
		print 'Found ', scalar(@siblings), " siblings(s)\n" if($opts{'v'});
		foreach my $sibling(@siblings) {
			if(($sibling->name() eq $person->name()) || Text::Names::samePerson($sibling->name(), $person->name())) {
				my $siblingbirth = dateofbirth($sibling);
				if($siblingbirth && ($siblingbirth eq $dateofbirth)) {
					complain({ person => $sibling, warning => 'possible duplicate person' });
				} elsif((!$dateofdeath) && !dateofdeath($sibling)) {
					complain({ person => $sibling, warning => 'two siblings of the same name alive at the same time'});
				}
			}
		}
	}

	if($me && ($person->xref() ne $me->xref())) {
		print "find relationship\n" if($opts{'v'});
		$relationship = $me->relationship($person);
		if((!$relationship) && scalar(@spouses)) {
			print "find spousal relationship\n" if($opts{'v'});
			if($spouses[0] eq $me) {
				$relationship = ($sex eq 'F') ? 'wife' : 'husband';
			} else {
				foreach my $s(@spouses) {
					$spouserelationship = $me->relationship($s);
					if($spouserelationship) {
						$spouse = $s;
						last;
					}
				}
			}
		}
		if((!$relationship) && (!$spouserelationship)) {
			complain({
				person => $person,
				warning => "Can't find relationship with the home person"
			});
		}
		print 'relationship = ', ($relationship ? $relationship : 'unknown'), "\n" if($opts{'v'});
		if(my $r = $relationship) {
			# Remove spaces from the relationship so that the Template Toolkit can
			# use it as a key
			$r =~ s/ /_/g;
			$facts->{'relations'}->{$r}++;
		}
	}

	if(($dateofbaptism || $placeofbaptism) && !($mother || $father) && $relationship) {
		complain({ person => $person, warning => 'Baptism information not used to determine a parent' });
	}

	my @occupations = get_all_occupations($person);

	print 'Found ', scalar(@occupations), " occupation(s)\n" if($opts{'v'});

	my $same_occupation_as_father;
	my $printed_comma = 0;

	if($occupations[0]) {
		my @foccupations;
		if($father) {
			@foccupations = get_all_occupations(person => $father);
		}
		if(scalar(@foccupations) && ($occupations[0] eq $foccupations[0])) {
			$same_occupation_as_father = $occupations[0];
			@occupations = ();
		} else {
			$bio = 'A';
			if($occupations[0] =~ /^[aeiou]/i) {
				$bio .= 'n';
			}
			$bio .= ' ';
			if($occupations[1]) {
				# my $alloccupations = join(', ', @occupations);
				# substr($alloccupations, rindex($alloccupations, ', '), 2, ' and ');
				# $bio .= HTML::Entities::encode(lc($alloccupations));
				$bio .= lc(Lingua::EN::Inflect::WORDLIST(@occupations, {final_sep => ''}));
			} else {
				$bio .= lc($occupations[0]);
			}
			if(!($father || $mother || $spouserelationship)) {
				$bio .= ', ';
				$printed_comma = 1;
			}
		}
	}

	my @person_twins;
	if($birth_dt && ($opts{'l'} || !$is_alive)) {
		foreach my $s(@siblings) {
			if(my $dob = dateofbirth($s)) {
				if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
					my $d;
					eval {
						$d = $date_parser->parse(date => $dob);
					};
					if($d) {
						if($d = @{$d}[0]) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if(($d == $birth_dt) || ($d == ($birth_dt - $oneday)) || ($d == ($birth_dt + $oneday))) {
								push @person_twins, $s;
								$twins{$person->xref()} = $s->xref();
							}
						}
					}
				}
			}
		}
		if(scalar(@person_twins) == 1) {	# TODO triplets and higher order
			if(scalar(@occupations)) {
				$bio .= ', twin of ' . $person_twins[0]->given_names();
			} else {
				$bio .= 'The twin ' . (($person->sex() eq 'M') ? 'brother' : 'sister') .
					' of ' . $person_twins[0]->given_names();
			}
			$printed_comma = 0;
		}
	}

	print $xml "\n\t\t<bio>\n\t\t\t<en>\n\t\t\t\t";

	my $print_sibling_count = 0;
	my $html_and_csv = File::Print::Many->new([$csv, $html]);
	# my $html_and_xml = File::Print::Many->new([$xml, $html]);
	my $all = File::Print::Many->new([$xml, $html, $csv]);

	if($father || $mother) {
		if(scalar(@occupations) || scalar(@person_twins)) {
			$bio .= ' and the ';
		} else {
			$bio = 'The ';
		}

		if($birth_dt && ($opts{'l'} || !$is_alive)) {
			if(scalar(@siblings)) {
				# If possible, sort siblings by date of birth
				my $all_siblings_have_dob = 1;
				foreach my $sibling(@siblings) {
					if(my $dob = dateofbirth($sibling)) {
						if(($dob !~ /^\d/) || ($dob =~ /[a-z]$/i) ||
						   ($dob =~ /[\/\-]/) || !date_parser_cached(date => $dob)) {
							$all_siblings_have_dob = 0;
							last;
						}
						if(!date_parser_cached(date => $dob)) {
							complain({
								person => $sibling,
								warning => "has an invalid date of birth: $dob"
							});
							$all_siblings_have_dob = 0;
							last;
						}
					} else {
						$all_siblings_have_dob = 0;
						last;
					}
				}
				if($all_siblings_have_dob) {
					@siblings = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => dateofbirth($_))}[0]->{'canonical'}) } @siblings;
				}
				my $age_index = 1;	# count of siblings born before $person + 1 (i.e. where $person is in the date order)
				$print_sibling_count = 1;
				foreach my $sibling(@siblings) {
					if(my $dob = dateofbirth($sibling)) {
						if(my $d = date_parser_cached(date => $dob)) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if($opts{'w'} &&
							  ($dob =~ /^\d/) && ($dob !~ /[a-z]$/i) &&
							  ($d < $birth_dt) &&
							  ($d < ($birth_dt - $oneday)) &&
							  ($d > ($birth_dt - $tenmonths))) {
								complain({
									person => $sibling,
									warning => 'Born less than 10 months before sibling ' . $person->as_string()
								});
							}
							$age_index++ if($d && ($d < $birth_dt));
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					} else {
						$all_siblings_have_dob = 0;
						last;
				}
				}
				if($all_siblings_have_dob) {
					if(scalar(@siblings) && ($age_index == (scalar(@siblings) + 1))) {
						$bio .= ((scalar(@siblings) > 1) ? 'youngest' : 'younger');
					} elsif(scalar(@siblings) && ($age_index == 1)) {
						$bio .= ((scalar(@siblings) > 1) ? 'eldest' : 'older');
					} else {
						$bio .= ordinate($age_index);
					}
					$bio .= ' of ' . (scalar(@siblings) + 1) . ' children';
				} else {
					$bio .= 'child';
				}
			} else {
				# $bio .= ' only child of';
				$bio .= 'child';
			}
		} else {
			$bio .= 'child';
		}

		$bio .= ' of';

		print $csv $bio;
		$bio =~ s/\s&\s/ &amp; /g;
		print $html $bio;
		$bio =~ s/&eacute;/&#233;/g;
		print $xml $bio;

		$fullbio = $bio;
		$bio = undef;

		if($opts{'l'} || !$is_alive) {
			if($father) {
				print $html ' <a href="', make_filename_from_person(person => $father), '">',
					$father->as_string(),
					'</a>';
				print $xml ' &lt;a href="?page=people&amp;entry=', $father->xref(), '"&gt;'.
					$father->as_string(),
					'$lt;/a$gt;';
				print $csv ' <a href="?page=people&entry=', $father->xref(), '">'.
					$father->as_string(),
					'</a>';

				if(!$same_occupation_as_father) {
					my @occupations = get_all_occupations(person => $father);
					# TODO: print all occupations
					if(my $occupation = $occupations[0]) {
						$all->print(' (', HTML::Entities::encode(Lingua::EN::Inflect::A(lc($occupation))), ')');
					}
				}
				$fullbio .= ' ' . $father->as_string();
				if($mother) {
					$all->print(' and');
					$fullbio .= ' and';
				}
			}
			if($mother) {
				if(my $m = $mother->as_string(give_maidenname => 0)) {
					print $html ' <a href="', make_filename_from_person(person => $mother), "\">$m</a>";
					print $csv ' <a href="?page=people&entry=', $mother->xref(), "\">$m</a>";
					print $xml ' &lt;a href="?page=people&amp;entry=', $mother->xref(), "\"&gt;$m&lt;/a&gt;";
				}

				my @occupations = get_all_occupations($mother);
				# TODO: print all occupations
				if($occupations[0]) {
					$all->print(' (', Lingua::EN::Inflect::A(lc($occupations[0])), ')');
				}
				$fullbio .= ' ' . $mother->as_string();
				if($opts{'w'} && $birth_dt && (my $mdod = dateofdeath($mother))) {
					if(my $dt = date_to_datetime(date => $mdod)) {
						if($birth_dt > $dt) {
							complain({ person => $person, warning => 'Born after mother died' });
						}
					}
				}
			}
		} else {
			if($father) {
				print $html ' <a href="', make_filename_from_person(person => $father), '">',
					$father->given_names(),
					'</a>';
				print $csv ' <a href="?page=people&entry=', $father->xref(), '">',
					$father->given_names(),
					'</a>';
				print $xml ' &lt;a href="?page=people&amp;entry=', $father->xref(), '"&gt;',
					$father->given_names(),
					'&lt;/a&gt;';
				if($mother) {
					$all->print(' and');
				}
			}
			if($mother) {
				print $html ' <a href="', make_filename_from_person(person => $mother), '">',
					$mother->given_names(),
					'</a>';
				print $csv ' <a href="?page=people&entry=', $mother->xref(), '">',
					$mother->given_names(),
					'</a>';
				print $xml ' &lt;a href="?page=people&amp;entry=', $mother->xref(), '"&gt;',
					$mother->given_names(),
					'&lt;/a&gt;';
			}
		}
		$printed_comma = 0;
	}

	if($firstname) {
		if((!$is_alive) || $opts{'l'} || (!defined($me)) || ($person->xref() ne $me->xref())) {
			if($opts{'l'} || $is_alive) {
				if($relationship) {
					$bio .= ', ' if(($mother || $father) && !$printed_comma);
					$bio .= "<b>$firstname</b>";
					if(($dob || $marriage) && (!($is_alive || $opts{'l'}))) {
						$bio .= ',';
					} elsif($is_alive) {
						$bio .= ' is';
					} else {
						$bio .= ' was';
					}
				}
			} else {
				if($father || $mother || $occupations[0]) {
					$bio .= ', ' if(!$printed_comma);
				}
				if($name_components{'surname_1'}) {
					$bio .= "<b>$firstname " .
						$name_components{'surname_1'} .
						'</b>';
				} else {
					$bio .= "<b>$firstname</b>";
				}
				if($relationship) {
					if($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || scalar(@spouses)) {
						$bio .= ',';
					} elsif($opts{'l'} || $is_alive) {
						$bio .= ' is';
					} else {
						$bio .= ' was';
					}
				}
			}
		}
	} else {
		$bio .= $pronoun;
	}

	if($bio) {
		$html_and_csv->print($bio);
		print $xml HTML::Entities::encode($bio);

		$fullbio .= $bio;
	}
	$bio = '';

	my $haveprintedspousename;
	if($relationship) {
		print $html " the $relationship of ",
			'<a href="', make_filename_from_person(person => $me), '">',
			$me->as_string(nee => 1),
			'</a>';
		print $csv " the $relationship of ",
			'<a href="?page=people&home=1">',
			$me->as_string(nee => 1),
			'</a>';
		print $xml " the $relationship of ",
			'&lt;a href="?page=people&amp;home=1"&gt;',
			$me->as_string(nee => 1),
			'&lt;/a&gt;';
	} elsif($spouserelationship) {
		if($sex eq 'F') {
			$all->print(', the wife of');
		} else {
			$all->print(', the husband of');
		}
		my $s = $spouse->as_string({ middle_names => 1, title => 1 });
		if(!defined($s)) {
			complain({ person => $spouse, warning => 'Seems to have no name' });
			$s = 'your relation';
		}
		print $html ' <a href="', make_filename_from_person(person => $spouse), '">',
			"$s</a> the $spouserelationship of ",
			'<a href="', make_filename_from_person(person => $me), '">',
			$me->as_string(nee => 1),
			'</a>';
		print $csv ' <a href="?page=people&entry=', $spouse->xref(), '">',
			"$s</a> the $spouserelationship of ",
			'<a href="?page=people&home=1">',
			$me->as_string(nee => 1),
			'</a>';
		$s =~ s/\xc3\xab/&#235;/g;	# eumlaut
		print $xml ' &lt;a href="?page=people&amp;entry=', $spouse->xref(), '"&gt;',
			"$s&lt;/a&gt; the $spouserelationship of ",
			'&lt;a href="?page=people&amp;home=1"&gt;',
			$me->as_string(nee => 1),
			'&lt;/a&gt;';
		if($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $dateofmarriage) {
			print $html ',';
			print $csv ',';
			print $xml ',';
		}
		$haveprintedspousename = 1;
	}

	if(my $aka = $person->as_string({ use_aka => 1 })) {
		$html_and_csv->print(" (also known as $aka)");
		$aka =~ s/&eacute;/&#233;/g;
		print $xml " (also known as $aka)";
	}

	my $end_of_sentence = 0;

	my @childrenunknownparent;
	my @residences = get_all_residences($person);
	if($opts{'l'} || !$is_alive) {
		my $all_children_are_alive = 1;

		if($yob && ($year >= $yob + 150)) {
			$all_children_are_alive = 0;
		} else {
			foreach my $child(@children) {
				if(!is_alive(person => $child)) {
					$all_children_are_alive = 0;
					last;
				}
			}
		}

		if(($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism)) {
			if($dateofbirth || $placeofbirth) {
				# print $html ',' if($print_sibling_count && (!$opts{'a'}) && !$opts{'p'});

				$bio = ',' if($relationship);
				$bio .= ' was born';
				if($placeofbirth) {
					my $p = place({ person => $person, place => $placeofbirth });
					$bio .= $p;
					$places_printed{$p} = 1;
				} else {
					complain({ person => $person, warning => 'Date of birth is known, but not place' });
				}
				if($dateofbirth) {
					my $y = year({
						person => $person,
						date => $dateofbirth,
						must_predate => $death_dt
					});
					if($y =~ /^fro?m (.+) to (.+)/i) {
						$y = "between $1 and $2";
					}
					$bio .= " $y" if($y);
				}
				$bio .= cite(@birthcitations);
				if($dateofbaptism || $placeofbaptism) {
					if(scalar(@spouses) && ($numberofchildren > 0)) {
						$bio .= ', was';
					} else {
						$bio .= ' and';
					}
				}
				$end_of_sentence = 0;
			}
			if($opts{'w'}) {
				if($mother && $yob && (my $mumdateofbirth = dateofbirth($mother))) {
					if($mumdateofbirth =~ /.*?(\d{3,4})/) {
						$mumdateofbirth = $1;
						if(($yob - $mumdateofbirth) <= 13) {
							complain({
								person => $person,
								warning => "Something is wrong with the date of birth which is less than 13 years after the mother was born ($mumdateofbirth)"
							});
						} elsif(($yob - $mumdateofbirth) >= 52) {
							complain({
								person => $person,
								warning => "Something is wrong with the date of birth which is more than 52 years after the mother was born ($mumdateofbirth)"
							});
						}
					}
				}
				if($father && $yob && (my $daddateofbirth = dateofbirth($father))) {
					if($daddateofbirth =~ /.*?(\d{3,4})/) {
						$daddateofbirth = $1;
						if(($yob - $daddateofbirth) <= 13) {
							complain({
								person => $person,
								warning => "Something is wrong with the date of birth which is less than 13 years after the father was born ($daddateofbirth)"
							});
						}
					}
				}
				if($death_dt || ($dateofdeath && ($dateofdeath =~ /^\d{3,4}$/))) {
					my $yod;
					# TODO: Add more checking
					if($death_dt) {
						$yod = $death_dt->year();
					} elsif($dateofdeath =~ /^(\d{3,4})$/) {
						$yod = $1;
					} else {
						die "BUG: Impossible case";
					}
					foreach my $bc(@birthcitations) {
						my $citation = $citations{$bc};
						my $title = $citation->title();
						if($title =~ /^(\d{3,4})\s/) {
							if($1 > $yod) {
								complain({
									person => $person,
									warning => "Year of citation of $title is after the death year of $yod"
								});
							}
						}
					}
				}
			}
			if($dateofbaptism || $placeofbaptism) {
				$bio .= ' ';
				unless($dateofbirth || $placeofbirth) {
					if($numberofchildren == 0) {
						$bio .= 'and ';
					}
					$bio .= 'was ';
				}
				if($ENV{'LANG'} =~ /^en_US/) {
					$bio .= 'baptized';
				} else {
					$bio .= 'baptised';
				}
				if($placeofbaptism) {
					if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
						$bio .= ' there';
						if(my $address = $baptism->address()) {
							if($address =~ /(.+),\s*$placeofbirth$/) {
								$address = $1;
							}
							$bio .= " at $address";
						}
					} else {
						my $p = place({ person => $person, place => $placeofbaptism });
						$bio .= $p;
						$places_printed{$p} = 1;
					}
				}
				if($dateofbaptism) {
					if($opts{'w'} && $yob && ($dateofbaptism =~ /(\d{3,4})$/)) {
						# must_predate doesn't work when only years are known
						if($1 < $yob) {
							if($opts{'f'}) {
								die $person->as_string(), ": Year of baptism $1 is before the year of birth $yob";
							}
							red_warning({
								person => $person,
								warning => "Year of baptism $1 is before the year of birth $yob"
							});
						}
					}
					$bio .= ' ' . year({
						person => $person,
						date => $dateofbaptism,
						must_postdate => $birth_dt,
						must_predate => $death_dt
					}) . sibling_baptism_string({
						person => $person,
						siblings => \@siblings,
						date => $dateofbaptism,
						birthdate => $dateofbirth,
					});
				}
			} elsif($birth_dt) {
				my @person_twins;
				foreach my $s(@siblings) {
					if(my $dob = dateofbirth($s)) {
						if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
							my $d;
							eval {
								$d = $date_parser->parse(date => $dob);
							};
							if($d) {
								$d = @{$d}[0];
							}
							if($d) {
								$d = $dfn->parse_datetime($d->{'canonical'});
								if(($d == $birth_dt) || ($d == ($birth_dt - $oneday)) || ($d == ($birth_dt + $oneday))) {
									push @person_twins, { sibling => $s, dob => $d };
									if($opts{'l'} || !$is_alive) {
										$twins{$person->xref()} = $s->xref();
									}
								}
							}
						}
					}
				}
				if(scalar(@person_twins) == 1) {	# TODO triplets and higher order
					my $t = $person_twins[0];
					my $sibling = $t->{'sibling'};
					my $dob = $t->{'dob'};
					if($dob == $birth_dt) {
						$bio .= ', the same day as ';
					} elsif($dob == ($birth_dt + $oneday)) {
						$bio .= ', a day before ';
					} else {
						$bio .= ', a day after ';
					}
					$bio .= ($sex eq 'M' ? 'his' : 'her') . ' twin ' .
						(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
						$sibling->given_names();
				}
			}

			if(scalar(@spouses) && ($numberofchildren > 0) && !$all_children_are_alive) {
				# $bio .= ' and';
			} else {
				$bio .= '.';
				$end_of_sentence = 1;
			}
		} elsif($dateofbaptism || $placeofbaptism) {
			$bio .= " $pronoun was ";

			if($ENV{'LANG'} =~ /^en_US/) {
				$bio .= 'baptized';
			} else {
				$bio .= 'baptised';
			}
			if($placeofbaptism) {
				if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
					$bio .= ' there';
					if(my $address = $baptism->address()) {
						$bio .= " at $address";
					}
				} else {
					my $opts = {
						person => $person,
						place => $placeofbaptism,
						places_printed => \%places_printed
					};
					if(my $address = $baptism->address()) {
						$opts->{'address'} = $address;
					}
					my $p = place($opts);
					$bio .= $p;
					$places_printed{$p} = 1;
				}
			}
			if($dateofbaptism) {
				$bio .= ' ' . year({
					person => $person,
					date => $dateofbaptism,
					must_postdate => $birth_dt,
					must_predate => $death_dt
				}) . sibling_baptism_string({
					person => $person,
					siblings => \@siblings,
					date => $dateofbaptism,
					birthdate => $dateofbirth,
				});
			}
			if(scalar(@spouses)) {
				if(!scalar(@residences)) {
					$bio .= ',';
				}
				$end_of_sentence = 0;
			} else {
				$bio .= '.';
				$end_of_sentence = 1;
			}
		}

		print "bio so far: $bio\n" if($opts{'v'});

		my @education = $person->education();

		if(scalar(@education)) {
			if($end_of_sentence) {
				$bio .= " $pronoun";
			}
			# FIXME: do all schools
			$bio .= ' went to'.
				place({ person => $person, record => $education[0], places_printed => \%places_printed, nopreposition => 1 }) .
				'. ';
			$end_of_sentence = 1;
		}

		# TODO: children != 0 && spouses == 0
		if(scalar(@spouses) &&
		   ((!$spouserelationship) || $placeofmarriage || $dateofmarriage)) {
			$bio .= '<p>' . ucfirst($pronoun) if($end_of_sentence);

			if(scalar(@spouses) == 1) {
				if((!$end_of_sentence) &&
				   ((scalar(@residences) > 0) || ((!($dateofbaptism)) && !$placeofbaptism))) {
					$bio .= ' and';
				}
				if($placeofmarriage || $dateofmarriage) {
					if($placeofbaptism && $placeofmarriage && ($placeofmarriage eq $placeofbaptism) &&
					   !$end_of_sentence) {
						$bio .= ' also';
					}
					$bio .= ' married ';
				} else {
					$bio .= ' was married to ';
				}
				if($haveprintedspousename) {
					$nameparser->parse($spouses[0]->name());

					my %name_components = $nameparser->components();
					if(my $n = $name_components{'given_name_1'}) {
						$bio .= $n;
					} else {
						complain({ person => $spouses[0], warning => 'seems to have no first name' });
					}
				} else {
					$html_and_csv->print($bio);
					$bio =~ s/&/&amp;/g;
					$bio =~ s/</&lt;/g;
					$bio =~ s/>/&gt;/g;
					$bio =~ s/&amp;amp;/&amp;/g;	# Because of the Encode entities
					print $xml $bio;

					$fullbio .= $bio . $spouses[0]->as_string();
					$bio = '';

					if($opts{'l'} || !$is_alive) {
						print $html '<a href="', make_filename_from_person(person => $spouses[0]), '">',
							$spouses[0]->as_string(),
							'</a>';
						print $csv '<a href="?page=people&entry=', $spouses[0]->xref(), '">',
							$spouses[0]->as_string(),
							'</a>';
						print $xml '&lt;a href="?page=people&amp;entry=', $spouses[0]->xref(), '"&gt;',
							$spouses[0]->as_string(),
							'&lt;/a&gt;';
					} else {
						print $html '<a href="', make_filename_from_person(person => $spouses[0]), '">',
							$spouses[0]->given_names(),
							'</a>';
						print $csv '<a href="?page=people&entry=', $spouses[0]->xref(), '">',
							$spouses[0]->given_names(),
							'</a>';
						print $xml '&lt;a href="?page=people&amp;entry=', $spouses[0]->xref(), '"&gt;',
							$spouses[0]->given_names(),
							'&lt;/a&gt;';
					}
					$haveprintedspousename = 1;
				}
				my $parentheses = 0;
				if($numberofchildren) {
					# if((!$placeofmarriage) && !$dateofmarriage) {
						# $bio .= ', ';
					# }
					my @spouse_occupations = get_all_occupations($spouses[0]);
					if(my $soccupation = $spouse_occupations[0]) {
						$parentheses = 1;
						$bio .= ' (' .
							Lingua::EN::Inflect::A(lc($soccupation)) .
							' ';
					}
					my @childrenofthisspouse;
					my $numberofchildrenwiththisspouse = $numberofchildren;
					my $spouse = $spouses[0];
					foreach my $child(@children) {
						if($sex eq 'F') {
							# Check through all possible fathers, since there could be a biologial and
							# and adoptive one listed
							# FIXME: this assumes that the spouse is the biological father, which is not
							#	a good assumption to make
							my @candidates = $child->father();
							my $father;
							foreach (@candidates) {
								if($_ eq $spouse) {
									$father = $_;
									last;
								}
							}
							if((!defined($father)) || ($father ne $spouse)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						} else {
							my $mother = $child->mother();
							if((!defined($mother)) || ($mother ne $spouse)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						}
					}
					if(scalar(@childrenunknownparent) < $numberofchildren) {
						if(!$parentheses) {
							$bio .= ' (';
							$parentheses = 1;
						}
						$bio .= 'with whom ' . lcfirst($pronoun);
						if((!$all_children_are_alive) || (!$opts{'l'}) || ($yob && ($year > $yob + 100))) {
							$bio .= ' had ';
						} elsif((!$dateofdeath) && (!$dateofburial) && ($spouses[0]) && !$spouses[0]->death()) {
							$bio .= ' has had ';
						} else {
							$bio .= $dateofdeath || $dateofburial ? ' had ' : ' has ';
						}

						if($numberofchildrenwiththisspouse == 1) {
							if($all_children_are_alive) {
								$bio .= '1 surviving child, ';
							} else {
								$bio .= '1 child, ';
							}
						} else {
							if($all_children_are_alive) {
								$bio .= "$numberofchildrenwiththisspouse surviving children: ";
							} else {
								$bio .= "$numberofchildrenwiththisspouse children: ";
							}
						}
						if($numberofchildrenwiththisspouse == 1) {
							$bio .= $children[0]->given_names();
						} elsif($numberofchildrenwiththisspouse > 1) {
							my $childnames = join(', ', map {
								'<a href="' . make_filename_from_person(person => $_) . '">'.
									$_->given_names() . '</a>'
							} @childrenofthisspouse);
							substr($childnames, rindex($childnames, ', '), 2, ' and ');
							$childnames =~ s/&entry=/&amp;entry=/g;
							print $html $childnames;
							# FIXME: breaks static HTML page, because of the print $bio
							#	later on
							$childnames = join(', ', map {
								'<a href="?page=people&entry=' . $_->xref() . '">'.
									$_->given_names() . '</a>'
							} @childrenofthisspouse);
							substr($childnames, rindex($childnames, ', '), 2, ' and ');
							$bio .= $childnames;
						}
					}
				} else {
					my @spouse_occupations = get_all_occupations($spouses[0]);
					if($spouse_occupations[0]) {
						$bio .= ' (' . HTML::Entities::encode(Lingua::EN::Inflect::A(lc($spouse_occupations[0])));
						$parentheses = 1;
					}
				}
				if($opts{'l'} || !$is_alive) {
					if($parentheses) {
						$bio .= ')';
					} elsif(($dateofmarriage || $placeofmarriage) && $numberofchildren) {
						$bio .= ',';
					}
					if($placeofmarriage && $dateofmarriage &&
					   ($placeofbaptism and ($placeofmarriage eq $placeofbaptism))) {
						if((!defined($placeofbaptism)) or ($placeofmarriage ne $placeofbaptism)) {
							$bio .= ' there';
						}
						$bio .= ' ';
						if(my $address = $marriage->address()) {
							if($address eq 'Parish Church') {
								$bio .= 'at the Parish Church ';
							} elsif($address eq 'Registry Office') {
								$bio .= 'at the Registry Office ';
							} else {
								$bio .= "at $address ";
							}
						}
						$bio .= year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt);
					} else {
						if($placeofmarriage) {
							my $args = {
								place => $placeofmarriage,
								person => $person,
								places_printed => \%places_printed
							};
							if($marriage && (my $address = $marriage->address())) {
								$args->{'address'} = $address;
							}
							my $p = place($args);
							$bio .= $p;
							$places_printed{$p} = 1;
						}
						$bio .= ' ' . year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt) if($dateofmarriage);
					}
					if($marriagecitation) {
						$bio .= cite(($marriagecitation));
					}
				}
			} elsif($opts{'l'} || !$is_alive) {
				$bio .= ' was married ';
				if(scalar(@spouses) == 2) {
					if($spouses[0] eq $spouses[1]) {
						complain({ person => $person, warning => [ 'Married twice to ', $spouses[0]->as_string() ] });
					} else {
						$bio .= 'twice';
					}
				} else {
					$bio .= scalar(@spouses) . ' times';
				}

				$bio .= ', to';

				$html_and_csv->print($bio);
				$bio =~ s/</&lt;/g;
				$bio =~ s/>/&gt;/g;
				$bio =~ s/&/&amp;/g;
				print $xml $bio;

				$fullbio .= $bio;
				$bio = '';

				my $all_marriages_have_date = 1;
				foreach my $spouse(@spouses) {
					my $date = get_value({ person => $spouse, value => 'marriage date' });
					if(!defined($date)) {
						if(my $marriage = ($spouse->get_record('marriage') || $spouse->get_record('fams marriage'))) {
							$date = $marriage->date();
						}
					}
					if(!date_to_datetime($date)) {
						$all_marriages_have_date = 0;
						last;
					}
				}
				if($all_marriages_have_date) {
					@spouses = Sort::Key::DateTime::dtkeysort {
						my $date;
						if(my $rec = $_->get_record('fams marriage')) {
							$date = $rec->date();
						}
						if((!defined($date)) && (my $rec = $_->get_record('marriage'))) {
							$date = $rec->date();
						}
						date_to_datetime(date => $date);
					} @spouses;
				}

				my $spouse_number = 0;
				my $previousplace;
				foreach my $spouse(@spouses) {
					print $html ' <a href="', make_filename_from_person(person => $spouse), '">',
						$spouse->as_string(), '</a>';
					print $csv ' <a href="?page=people&entry=', $spouse->xref(), '">',
						$spouse->as_string(),
						'</a>';
					print $xml ' &lt;a href="?page=people&amp;entry=', $spouse->xref(), '"&gt;',
						$spouse->as_string(),
						'&lt;/a&gt;';

					my $dateofmarriage = get_value({ person => $spouse, value => 'marriage date' });
					if(!defined($dateofmarriage)) {
						if(my $marriage = ($spouse->get_record('marriage') || $spouse->get_record('fams marriage'))) {
							$dateofmarriage = $marriage->date();
						}
					}
					my $placeofmarriage = get_value({ person => $spouse, value => 'marriage place' });
					if(!defined($placeofmarriage)) {
						if(my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage')) {
							$placeofmarriage = $marriage->place();
						}
					}
					if($placeofmarriage) {
						$placeofmarriage = place({ person => $spouse, place => $placeofmarriage, places_printed => \%places_printed });
						if($previousplace && ($placeofmarriage eq $previousplace)) {
							if($placeofmarriage =~ /^(.+?),/) {
								$placeofmarriage = " also$1";
							}
						} else {
							$previousplace = $placeofmarriage;
						}
					}

					my $printed_bracket = 0;
					if($dateofmarriage && $placeofmarriage) {
						$bio .= ' (' . year({ string => $dateofmarriage }) .
							$placeofmarriage;
						$printed_bracket = 1;
					} elsif($placeofmarriage) {
						$placeofmarriage =~ s/^\s+//;
						$bio .= " ($placeofmarriage";
						$printed_bracket = 1;
					} elsif($dateofmarriage) {
						$bio .= ' (' . year({ string => $dateofmarriage });
						$printed_bracket = 1;
					}
					$spouse_number++;
					if((scalar(@spouses) == 2) && $all_marriages_have_date && ($spouse_number == 2) &&
					   (my $death_of_first_spouse = dateofdeath($spouses[0]))) {
						if(datecmp($dateofmarriage, $death_of_first_spouse) > 0) {
							if($printed_bracket) {
								$bio .= ', ';
							} else {
								$bio .= '(';
								$printed_bracket = 1;
							}
							$bio .= 'following the death of ' .
								$spouses[0]->as_string() . ' ' .
								year({
									person => $spouses[0],
									record => $death_of_first_spouse,
								});
						}
					}
					$bio .= ')' if($printed_bracket);
					if($spouse_number == (scalar(@spouses) - 1)) {
						$bio .= ' and';
					} elsif($spouse_number < (scalar(@spouses) - 1)) {
						$bio .= ',';
					}
					$html_and_csv->print($bio);
					print $xml $bio;

					$fullbio .= $bio;
					$bio = '';
				}
				# substr($names, rindex($names, ', '), 2, ' and ');
				$bio = cite(($marriagecitation));

				# Determine if all the children are from one marriage, since that's
				# easier to print.
				# FIXME:  handle where offspring are from more than one marriage
				if($numberofchildren) {
					my %childrenbyspouse;
					my $childrenseen = 0;
					my $unknown;
					foreach my $family ($person->fams()) {
						if($family->number_of_children() &&
						   ($spouse = ($sex eq 'M') ? $family->wife() : $family->husband())) {
							my $spouse = ($sex eq 'M') ? $family->wife() : $family->husband();
							foreach my $child($person->children()) {
								$unknown = $child;
								foreach my $spouseschild($spouse->children()) {
									if($spouseschild eq $child) {
										$childrenbyspouse{$spouse}++;
										$childrenseen++;
										$unknown = undef;
										last;
									}
								}
							}
						}
					}
					my $parentofall;
					if($childrenseen < $numberofchildren) {
						# Unable to find the parent of all of the children.  This
						# may be the case where someone married more than once,
						# and has a child by a 3rd unknown (or unfound) person
						if($opts{'w'}) {
							if($opts{'f'}) {
								die $person->as_string(), ': one of the parents of ', ($numberofchildren - $childrenseen), ' children is not known';
							}
							if(($numberofchildren - $childrenseen) == 1) {
								if($unknown) {
									red_warning({ person => $person, warning => 'One of the parents of ' . $unknown->as_string() . ' is not known'});
								} else {
									red_warning({ person => $person, warning => 'One of the parents of 1 child is not known'});
								}
							} else {
								red_warning({ person => $person, warning => 'One of the parents of ' . ($numberofchildren - $childrenseen) . ' children is not known'});
							}
						}
					} else {
						foreach my $spouse(@spouses) {
							if($parentofall && $childrenbyspouse{$spouse}) {
								$parentofall = undef;
								last;
							}
							if($childrenbyspouse{$spouse}) {
								$parentofall = $spouse;
							}
						}
					}
					$bio .= ". $pronoun " .
						($all_children_are_alive ? 'has ' : 'had ');
					if($numberofchildren == 1) {
						if($all_children_are_alive) {
							$bio .= '1 surviving child';
						} else {
							$bio .= '1 child';
						}
						if($childrenseen >= $numberofchildren) {
							if($parentofall) {
								$bio .= ' with ' . $parentofall->as_string();
							} else {
								if($opts{'f'}) {
									die $person->as_string(), ': BUG: parentofall not set when only one child';
								} else {
									red_warning({ person => $person, warning => 'BUG: parentofall not set when only one child' });
								}
							}
						} else {
							$bio .= ' with an unknown ' . (($sex eq 'M') ? 'mother' : 'father');
						}
						# TODO: make hyperlink to the persons record, unless surviving
						$bio .= ', ' . $children[0]->given_names();
					} else {
						if($all_children_are_alive) {
							$bio .= "$numberofchildren surviving children";
						} else {
							$bio .= "$numberofchildren children";
						}
						# FIXME: do hyperlinks - needs to be correct for $csv and $html
						my $childnames;
						if($parentofall) {
							if($numberofchildren == 2) {
								$bio .= ', both with ' . $parentofall->as_string();
							} else {
								$bio .= ', all with ' . $parentofall->as_string();
							}
							# TODO: only add hyperlink to dead children
							# $childnames = join(', ', map {
								# '<a href="' . make_filename_from_person(person => $_) . '">' .
									# $_->given_names() . '</a>'
							# } @children);
							$childnames = join(', ', map { $_->given_names() } @children);
						} elsif($sex eq 'M') {
							# FIXME: children from the same parent should be listed together
							# $childnames = join(', ', map {
								# my $mother = $_->mother();
								# '<a href="' . make_filename_from_person(person => $_) . '">' .
									# $_->given_names() . '</a>' .
								# ' (with ' .
								# '<a href="' . make_filename_from_person(person => $mother) . '">' .
									# $mother->given_names() . '</a>' .
								# ')'
							# } @children);
							$childnames = join(', ', map { $_->given_names() } @children);
						} else {
							# $childnames = join(', ', map {
								# my $father = $_->father();
								# '<a href="' . make_filename_from_person(person => $_) . '">' .
									# $_->given_names() . '</a>' .
								# ' (with ' .
								# '<a href="' . make_filename_from_person(person => $father) . '">' .
									# $father->given_names() . '</a>' .
								# ')'
							# } @children);
							$childnames = join(', ', map { $_->given_names() } @children);
						}
						substr($childnames, rindex($childnames, ', '), 2, ' and ');
						$bio .= ": $childnames";
					}
				}
			}
			if($bio =~ /\.$/) {
				$end_of_sentence = 1;
			} else {
				$end_of_sentence = 0;
			}
		} elsif($numberofchildren) {
			# Neither date nor place of marriage is known
			if($end_of_sentence) {
				$bio .= " $pronoun";
			} elsif(scalar(@residences) == 0) {
				$bio .= ' and';
			}
			$bio .= ' had ' .
				(($numberofchildren == 1) ? '1 child, ' : "$numberofchildren children, ");
			if($numberofchildren == 1) {
				$bio .= $children[0]->given_names();
			} else {
				my $childnames = join(', ', map { $_->given_names() } @children);
				substr($childnames, rindex($childnames, ', '), 2, ' and ');
				$bio .= $childnames;
			}
			$end_of_sentence = 0;
		}
	}

	my $printed_residence = 0;
	my %citationnotes;
	my @note_locations;
	my @residencelist;
	my $diedathome;

	if($opts{'l'} || !$is_alive) {
		if(scalar(@childrenunknownparent)) {
			$bio .= '. ' if(!$end_of_sentence);
			$bio .= "$pronoun ";
			if(scalar(@children) > scalar(@childrenunknownparent)) {
				$bio .= 'also ';
			}
			$bio .= 'had ' . scalar(@childrenunknownparent) . ' ';
			if(scalar(@childrenunknownparent) == 1) {
				$bio .= 'child, ';
			} else {
				$bio .= 'children, ';
			}
			$bio .= Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @childrenunknownparent), {final_sep => ''}) .
				', whose ' .
				(($sex eq 'F') ? 'father' : 'mother') .
				' is unknown';
			$end_of_sentence = 0;
		}

		if($same_occupation_as_father) {
			$bio .= '.' if(!$end_of_sentence);
			$bio .= ' Like ' . lcfirst($person->possessive()) . ' father, ' . lcfirst($pronoun) .
				(is_alive(person => $person) ? ' is' : ' was');
			$bio .= ' ' . Lingua::EN::Inflect::A(lc($same_occupation_as_father)) . '. ';
			$end_of_sentence = 1;
		}

		print "Handling residences\n" if($opts{'v'});
		# FMP stores Censuses as events
		if($opts{'w'}) {
			my $index = 0;
			foreach my $event(@events) {
				$index++;
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN', $index);
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					} else {
						red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
					}
				}
				if(ref($event) eq 'Gedcom::Record') {
					my $type = $event->type();
					if(!defined($type)) {
						red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
						next;
					}

					# if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939')) {
					if(($type =~ /Census/) || ($type eq 'Register UK 1939')) {
						if(!$dateofbirth) {
							complain({ person => $person, warning => 'Census information not used to approximate a date of birth' });
						}
					}
				}
			}
		}

		my @all_residences = get_all_residences($person);
		if(scalar(@all_residences)) {
			print scalar(@all_residences), " residences found\n" if($opts{'v'});
			# FIXME: handle duplicate locations better
			my %residencecitations;

			# This is an attempt to handle
			# https://github.com/pjcj/Gedcom.pm/issues/13
			my $index = 0;
			foreach my $residence(@all_residences) {
				$index++;
				if(!ref($residence)) {
					my $r = $person->tag_record('EVEN', $index);
					if(ref($r) eq 'Gedcom::Record') {
						$residence = $r;
					} else {
						$r = $person->record(['residence', $index]);
						if(ref($r) eq 'Gedcom::Record') {
							$residence = $r;
						} else {
							red_warning({ person => $person, warning => "Residence record is just description ($residence), infomation has been lost" });
						}
					}
				}
				if(ref($residence) eq 'Gedcom::Record') {
					my $place = $residence->place();
					if(my $address = $residence->address()) {
						if(ref($address) eq 'Gedcom::Record') {
							$place = getaddress($address);
						} elsif($place) {
							$place = "$address, $place";
						} elsif($opts{'f'}) {
							die $person->string(), ": address set to $address but place is empty";
						} else {
							red_warning({
								person => $person,
								warning => "Address set to $address but place is empty"
							});
						}
					}
					if(defined($place)) {
						if(my $dor = $residence->date()) {
							if($placeofbirth && $dob && ($dor eq $dob)) {
								next;
							}
							if($placeofmarriage && $dateofmarriage && ($dor eq $dateofmarriage)) {
								next;
							}
						}
						push @residencelist, $residence;
						if($opts{'c'}) {
							if(my $src = $residence->source()) {
								$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
								my $note = notes(record => $residence, note_locations => \@note_locations);
								foreach my $c(@birthcitations) {
									if($src eq $citations{$c}) {
										$residencecitations{$residence} = $c;
										if($note) {
											$citationnotes{$c} = $note;
										}
										last;
									}
								}
								unless($residencecitations{$residence}) {
									if($deathcitations[0] && ($src eq $citations{$deathcitations[0]})) {
										$residencecitations{$residence} = $deathcitations[0];
										if($note) {
											$citationnotes{$deathcitations[0]} = $note;
										}
									} else {
										$residencecitations{$residence} = ++$citationcount;
										$citations{$citationcount} = $src;
										if($note) {
											$citationnotes{$citationcount} = $note;
										}
									}
								}
							} elsif(my $dor = $residence->date()) {
								red_warning({ person => $person, warning => "Residence record for $dor contains no citation" });
							}
						}
					} elsif(my $dor = $residence->date()) {
						if(my $type = $residence->type()) {
							if(($type ne 'Military service') &&
							   ($type ne 'Story')) {
								red_warning({ person => $person, warning => "Residence record for $dor contains no location" });
							}
						} else {
							red_warning({ person => $person, warning => 'Residence record contains no type' });
						}
					} else {
						red_warning({ person => $person, warning => 'Residence record contains no date' });
					}
				}
			}

			if(scalar(@residencelist) == 2) {
				print "Check if the residences are the same\n" if($opts{'v'});
				my $date1 = $residencelist[0]->date();
				my $date2 = $residencelist[1]->date();

				if($date1 && $date2 && ($date1 eq $date2)) {
					if(places_are_the_same({ person => $person, first => $residencelist[0], second => $residencelist[1] })) {
						complain({ person => $person, warning => "Duplicate residence on $date1" });
						@residencelist = ($residencelist[0]);
					}
				}
			}

			# TODO: See RT110333

			# Sort residences chronologically
			# FIXME: This messes citations
			my $all_residences_have_date = 1;
			foreach my $residence(@residencelist) {
				my $date = $residence->date();
				if(!$date) {
					complain({ person => $person, warning => 'Contains a residence' . place(record => $residence) . ' without a date' });
					$all_residences_have_date = 0;
					last;
				}
				$date = $date_parser->parse(date => $date);
				if(!defined($date)) {
					complain({ person => $person, warning => "Can't parse date '$date'" });
					$all_residences_have_date = 0;
					last;
				}
				if(scalar(@{$date}) == 0) {
					# e.g. "Apr/May/Jun 2016"
					$all_residences_have_date = 0;
					last;
				}
			}
			if($all_residences_have_date) {
				print "Sort the residences\n" if($opts{'v'});
				@residencelist = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @residencelist;
			}
			my $count = 0;
			my $prev_residence;
			my $spdeath_dt;
			if($spouses[0] && ($spdeath_dt = dateofdeath($spouses[0]))) {
				$spdeath_dt = date_to_datetime(date => $spdeath_dt);
			}
			my $print_year_only;	# used when printing a range, e.g. 1871-1891
			my $printed_following_message;
			# my $yod;
			# my $dod = dateofdeath($person);
			# if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				# $yod = $1;
			# }
			my %printed_dates;

			my @residencestringarray;

			print "Sanity checking the residences\n" if($opts{'v'});
			# Create a list of residence strings
			foreach my $residence(@residencelist) {
				my $rdate = $residence->date();
				my $latitude;
				my $longitude;
				my $residencestring;
				if(($count == 0) || !places_are_the_same({ person => $person, first => $residence, second => $residencelist[$count - 1] })) {
					if($birth && $dob && $rdate && ($rdate eq $dob) &&
					   places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						# This residence record is for the place of birth, which is
						# printed elsewhere
						$count++;
						next;
					}
					if($birth && places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						$residencestring = ' at ' . ($person->pronoun() eq 'She' ? 'her' : 'his')
								. ' birthplace';
					} else {
						my $p = place({
							person => $person,
							record => $residence,
							places_printed => \%places_printed
						});
						if($residence->type() && ($residence->type() eq 'Hospitalisation')) {
							$residencestring = ' in hospital';
						}

						if((!defined($prev_residence)) ||
						   !places_are_the_same({ person => $person, first => $prev_residence, second => $residence })) {
							# Actually prints the place here
							$residencestring .= $p;
							$places_printed{$p} = 1;
						}
					}
					if($rdate && (my $rdate_dt = date_to_datetime($rdate))) {
						my $year = $rdate_dt->year();
						my $strftime = $rdate_dt->strftime('%x');
						my $place = place({
							person => $person,
							record => $residence,
							nopreposition => 1,
						});
						if($place) {
							$place =~ s/^\s+//;
							my @locations = $geocoder->geocode($place);
							if(my $location = shift @locations) {
								my $lat;
								my $long;
								if(ref($location) eq 'Geo::Location::Point') {
									if(ref($location) eq 'Geo::Location::Point') {
										$lat = $location->lat();
										$long = $location->long();
									} else {
										$lat = $location->{geometry}{location}{lat};
										$long = $location->{geometry}{location}{lng};
									}
								}
								push @{$all_locations{$year}}, {
									'residence' => $residence,
									'person' => $person,
									'date' => $strftime,
									'latitude' => $lat,
									'longitude' => $long,
								};
							}
						}
						if($opts{'w'} && $marriage_dt && ($rdate_dt > $marriage_dt)) {
							if(!defined($spouses[0])) {
								complain({ person => $person, warning => 'Has a date of marriage but no spouse' });
							} else {
								# Check this person was living at the same place as their spouse.
								# TODO: Also check all children under 10
								foreach my $l(@{$all_locations{$year}}) {
									if(($l->{'person'} eq $spouses[0]) &&
									   ($l->{'date'} eq $strftime)) {
										my $r1 = place(record => $residence, nopreposition => 1);
										my $r2 = place(record => $l->{'residence'}, nopreposition => 1);
										if($r1 ne $r2) {
											$r1 =~ s/^\s+//;
											$r2 =~ s/^\s+//;
											complain({
												person => $person,
												warning => [
													"$strftime: not living at same address as spouse ",
													$spouses[0]->as_string(),
													" ('$r1'/'$r2')"
												]
											});
										}
									}
								}
							}
						}
					}
				}
				# Citation residence notes print later
				if($rdate) {	# residence has a date?
					next if($printed_dates{$rdate});
					$printed_dates{$rdate}++;
					if($opts{'w'} && ($rdate =~ /(\d{3,4})$/)) {
						my $yoe = $1;
						if($yod) {
							if($yoe > $yod) {
								complain({
									person => $person,
									warning => "Year of residence $yoe is after the year of death $yod"
								});
							} elsif($death_dt && (my $rdate_dt = date_to_datetime($rdate))) {
								# FIXME: If $rdate is a date range, should check both dates in the range
								if($rdate_dt > $death_dt) {
									complain({
										person => $person,
										warning => "Date of residence $rdate is after date of death " . $death_dt->strftime('%x')
									});
								}
							}
						}
						# Check if spouse listed at all residences when we only know the year
						if($spouses[0]) {
							my $spyod = dateofdeath($spouses[0]) || ($yoe + 1);
							if($spyod =~ /(\d{3,4})$/) {
								$spyod = $1;
							}
							if(defined($dateofmarriage) &&
							   ($dateofmarriage =~ /(\d{3,4})$/) &&
							   (my $spouse = $spouses[0]) &&
							   ($yoe < $spyod)) {
								my $yom = $1;
								if($yom < $yoe) {
									my $found_spouse;
									foreach my $residence(get_all_residences($spouse)) {
										my $date = $residence->date();
										if(defined($date) && ($date =~ /(\d{3,4})$/)) {
											if($1 == $yoe) {
												$found_spouse = $residence;
												last;
											}
										}
									}
									if(!$found_spouse) {
										complain({ person => $person, warning => ["Listed in the residence for $rdate, but spouse ", $spouse->as_string(), ' is not'] });
									}
								}
							}
						}
						if($yob && (($yoe - $yob) <= 10)) {
							my $found_parent = 0;
							if($mother) {
								foreach my $m_residence(get_all_residences($mother)) {
									my $date = $m_residence->date();
									if(defined($date) && ($date =~ /(\d{3,4})$/)) {
										if($1 == $yoe) {
											$found_parent = $m_residence;
											my $p1 = place({
													person => $mother,
													record => $m_residence,
													nopreposition => 1
												});
											my $p2 = place({
													person => $person,
													record => $residence,
													nopreposition => 1
												});
											if($p1 ne $p2) {
												$p1 =~ s/^\s+//;
												$p2 =~ s/^\s+//;
												complain({ person => $person, warning => "Location for $date ($p2) differs from mother's ($p1)" });
											}
											if($date ne $rdate) {
												complain({ person => $person, warning => "Date of residence ($rdate) differs from mother's in same year ($date)" });
											}
											last;
										}
									}
								}
							}
							if($father && ($opts{'w'} || !$found_parent)) {
								foreach my $f_residence(get_all_residences($father)) {
									my $date = $f_residence->date();
									if(defined($date) && ($date =~ /(\d{3,4})$/)) {
										if($1 == $yoe) {
											$found_parent = $f_residence;
											my $p1 = place({
													person => $father,
													record => $f_residence,
													nopreposition => 1
												});
											my $p2 = place({
													person => $person,
													record => $residence,
													nopreposition => 1
												});
											if($p1 ne $p2) {
												$p1 =~ s/^\s+//;
												$p2 =~ s/^\s+//;
												complain({ person => $person, warning => "Location for $date ($p2) differs from father's ($p1)" });
											}
											if($date ne $rdate) {
												complain({ person => $person, warning => "Date of residence ($rdate) differs from father's in same year ($date)" });
											}
											last;
										}
									}
								}
							}
							if((!$mother) && !$father) {
								# People not related by blood tend not to have been researched
								if($relationship) {
									complain({ person => $person, warning => 'Census information not used to determine a parent' });
								}
							} elsif(!$found_parent) {
								# FIXME: both parents could be dead
								complain({ person => $person, warning => "Residence information in $yoe, but no residence information found for either parent" });
							}	# TODO: else warn if both parents locations are different
						} elsif($numberofchildren && ($rdate !~ /^bet\s/i)) {
							# Look if a young child isn't with this parent
							foreach my $child(@children) {
								my $cyob = dateofbirth($child);
								next if(!defined($cyob));
								next if(datecmp($cyob, $rdate) >= 0);	# Child was not born yet
								if($cyob =~ /(\d{3,4})\s*$/) {
									$cyob = $1;
								}
								next if(($yoe - $cyob) > 10);	# Over 10 years old
								if(my $cyod = dateofdeath($child)) {
									next if(datecmp($cyod, $rdate) <= 0);	# Child was dead by this event
								}

								my $missing_child = 1;
								foreach my $event(get_all_residences($child)) {
									my $edate = $event->date();
									if($edate && ($edate !~ /^bet\s/i) && (datecmp($edate, $rdate) >= 0)) {
										$missing_child = 0;
										last;
									}
								}
								if($missing_child) {
									if($firstname) {
										complain({ person => $child, warning => "Parent $firstname is listed in the residence for $rdate, but this child is not" });
									} else {
										complain({ person => $child, warning => "Parent is listed in the residence for $rdate, but this child is not" });
									}
								}
							}
						}
					}
					if(scalar(@residencelist) > 1) {
						my $this_date = year({ person => $person, date => $rdate });
						if($prev_residence && (year(record => $prev_residence) eq $this_date)) {
							if(place(record => $prev_residence) ne place(record => $residence)) {
								complain({ person => $person, warning => "Two residence records for $rdate differ in location" });
							}
						} else {
							if($print_year_only) {
								if($count == (scalar(@residencelist) - 1)) {
									$residencestring .= $rdate;
									# $print_year_only = 0;
								}
							} else {
								if((!defined($residencestring)) && (my $p = pop(@residencestringarray))) {
									$p =~ s/ and /, /g;
									$residencestring = "$p and $this_date";
								} else {
									$residencestring .= " $this_date";
								}
							}
							$prev_residence = $residence;
						}
					}
					if(defined($latitude)) {
						# Print close relatives living close by
						# This really only works when printing a lot of people, for example with the -a
						#	flag, or when producing a PDF book, since it relies on having found data
						#	on people beforehand
						my $year = date_to_datetime($rdate)->year();
						my $printed_person = 0;
						my $gis = GIS::Distance->new('MathTrig');
						my $p2 = place({ record => $residence, nopreposition => 1 });
						my $count = 0;
						my $p3;	# previous place
						my @people_at_p3;

						my @sorted_locations = sort { $a->{'latitude'} <=> $b->{'latitude'} } @{$all_locations{$year}};

						# $Data::Dumper::Maxdepth = 2;
						foreach my $l(@sorted_locations) {
							$count++;
							# print Data::Dumper->new([$l])->Dump();
							if(($l->{'person'}->xref() ne $person->xref()) &&
							   (($spouses[0] && ($l->{'person'}->xref() eq $spouses[0]->xref())) ||
							   (my $relationship = $person->relationship($l->{'person'})) &&
							    ((stepsabove($l->{'person'}, $person, 0) <= 3) &&
							     (stepsabove($person, $l->{'person'}, 0) <= 3)))) {
								my $distance = $gis->distance($l->{'latitude'}, $l->{'longitude'}, $latitude, $longitude);
								my $peek = $sorted_locations[$count];
								next if($peek && ($peek->{'person'} eq $l->{'person'}));
								my $p1 = place({ record => $l->{'residence'}, nopreposition => 1});
								if($p1 eq $p2) {
									if($p3 && $peek && (place({ record => $peek->{'residence'}, nopreposition => 1 }) eq $p3)) {
										if((!defined($people_at_p3[0])) || ($people_at_p3[0]->{'person'} ne $l->{'person'})) {
											push @people_at_p3, $l;
										}
										next;
									}
									$p3 = $p1;
								} elsif(($l->{'latitude'} == $latitude) && ($l->{'longitude'} == $longitude)) {
									complain({
										person => $person,
										warning => [ $l->{'person'}->as_string(nee => 1), " residence is same location probably should be recorded as the same address ('$p1'/'$p2') in $year" ]
									});
								} elsif($distance->yards() < 20) {
									complain({
										person => $person,
										warning => [ $l->{'person'}->as_string(nee => 1), " residence is very close probably should be recorded as the same address ('$p1'/'$p2') in $year" ]
									});
								} elsif($distance->miles() < 1) {
									if($p3 && $peek && (place({ record => $peek->{'residence'}, nopreposition => 1 }) eq $p3)) {
										if((!defined($people_at_p3[0])) || ($people_at_p3[0]->{'person'} ne $l->{'person'})) {
											push @people_at_p3, $l;
										}
										next;
									}
									$p3 = $p1;
									if($printed_person) {
										$residencestring .= ', ';
									} else {
										$residencestring .= ', less than a mile from ';
									}
									if($spouses[0] && ($l->{'person'}->xref() eq $spouses[0]->xref())) {
										# FIXME: Only when before they married, though when
										#	they are married it should be the same place, right?
										$residencestring .= (($sex eq 'M') ? 'his future wife ' : 'her future husband ');
									} else {
										$residencestring .= ($sex eq 'M' ? 'his' : 'her') .
											" $relationship ";
									}
									if(defined($relationship) && (($relationship eq 'sister') || ($relationship eq 'brother'))) {
										$residencestring .= $l->{'person'}->given_names();
									} else {
										$residencestring .= $l->{'person'}->as_string();
									}
									if(scalar(@people_at_p3)) {
										while(my $p = pop(@people_at_p3)) {
											if(scalar(@people_at_p3)) {
												$residencestring .= ',';
											} else {
												$residencestring .= ' and';
											}
											$residencestring .= ' ' .
												$person->relationship($p->{'person'}) .
												' ' .
												$p->{'person'}->as_string();
										}
										$residencestring .= ' who were living';
									} else {
										$residencestring .= ' who was living';
									}
									$residencestring .= place({ record => $l->{'residence'}, there => $p2 });
									$printed_person = 1;
								}
							}
						}
						$residencestring .= ',' if($printed_person);
					}
					if($spdeath_dt && (!$printed_following_message) && (my $rdate_dt = date_to_datetime($rdate))) {
						if($rdate_dt > $spdeath_dt) {
							# Living with a child following death of spouse?
							CHILD: foreach my $child(@children) {
								my @cevents = $child->event();
								my $index = 0;
								EVENT: foreach my $event(@cevents) {
									$index++;
									if(!ref($event)) {
										my $e = $child->tag_record('EVEN', $index);
										if(ref($e) eq 'Gedcom::Record') {
											$event = $e;
										} else {
											# red_warning({ person => $child, warning => "Event record is just description ($event), infomation has been lost" });
											next EVENT;
										}
									}
									my $type = $event->type();

									# if(($type !~ /^Census U[KS] \d{4}$/) && ($type ne 'Register UK 1939')) {
									if(($type !~ /Census/) && ($type ne 'Register UK 1939')) {
										next EVENT;
									}
									if((ref($event) eq 'Gedcom::Record') &&
									   $event->date() && ($event->date() eq $rdate) &&
									   places_are_the_same({ person => $child, first => $residence, second => $event })) {
										$residencestring .= ' when ' .
											lcfirst($person->pronoun()) .
											' was living with ' .
											lcfirst($person->possessive()) .
											(($child->sex() eq 'F') ? ' daughter, ' : ' son, ') .
											$child->given_names() .
											', following the death of ' .
											(($sex eq 'M') ? 'his wife ' : 'her husband ') .
											year(date => dateofdeath($spouses[0]));
										$spdeath_dt = undef;
										last CHILD;
									}
								}
							}
							if($spdeath_dt) {
								# Outlived spouse, but not living with a child
								$residencestring .= ' following the death of ' .
									($person->pronoun() eq 'She' ? 'her' : 'his') .
									(($sex eq 'M') ? ' wife ' : ' husband ') .
									year(date => dateofdeath($spouses[0]));
							}
							$printed_following_message = 1;
						}
					}
					# Find if they are an adult living with an adult sibling or in-law
					if($all_residences_have_date && scalar(@siblings) && $birth_dt) {
						my $printed_sibling = 0;
						my $r = $residence;
						next if($r->date() ne $rdate);
						my $place = place({ person => $person, record => $r });
						my $first = 1;

						my $bdiff = $dfn->parse_datetime($rdate) - $birth_dt;

						foreach my $sibling(@siblings) {
							if(my $ss = $sibling->spouse()) {
								next if($bdiff->in_units('years') < 20);
								# If they are living with an in-law, assume both are adults
								my @ssr = get_all_residences(person => $ss);
								foreach my $ssr(@ssr) {
									if(my $d = $ssr->date()) {
										next if($d ne $rdate);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($place =~ /^d/ && (my $ssp = place({ person => $ss, record => $ssr })))) {
											if($ssp eq $place) {
												if($first) {
													$residencestring .= ' when ' . ($person->pronoun() eq 'She' ? 'her' : 'his') .
													' was living with ' . ($person->pronoun() eq 'She' ? 'her ' : 'his ') .
														(($ss->sex() eq 'F') ? 'sister-in-law, ' : 'brother-in-law, ') .
														$ss->as_string();
														$first = 0;
												} else {
													# FIXME: If possible, should say
													#	sisters-in-law or
													#	brothers-in-law
													$residencestring .= ' and ' .
														(($ss->sex() eq 'F') ? 'sister-in-law, ' : 'brother-in-law, ') .
														$ss->as_string();
												}
												$printed_sibling = 1;
												# May be removed later
												$residencestring .= ' and';
												last;
											}
										}
									}
								}
							}
							next if($bdiff->in_units('years') < 40);
							# Safe to assume both are adults at this time
							my @sr = get_all_residences(person => $sibling);
							foreach my $sr(@sr) {
								my $sdate = $sr->date();
								next if(!defined($sdate));
								next if($sdate ne $rdate);
								if(($place =~ /^\d/) && (place({ person => $sibling, record => $sr }) eq $place)) {
									if($first) {
										$residencestring .= ' with ' . ($person->pronoun() eq 'She' ? 'her' : 'his');
										$first = 0;
									}
									$residencestring .= ' ' .
										(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
										$sibling->given_names() . ',';
									$printed_sibling = 1;
									last;
								}
							}
						}
						# FIXME: only checks when there are @siblings
						if($bdiff->in_units('years') >= 30) {
							my $with_mother;
							my $same_road_as_mother;
							my $road = $residence->address();
							if($road) {
								if($road =~ /,\s*(.+)/) {
									$road = $1;
								}
								if($road =~ /^\d*\s(.+)/) {
									$road = $1;
								}
							}
							if($mother) {
								my @mr = get_all_residences(person => $mother);
								foreach my $mr(@mr) {
									my $mdate = $mr->date();
									next if(!defined($mdate));
									next if($mdate ne $rdate);
									if(place({ person => $mother, record => $mr }) eq $place) {
										$with_mother++;
										last;
									}
									if($mr->place() eq $residence->place()) {
										if(my $mroad = $mr->address()) {
											if($mroad =~ /,\s*(.+)/) {
												$mroad = $1;
											}
											if($mroad =~ /^\d*\s(.+)/) {
												$mroad = $1;
											}
											if($mroad eq $road) {
												$same_road_as_mother = 1;
											}
										}
									}
								}
							}
							my $with_father;
							my $same_road_as_father;
							if($father) {
								my @fr = get_all_residences(person => $father);
								foreach my $fr(@fr) {
									my $fdate = $fr->date();
									next if(!defined($fdate));
									next if($fdate ne $rdate);
									if(place({ person => $father, record => $fr }) eq $place) {
										$with_father++;
										last;
									}
									if($fr->place() eq $residence->place()) {
										if(my $froad = $fr->address()) {
											if($froad =~ /,\s*(.+)/) {
												$froad = $1;
											}
											if($froad =~ /^\d*\s(.+)/) {
												$froad = $1;
											}
											if($froad eq $road) {
												$same_road_as_father = 1;
											}
										}
									}
								}
							}
							if($with_mother || $with_father) {
								if($first) {
									$residencestring .= ($printed_sibling ? ' and ' : ' with ') .
										($person->pronoun() eq 'She' ? 'her' : 'his');
								} else {
									$residencestring =~ s/,$//;
									if($language eq 'French') {
										$residencestring .= ' et';
									} else {
										$residencestring .= ' and';
									}
								}
								$printed_sibling = 1;
								$first = 0;

								if($with_mother && $with_father) {
									$residencestring .= ' parents ';
								} elsif($with_mother) {
									$residencestring .= ' mother ' . $mother->given_names();
								} elsif($with_father) {
									$residencestring .= ' father ' . $father->given_names();
								}
							} elsif(($same_road_as_mother || $same_road_as_father) && !$printed_sibling) {
								$residencestring .= ' on the same road as ' .
											($person->pronoun() eq 'She' ? 'her' : 'his');
								$printed_sibling = 1;
								$first = 0;

								if($same_road_as_mother && $same_road_as_father) {
									$residencestring .= ' parents';
								} elsif($same_road_as_mother) {
									$residencestring .= ' mother';
								} else {
									$residencestring .= ' father';
								}
							}
						}
						if($spouse && $marriage_dt && (my $rdate_dt = date_to_datetime($rdate))) {
							if($marriage_dt > $rdate_dt) {
								my @sr = get_all_residences(person => $spouse);
								foreach my $sr(@sr) {
									my $sdate = $sr->date();
									next if(!defined($sdate));
									next if($sdate ne $rdate);
									if(place({ person => $spouse, record => $sr }) eq $place) {
										$residencestring .= ($printed_sibling ? ' and ' : ' with ') .
											($person->pronoun() eq 'She' ? 'her future husband, ' : 'his future wife, ') .
											$spouse->given_names();
										last;
									}
								}
							}
						}
					}
				}
				if((!($opts{'c'} && $residence->source())) && (my $notes = notes({ record => $residence }))) {
					$notes =~ s/\.$//;
					$notes = lcfirst($notes);
					$residencestring .= " ($notes)";
				} elsif($opts{'c'}) {
					my @citationlist;
					if($residencecitations{$residence}) {
						push @citationlist, $residencecitations{$residence};
					}
					if($residence->place() &&
					  (!$rdate) &&
					  ($count <= (scalar(@residencelist) - 1)) &&
					  ($residencecitations{$residence})) {
						my $peek = $residencelist[$count + 1];
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							push @citationlist, $residencecitations{$peek};
						}
					}
					if(scalar(@citationlist)) {
						$residencestring =~ s/,$//;
						$residencestring .= cite(@citationlist);
					}
				}
				$count++;
				if(($count == 1) && (scalar(@residencelist) == 2)) {
					if($print_year_only) {
						$residencestring .= $rdate;
						$print_year_only = 0;
					}
				} else {
					my $peek = $residencelist[$count];
					if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
						$peek = $residencelist[$count + 1];
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							if((!$opts{'c'}) && $rdate && ($rdate =~ /^\d{4}$/) && $peek->date() && ($peek->date() =~ /^\d{4}$/)) {
								if((!$print_year_only) && !notes(record => $peek)) {
									$residencestring .= '-';
									$print_year_only = 1;
								}
							} else {
								if($print_year_only && $rdate) {
									$residencestring .= $rdate;
									$print_year_only = 0;
								}
							}
						}
					} elsif($print_year_only) {
						$residencestring .= $rdate;
						$print_year_only = 0;
					}
				}
				if($residencestring) {
					$residencestring =~ s/^\s//;
					if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^fr/)) {
						$residencestring =~ s/(.+), (his|her) /$1 et $2 /;
					} else {
						$residencestring =~ s/(.+), (his|her) /$1 and $2 /;
					}
					push @residencestringarray, $residencestring;
					$printed_residence = 1;
				}
			}

			# Print out the residence strings with semi-colons between each residence
			if(scalar(@residencestringarray)) {
				$bio .= '. ' unless($end_of_sentence);
				my $first = $residencelist[0];
				if((scalar(@residencelist) == 1) && (my $rdate = $first->date())) {
					$bio .= ' ' . ucfirst(year({ person => $person, date => $rdate, circa => 'About' }));
				} else {
					$bio .= '</p><p>During ' . lc($person->possessive()) . ' life';
				}

				# print Data::Dumper->new([\@residencestringarray])->Dump();
				$bio .= ', ' . lcfirst($pronoun) . ' was living ' .
					Lingua::EN::Inflect::WORDLIST(@residencestringarray, {sep => '; '});

				if($placeofdeath) {
					my $lastresidence = $residencelist[scalar(@residencelist) - 1];
					my $deathplace = place({ person => $person, record => $death });
					my $lastdate = $lastresidence->date();
					$lastresidence = place({ person => $person, record => $lastresidence });
					if(defined($lastdate) && ($deathplace eq $lastresidence)) {
						my $p = lcfirst($pronoun);
						$bio .= " which is where $p died";
						if($dateofdeath) {
							my $date = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
							$lastdate =~ s/^.*(\d{4})$/$1/;
							$date =~ /, (\d{3,4})$/;
							if($lastdate == $yod) {
								$date =~ s/, (\d{3,4})$//;
							}
							$bio .= " $date";
						}
						$bio .= cite(@deathcitations);
						# Print notes about the death, if any
						my $notes;
						if($notes = notes({ person => $person, record => $death, note_locations => \@note_locations })) {
							$notes =~ tr/\r//;
							$notes =~ tr/\n/ /;
							$notes =~ s/\.$//;
							$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
							$bio .= " ($notes)";
						}
						$diedathome = 1;
					}
				}
				$bio .= '. ';
				$end_of_sentence = 1;
			}
		}
	} else {
		print $csv '.!!!';
		print $xml '.';
	}
	$bio =~ s/,;/;/g;
	$bio =~ s/;$//;
	$bio =~ s/,.$/./;

	if($placeofburial || $dateofburial || $placeofcremation || $dateofcremation) {
		if((!$dateofdeath) && !$placeofdeath) {
			$bio .= '.' if((!$end_of_sentence) && (scalar(@spouses) || $numberofchildren));
			my $type = 'burial';
			if($placeofcremation || $dateofcremation) {
				$type = 'cremation';
			}
			if($dateofburial) {
				$bio .= ($type eq 'burial' ) ? " $pronoun was buried" : " $pronoun was cremated";
				$bio .= year({ person => $person, date => $dateofburial });
				if(my $city = ($placeofburial // $placeofcremation)) {
					if($placeofbirth && ($city eq $placeofbirth)) {
						if(my $address = $burial->address()) {
							$bio .= " at $address";
						}
						$bio .= ' in ' .
							lcfirst($person->possessive()) .
							' home town of ';
						if($city =~ /^(.+?),/) {
							$bio .= $1;
						} else {
							my $opts = {
								person => $person,
								there => $placeofdeath,
								places_printed => \%places_printed,
								must_postdate => $birth_dt
							};
							if($type eq 'burial') {
								$opts->{'place'} = $placeofburial;
								if(my $address = $burial->address()) {
									$opts->{'address'} = $address;
								}
							} else {
								$opts->{'place'} = $placeofcremation;
								if(my $address = $cremation->address()) {
									$opts->{'address'} = $address;
								}
							}
							$bio .= place($opts);
						}
					} else {
						$bio .= place({
							person => $person,
							place => $placeofburial // $placeofcremation,
							there => $placeofdeath,
							places_printed => \%places_printed,
							must_postdate => $birth_dt
						});
					}
				}
				if($type eq 'burial') {
					$bio .= ' ' . year({ person => $person, date => $dateofburial });
					$b = notes({ record => $burial, paragraph => 0 });
				} else {
					$bio .= ' ' . year({ person => $person, date => $dateofcremation });
					$b = notes({ record => $cremation, paragraph => 0 });
				}
				if($b) {
					$b =~ tr/\r//;
					$bio .= " ($b)";
				}
			} elsif($placeofbirth && ($placeofburial eq $placeofbirth)) {
				$bio .= " $pronoun was buried";
				if(my $address = $burial->address()) {
					$bio .= " at $address";
				}
				$bio .= ' in ' . lcfirst($person->possessive()) .
					' home town of ';
				my $city = $placeofburial;
				if($city =~ /^(.+?),/) {
					$bio .= $1;
				} else {
					$bio .= place({ person => $person, place => $placeofburial });
				}
			} else {
				$bio .= " $pronoun is buried",
					place({ person => $person, record => $burial, places_printed => \%places_printed, there => $placeofmarriage });
			}
			$end_of_sentence = 0;
		} else {	# $dateofdeath || $placeofdeath
			$bio .= '.' if(!$end_of_sentence);
			my $notes;
			if(!$diedathome) {
				$bio .= "<p>$pronoun died";
				if($dateofdeath) {
					my $y = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
					if($y =~ /^from (.+) to (.+)/i) {
						$y = "between $1 and $2";
					}
					$bio .= " $y";
				}
				if($placeofdeath && (my $p = place({ person => $person, record => $death, places_printed => \%places_printed }))) {
					$bio .= $p;
					$places_printed{$p} = 1;
				}
				$bio .= cite(@deathcitations);
				# Print notes about the death, if any
				if($notes = notes({ person => $person, record => $death, note_locations => \@note_locations })) {
					$notes =~ tr/\r//;
					$notes =~ tr/\n/ /;
					$notes =~ s/\.$//;
					$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
					$bio .= " ($notes)";
				}
			}
			my $opts = {
				person => $person,
				place => $placeofburial,
				there => $placeofdeath,
				places_printed => \%places_printed,
				must_postdate => $birth_dt,
			};
			my $address;
			if($address = get_value({ person => $person, value => 'burial address' })) {
				$opts->{'address'} = $address;
			}
			if($dateofburial) {
				if($diedathome) {
					$bio .= "$pronoun was buried";
				} else {
					$bio .= ' and was buried';
				}
				if($placeofburial) {
					if(defined($placeofdeath) && ($placeofburial eq $placeofdeath) && !$death->address()) {
						$bio .= ' there';
						if($address) {
							$bio .= " at $address";
						}
					} else {
						$bio .= place($opts);
					}
				}
				my $must_postdate;
				if($death_dt) {
					$must_postdate = $death_dt;
				} elsif(!defined($dateofdeath)) {
					complain({
						person => $person,
						warning => 'Date of burial is known but not of death, suggest adding "Abt. YEAR"'
					});
				} elsif($dateofdeath =~ /^(Abt|ca?)\.?\s*(.+)/i) {
					my $d = $2;
					if($d !~ /^\d/) {
						$must_postdate = date_to_datetime("1 $d");
					} else {
						$must_postdate = date_to_datetime($d);
					}
				}
				$bio .= ' ' . year({ person => $person, date => $dateofburial, must_postdate => $must_postdate });
				if(my $b = notes({ person => $person, record => $burial, paragraph => 0, note_locations => \@note_locations })) {
					$b =~ s/\.$//;
					$b =~ tr/\r//;
					$bio .= " ($b)";
				}
			} elsif($placeofdeath && $placeofburial && ($placeofburial eq $placeofdeath) &&
			   $burial->address() && !$death->address()) {
				$bio .= ' and is buried there at ' . $burial->address();
			} elsif(my $b = place($opts)) {
				if($diedathome) {
					$bio .= "$pronoun is buried$b";
				} else {
					$bio .= " and is buried$b";
				}
			}
			if($notes && (length($notes) > 160)) {
				$bio .= ".</p><p>";
				$end_of_sentence = 1;
			} else {
				$end_of_sentence = 0;
			}
		}
		$bio .= cite(@burialcitations);
	} elsif(($placeofdeath || $dateofdeath) && !$diedathome) {
		# TODO - extract marriage banns information
		# if($person->marriage_bann()) {
			# die 'foo';
		# }
		if($placeofdeath && (scalar(@spouses) <= 1) && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
			if($end_of_sentence) {
				$bio .= 'That';
			} else {
				$bio .= ', which';
			}
			$bio .= ' is also where ' . lcfirst($pronoun);
		} else {
			$bio .= '.' if(!$end_of_sentence);
			$bio .= "<p>$pronoun";
		}
		$bio .= ' died';
		if($dateofdeath) {
			if($dateofbirth && ($dateofdeath eq $dateofbirth)) {
				$bio .= ' on the same day';
			} elsif($placeofdeath && $placeofmarriage && (scalar(@spouses) == 1) && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
				my $y = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
				if($y =~ /^from (.+) to (.+)/i) {
					$y = "between $1 and $2";
				}
				$bio .= " $y";
			} elsif($placeofbirth && $placeofdeath && ($placeofdeath eq $placeofbirth) && ($placeofdeath =~ /^(.+?),.*/) && !$printed_residence) {
				$bio .= " in $1 " .
					year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
			} else {
				my $y = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
				if($y =~ /^from (.+) to (.+)/i) {
					$y = "between $1 and $2";
				}
				$bio .= " $y";
				if($placeofdeath && ((scalar(@spouses) > 1) || (!$placeofmarriage) || ($placeofdeath ne $placeofmarriage) || $printed_residence)) {
					my $place = place({ person => $person, record => $death, places_printed => \%places_printed });
					if(!defined($place)) {
						$place = place({ person => $person, place => $placeofdeath, places_printed => \%places_printed });
					}
					if(defined($place)) {
						$bio .= $place;
					} else {
						complain({
							person => $person,
							warning => "Place of death ($placeofdeath) can't be parsed"
						});
					}
				}
			}
		} elsif((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage)) {
			$bio .= place({ person => $person, place => $placeofdeath });
		}
		$bio .= cite(@deathcitations);

		# Print notes about the death, if any
		$end_of_sentence = 0;
		if(defined($death) && (my $notes = notes({ person => $person, record => $death, paragraph => 0, note_locations => \@note_locations }))) {
			$notes =~ tr/\r//;
			$notes =~ s/\.$//;
			$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
			$bio .= " ($notes)";
			if(length($notes) > 160) {
				$bio .= ".</p><p>";
			}
		}
		if($bio =~ /\.$/) {
			$end_of_sentence = 1;
		} else {
			$end_of_sentence = 0;
		}
	}
	$bio .= '.' if(!$end_of_sentence);
	$end_of_sentence = 1;

	my $all_events_have_date = 1;
	foreach my $event(@events) {
		if((ref($event) ne 'Gedcom::Record') || !$event->date()) {
			$all_events_have_date = 0;
			last;
		}
		my $date = $event->date();
		if(($date !~ /^\d/) || ($date =~ /[a-z]$/i) ||
		   ($date =~ /[\/\-]/) || !date_parser_cached(date => $date)) {
			$all_events_have_date = 0;
			last;
		}
		if(!date_parser_cached(date => $date)) {
			complain({
				person => $person,
				warning => "Event has an invalid date of $date"
			});
			$all_events_have_date = 0;
			last;
		}
	}
	if($all_events_have_date) {
		@events = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @events;
	}
	if((scalar(@events) == 2) &&
	   (ref($events[0]) eq 'Gedcom::Record') &&
	   (ref($events[1]) eq 'Gedcom::Record') &&
	   ((($events[0]->type() eq 'Arrival') && ($events[1]->type() eq 'Departure')) ||
	   (($events[1]->type() eq 'Arrival') && ($events[0]->type() eq 'Departure')))) {
		# Simple case - one journey made
		$bio .= '. ' if(!$end_of_sentence);

		my $arrival = ($events[0]->type() eq 'Arrival') ? $events[0] : $events[1];
		my $departure = ($events[0]->type() eq 'Departure') ? $events[0] : $events[1];

		$bio .= journey({ person => $person, arrival => $arrival, departure => $departure }) . '.  ';

		$end_of_sentence = 1;
	} elsif(scalar(@events) == 1) {
		$bio .= '.' if(!$end_of_sentence);
		$end_of_sentence = 1;

		my $event = $person->event();
		if(!ref($event)) {
			my $e = $person->tag_record('EVEN');
			if(ref($e) eq 'Gedcom::Record') {
				$event = $e;
			} else {
				red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
				$bio .= ' ' . ucfirst($event) . '.';
			}
		}
		if(ref($event) eq 'Gedcom::Record') {
			my $type = $event->type();
			if(!defined($type)) {
				red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
			} elsif($type eq 'Arrival') {
				$bio .= ' ' . $person->pronoun() . ' arrived';
				if(my $p = place({ person => $person, record => $events[0] })) {
					$bio .= $p;
				} else {
					complain({ person => $person, warning => 'Arrival record has no place' });
				}
				if(my $y = year({ person => $person, record => $events[0] })) {
					$bio .= " $y";
				} else {
					complain({ person => $person, warning => "Arrival record has no date" });
				}
				if(my $spouse = $spouses[0]) {
					foreach my $sevent($spouse->event()) {
						if(ref($sevent) eq 'Gedcom::Record') {
							my $type = $event->type();
							if(!defined($type)) {
								red_warning({ person => $spouse, warning => "Can't determine type of event, or the event type is empty" });
							} elsif($sevent->place() && ($type eq 'Arrival') &&
							   $event->date() && $sevent->date() &&
							   ($event->date() eq $sevent->date()) &&
							   ($event->place() eq $sevent->place())) {
								$bio .= ' with ' .
									lcfirst($person->possessive()) . ' ' .
									(($sex eq 'M') ? 'wife' : 'husband') .
									' ' . $spouse->given_names();
							}
						}
					}
				}
				if(my $notes = notes({ record => $event, note_locations => \@note_locations })) {
					$notes = lcfirst($notes);
					$notes =~ s/\.$//;
					$bio .= " ($notes)";
				}
				$bio .= '. ';
				if($ENV{'LANG'} =~ /^en_US/) {
					$place_records{'Traveled to'} = $event;
				} else {
					$place_records{'Travelled to'} = $event;
				}
			} elsif($type eq 'Departure') {
				$bio .= ' ' . $person->pronoun();
				if($ENV{'LANG'} =~ /^en_US/) {
					$bio .= ' traveled';
				} else {
					$bio .= ' travelled';
				}
				my $place = place({ person => $person, record => $events[0] });
				$place =~ s/^\sin/ from/;
				$bio .= "$place " .
					year({ person => $person, record => $events[0] });
				if(my $notes = notes({ record => $event, note_locations => \@note_locations })) {
					$notes = lcfirst($notes);
					$bio .= " ($notes)";
				}
				$bio .= '. ';
			} elsif(($type eq 'Military service') || ($type eq 'Military')) {
				$bio .= '.' if(!$end_of_sentence);
				my $date = year(record => $event);
				if($date && ($date !~ /^from /i)) {
					$bio .= ' ' . ucfirst($date) . ' ' . lcfirst($pronoun) . ' was serving in the military';
				} else {
					$bio .= " $pronoun was serving in the military";
				}
				if(my $place = place({ person => $person, record => $event })) {
					$bio .= $place;
				}
				if($date && ($date =~ /^from /i)) {
					$bio .= " $date";
				}

				if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
					$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
					$notes =~ s/[\s\.]+$//;
					$bio .= " (<em>$notes</em>)";
				}
				$end_of_sentence = 0;
			# } elsif(($type !~ /^Census U[KS] \d{4}$/) &&
			} elsif(($type !~ /Census/) &&
				($type ne 'Race') &&
				($type ne 'Custom Marriage') &&
				($type ne 'Email') &&
				($type ne 'Register UK 1939')) {

				red_warning({ person => $person, warning => "Unhandled event type: $type" });
				if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
					$notes = ucfirst($notes);
					$bio .= " ($notes)";
					$end_of_sentence = 0;
				}
			}
		}
	} else {
		my $mentioned_military;
		my $index = 0;
		my $previous;
		my $prev_type;
		foreach my $event(@events) {
			$index++;
			if(!ref($event)) {
				my $e = $person->tag_record('EVEN', $index);
				if(ref($e) eq 'Gedcom::Record') {
					$event = $e;
				} else {
					red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
					$bio .= ' ' . ucfirst($event) . '.';
				}
			}
			if(ref($event) eq 'Gedcom::Record') {
				my $type = $event->type();
				if($type eq 'Military service') {
					if(!$mentioned_military) {
						$bio .= '.' if(!$end_of_sentence);
						$bio .= " $pronoun served in the military";
						if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
							$bio .= $place;
						}
						if(my $date = year(record => $event)) {
							$bio .= " $date";
						}
						$mentioned_military = 1;
					}

					if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
						$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
						$notes =~ s/[\s\.]+$//;
						$bio .= " (<em>$notes</em>)";
					}
					$end_of_sentence = 0;
				} elsif($type eq 'Arrival') {
					if(!defined($event->place())) {
						complain({ person => $person, warning => 'Arrival record without destination' });
						next;
					}
					if($events[$index] && (ref($events[$index]) eq 'Gedcom::Record') && ($events[$index]->type() eq 'Departure') && $event->date()) {
						if($events[$index]->date()) {
							$previous = $event;
							$prev_type = 'Arrival';
							# FIXME: not all locations will be noted or notes printed
							next;
						}
					}
					if($previous) {
						if($prev_type eq 'Departure') {
							$bio .= journey({ person => $person, arrival => $event, departure => $previous });
						} else {
							# Two arrival records, put into one sentence for improved readability
							my $date1 = year({ record => $previous });
							my $date2 = year({ record => $event });
							my $year1;
							my $year2;
							if($date1 =~ /(.*)\s?(\d{4})$/) {
								$date1 = $1;
								$year1 = $2;
								$date1 =~ s/,\s//;
							}
							if($date2 =~ /(.*)\s?(\d{4})$/) {
								$date2 = $1;
								$year2 = $2;
								$date2 =~ s/,\s//;
							}
							$bio .= '. ' if(!$end_of_sentence);
							if(defined($year1) && defined($year2) && ($year1 == $year2)) {
								if($date1 eq 'in ') {
									$date1 = '';
								} else {
									$date1 = " $date1";
								}
								$bio .= "During $year1 " . lcfirst($pronoun) . ' arrived' .
									place({ person => $person, record => $previous }) .
									" $date1 and" .
									place({ person => $person, record => $event, nopreposition => 1 }) .
									" $date2.";
							} else {
								$bio .= ucfirst(year({ person => $person, record => $previous })) .
									' ' . lcfirst($person->pronoun()) .
									' arrived' .
									place({ person => $person, record => $previous }) .
									' and ' .
									year({ person => $person, record => $event }) .
									' ' . lcfirst($pronoun) .
									' arrived' .
									place({ person => $person, record => $event }) . '.';
							}
						}
						$previous = undef;
					} elsif(my $place = place({ person => $person, record => $event })) {
						if(my $year = year({ person => $person, record => $event })) {
							if($end_of_sentence) {
								$bio .= ucfirst($year);
							} else {
								$bio .= $year;
							}
							$bio .= ' ' . lcfirst($person->pronoun()) . " arrived$place.";
						} else {
							complain({ person => $person, warning => "Can't determine $type date" });
						}
					} else {
						complain({ person => $person, warning => "Can't determine $type location" });
					}
					if(my $notes = notes({ record => $event, note_locations => \@note_locations })) {
						$notes = lcfirst($notes);
						$bio .= " ($notes)";
					}
					$bio .= '.';
					$end_of_sentence = 1;
				} elsif($type eq 'Departure') {
					if(!defined($event->place())) {
						complain({ person => $person, warning => 'Departure record without destination' });
						next;
					}
					if(my $e = $events[$index]) {
						if(ref($e) && ($e->type() eq 'Arrival') && $event->date() && $e->date()) {
							$previous = $event;
							$prev_type = 'Departure';
							# FIXME: not all locations will be noted or notes printed
							next;
						}
					}
					if($previous) {
						if($prev_type eq 'Arrival') {
							$bio .= journey({ person => $person, arrival => $event, departure => $previous });
						}
						$previous = undef;
					} else {
						$bio .= ' ' . $person->pronoun();
						if($ENV{'LANG'} =~ /^en_US/) {
							$bio .= ' traveled';
						} else {
							$bio .= ' travelled';
						}
						my $place = place({ person => $person, record => $event });
						$place =~ s/^\sin/ from/;
						if($event->date()) {
							$bio .= "$place " .
								year({ person => $person, record => $event });
						} else {
							$bio .= $place;
						}
					}
					if(my $notes = notes({ record => $event, note_locations => \@note_locations })) {
						$notes = lcfirst($notes);
						$bio .= " ($notes)";
					}
					$bio .= '.';
					$end_of_sentence = 1;
				} elsif($type eq 'Story') {
					if(my $notes = notes(record => $event)) {
						if(!$end_of_sentence) {
							$bio .= '. ';
						}
						$notes =~ s/\.$//;
						# TODO:  Do this if the notes doesn't include a date
						# if(my $date = year(record => $event)) {
							# $bio .= ' ' . ucfirst($notes) . " $date. ";
						# } else {
							$bio .= ' ' . ucfirst($notes) . '. ';
						# }
						$end_of_sentence = 1;
					}
				} elsif($type eq 'Court') {
					$bio .= '. ' if(!$end_of_sentence);
					$bio .= " $pronoun was in court";
					if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
						$bio .= $place;
					}
					if(my $date = year(record => $event)) {
						$bio .= " $date";
					}
					if(my $notes = notes(record => $event)) {
						$notes = lcfirst($notes);
						$notes =~ s/\.$//;
						$bio .= " ($notes).";
						$end_of_sentence = 1;
					}
				# } elsif(($type !~ /^Census U[KS] \d{4}$/) &&
				} elsif(($type !~ /Census/) &&
					($type ne 'Register UK 1939') &&
					($type ne 'Race') &&
					($type ne 'Hospitalisation')) {
					red_warning({ person => $person, warning => "Unknown event type: $type" });
					if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
						$notes =~ s/\.$//;
						my $date = year(record => $event);
						if($end_of_sentence) {
							if($date) {
								$bio .= ' ' . ucfirst($notes) . " $date. ";
							} else {
								$bio .= ' ' . ucfirst($notes) . '. ';
							}
						} else {
							$notes = lcfirst($notes);
							if($date) {
								$bio .= " ($date, $notes)";
							} else {
								$bio .= " ($notes)";
							}
						}
					}
				}
			}
		}
		$bio .= '.' if(!$end_of_sentence);
		$end_of_sentence = 1;
	}

	if(my $profile_object = $person->tag_record('_MILT')) {
		# $person->resolve_xref($profile_object->value());
		if(my $value = $profile_object->get_value()) {
			$bio .= '.' if(!$end_of_sentence);
			$value =~ s/[\s\.]+$//;
			$bio .= " $pronoun served in the military ($value).";
			$end_of_sentence = 1;
		}
	}

	if($language eq 'English') {
		if($ENV{'LANG'} =~ /^en_US/) {
			$bio = Lingua::EN::ABC::b2a($bio);
		} elsif($ENV{'LANG'} =~ /^en_CA/) {
			$bio = Lingua::EN::ABC::b2c($bio);
		} else {
			$bio = Lingua::EN::ABC::a2b($bio);
		}
	}

	print $html $bio;
	$fullbio .= $bio;

	if($opts{'l'} || !$is_alive) {
		print $csv $bio;
		$bio =~ s/&/&amp;/g;
		$bio =~ s/&amp;amp;/&amp;/g;	# Because of the Encode entities
		$bio =~ s/&amp;Acirc;&amp;copy;/&#169;/g;
		$bio =~ s/&amp;acirc;&amp;#128;&amp;#152;//g;
		$bio =~ s/&amp;pound;/&#163;/g;
		$bio =~ s/&amp;#39;/'/g;
		$bio =~ s/&amp;#/&#/g;
		$bio =~ s/</&lt;/g;
		$bio =~ s/>/&gt;/g;
		$bio =~ s/&eacute;/&#233;/g;
		$bio =~ s/\xc3\xb1/&#241;/g;	# ntilde
		$bio =~ s/\xc3\xab/&#235;/g;	# eumlaut
		$bio =~ s/&Atilde;&laquo;/&#235;/g;	# ACOM bizarre
		print $xml $bio;
	}
	print $csv '!';
	print $xml "\n\t\t\t</en>\n\t\t</bio>";

	if($opts{'l'} || !$is_alive) {
		print "Create parents\n" if($opts{'v'});
		print $html '</p>';
		if($mother || $father) {
			print $html "<h2>Parents</h2><ol>";
			if($father && (my $f = person_line_html({ person => $father, year => $year }))) {
				print $html "<li>$f</li>";
				print $csv person_line_csv({ person => $father, year => $year });
				my $x = HTML::Entities::encode($f);
				print $xml "\n\t\t<father>$x</father>";
			}
			print $csv '!';
			if($mother && (my $m = person_line_html({ person => $mother, year => $year }))) {
				print $html "<li>$m</li>";
				print $csv person_line_csv({ person => $mother, year => $year });
				my $x = HTML::Entities::encode($m);
				print $xml "\n\t\t<mother>$x</mother>";
			}
			print $html '</ol>';
		} else {
			print $csv '!';
		}
		print $csv '!';
		my $printed_children_header;

		my $c = '';
		foreach my $child(@children) {
			my $line = person_line_html({ person => $child, year => $year });
			next if($line eq '');
			if(!$printed_children_header) {
				print $html '<h2>Children</h2><ol>';
				print $xml "\n\t\t<children>";
				$printed_children_header = 1;
			}
			print $html "<li>$line</li>";
			my $x = HTML::Entities::encode($line);
			$x =~ s/&Atilde;&laquo;/&#235;/g;	# ACOM bizarre
			print $xml "\n\t\t\t<child>$x</child>";
			if(length($c)) {
				$c .= '----' . person_line_csv({ person => $child, year => $year });
			} else {
				$c = person_line_csv({ person => $child, year => $year });
			}
			if($opts{'w'} && ($birth_dt || $death_dt)) {
				my $dob = dateofbirth($child);
				if($dob && ($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
					if(my $d = date_parser_cached(date => $dob)) {
						$d = $dfn->parse_datetime($d->{'canonical'});
						if($birth_dt && ($d <= $birth_dt)) {
							complain({ person => $child, warning => 'born before parent was born' });
						}
						if(($sex eq 'F') && $death_dt && ($d > $death_dt)) {
							complain({ person => $child, warning => 'born after mother died' });
						} elsif(($sex eq 'M') && $death_dt && ($d > ($death_dt + $tenmonths))) {
							# Allow the child to be
							# born up to 9 months
							# after the death of the
							# father
							complain({ person => $child, warning => 'born more than 10 months after father died' });
						}
					}
				}
			}
		}
		if($printed_children_header) {
			print $html '</ol>';
			print $xml "\n\t\t</children>";
		}
		print $csv $c;
	} else {
		print $csv '!!';
	}

	print $csv '!';
	my $profile_image;
	my $profile_thumbnail;

	if($opts{'l'} || !$is_alive) {
		if($opts{'c'} && $citationcount) {
			print "Create $citationcount citations\n" if($opts{'v'});
			print $html '<h2>Citations</h2><ol>';
			print $xml "\n\t\t<citations>";
			my $ufinder = URI::Find::Schemeless->new(sub {
				my($uri, $orig_uri) = @_;

				my $u = URI->new($orig_uri);
				if($u && (ref($u) ne 'URI::_generic')) {
					if((!$browser->head($orig_uri)) && !$browser->get($orig_uri)) {
						complain({ person => $person, warning => "$orig_uri: not found" });
					} else {
						$uri =~ s/:$//;
						return "<a href=\"$uri\">" .
							$u->host() .
							'</a>';
					}
				}
				return $orig_uri;
			});

			my %census_years;
			foreach my $citation(1..$citationcount) {
				if(!$citations{$citation}) {
					complain({
						person => $person,
						warning => "[$citation]: empty citation"
					});
				}
				my $title = $citations{$citation}->title();
				if(!defined($title)) {
					$title = notes(record => $citations{$citation});
					if(!defined($title)) {
						complain({
							person => $person,
							warning => "[$citation]: no citation title"
						});
						$title = 'No citation title';
					}
				}
				my $c;
				if(my $file = $citations{$citation}->file()) {
					$c = "<a href=\"$file\">" . HTML::Entities::encode($title) . '</a>';
				} else {
					$c = HTML::Entities::encode($title);
					if($title =~ /Census/) {
						if(my $census = $censusmaps{$title}) {
							# TODO: Add pointer to image
							$censuses{$census}->{$person->as_string(include_years => 1)} = $person;
						} else {
							complain({ person => $person, warning => "Add $title to censusmaps" });
						}
					}
				}
				if(defined(my $publication = $citations{$citation}->publication())) {
					$c .= ' ' . HTML::Entities::encode($publication);
					if(defined(my $continuation = $citations{$citation}->cont())) {
						$c .= ' ' . HTML::Entities::encode($continuation);
					}
				}
				if(defined(my $page = $citations{$citation}->page())) {
					$c .= ' ' . HTML::Entities::encode($page);
				}
				my @notes = $citations{$citation}->note();
				foreach my $note(@notes) {
					if(ref($note) eq 'Gedcom::Record') {
						$note = $note->note();
					}

					if($note && ($note !~ /^This information comes from/)) {
						$ufinder->find(\$note);
						$c .= ' (' . HTML::Entities::encode($note) . ')' unless($note eq $title);
					}
				}
				if($citationnotes{$citation}) {
					$citationnotes{$citation} =~ s/\.$//;
					$c .= ' (' . HTML::Entities::encode($citationnotes{$citation}) . ')';
				}
				if(($title =~ /census/i) && ($title =~ /(\d{3,4})/)) {
					$census_years{$1} = $title;
				}

				my $h = $c;
				if($h =~ s/&lt;a href=&quot;http/<a href="http/gi) {
					$h =~ s/&quot;&gt;/">/g;
					$h =~ s/&lt;\/a&gt;/<\/a>/gi;
				}
				print $html "<li>$h</li>";
				print $csv '----' if($citation > 1);
				print $csv $h;
				$c =~ s/&/&amp;/g;
				$c =~ s/&amp;Acirc;&amp;copy;/&#169;/g;
				$c =~ s/&amp;acirc;&amp;#128;&amp;#152;//g;
				$c =~ s/&amp;amp;/&amp;/g;	# Because of the Encode entities
				print $xml "\n\t\t\t<citation>$c</citation>";
			}
			print $html '</ol>';
			print $xml "\n\t\t</citations>";

			if($opts{'w'}) {
				# People alive during the years when censuses have been available must
				# have appeared in at least one census
				# FIXME:  should be a better test, e.g. catch people 1861-1930, don't
				#	catch 1862-1865.  The current test misses some but should have
				#	no false positives
				print "Checking for missing census entries\n" if($opts{'v'});
				if((defined($yob) && ($yob >= 1841)) &&
				  ((defined($yod)) && ($yod <= 1911)) &&
				  (($yod - $yob) >= 10) &&
				  (scalar(keys(%census_years)) == 0)) {
					complain({ person => $person, warning => 'Appears in no censuses' });
				}
				my %unused_censuses = %census_years;
				foreach my $residence(@residencelist) {
					if(my $rdate = $residence->date()) {
						if($rdate =~ /(\d{3,4})$/) {
							$rdate = $1;
							delete $unused_censuses{$1};
						}
					}
				}
				foreach my $year(sort keys %unused_censuses) {
					complain({
						person => $person,
						warning => "The census for year $year has been cited, but its information has not been used as a residence"
					});
				}
				foreach my $event(@events) {
					if(ref($event) eq 'Gedcom::Record') {
						my $type = $event->type();
						my $year;
						if($type =~ /^Census U[KS] (\d{4})$/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
						} elsif($type eq 'Register UK 1939') {
							if(!$event->date()) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
							$year = 1939;
						} elsif($type =~ /^(\d{4}) Census of Canada/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
							# Check Location includes Canada
							if(my $place = place({ person => $person, record => $event, nopreposition => 1 })) {
								if($place =~ /Canada$/i) {
									complain({ person => $person, warning => "Canadian census for $year doesn't list Canada as the location" });
								}
							} else {
								complain({ person => $person, warning => "Canadian census for $year doesn't list Canada as the location" });
							}
						} elsif($type eq 'Census') {
							if(my $date = $event->date()) {
								if($date =~ /(\d{4})$/) {
									$year = $1;
								}
							}
							if(!defined($year)) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
						} else {
							next;
						}
						$census_years{$year} = $type;
						if(defined($yod) && ($year > $yod)) {
							complain({ person => $person, warning => "Census for $year after year of death ($yod)" });
						} elsif(defined($yob) && ($year < $yob)) {
							complain({ person => $person, warning => "Census for $year before year of birth ($yob)" });
						}
					}
				}
				foreach my $year(sort { $a <=> $b } keys(%census_years)) {
					if($census_years{$year + 20} && !$census_years{$year + 10}) {
						complain({
							person => $person,
							warning => 'Census information missing between ' . $census_years{$year} . ' and ' . $census_years{$year + 20}
						});
					}
				}
				if($dateofdeath && !defined($placeofdeath)) {
					complain({ person => $person, warning => 'Date of death is known, but not place' });
				} elsif($placeofbirth && $placeofdeath && $dateofdeath && (!$census_years{1939}) &&
				   (datecmp($dateofdeath, '1939') >= 0) && ($placeofbirth =~ /England$/) && ($placeofdeath =~ /England$/) &&
				   ((!$dateofbirth) || (datecmp($dateofbirth, '1939') <= 0))) {
					my $has1939 = 0;
					foreach my $residence(@residencelist) {
						if($residence->date() && ($residence->date() =~ /1939$/)) {
							$has1939 = 1;
							last;
						}
					}
					if(!$has1939) {
						complain({
							person => $person,
							warning => '1939 UK register information missing'
						});
					}
				}
			}
		}

		print $csv '!';

		# my $printed_notes;
		# if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 1 }))) {
			# print $html "<h2>Notes</h2>$notes";
			# $printed_notes = 1;
			# print $csv notes({ person => $person, record => $death });
		# }

		if(($person->get_value('note')) &&
		   (my $notes = notes({ person => $person, paragraph => 1, record => $person, note_locations => \@note_locations }))) {
			print "Handling notes\n" if($opts{'v'});
			print $html '<h2>Notes</h2>';

			print $html $notes;
			# print $csv '----' if($printed_notes);
			my $n = notes({ person => $person, record => $person, note_locations => \@note_locations, encode => 0 });
			$n =~ s/"/<&quot;>/g;
			print $csv $n;
			$notes =~ s/&pound;/&#163;/g;
			# $notes =~ s/</&lt;/g;
			# $notes =~ s/>/&gt;/g;
			$notes =~ s/\s*&excl;/!/g;
			$notes =~ s/&Acirc;//gi;
			$notes =~ s/&Atilde;&copy;//gi;
			$notes =~ s/^<p>//;
			$notes =~ s/<\/p>$//;
			$notes =~ s/<br>/<br \/>/g;
			print $xml "\n\t\t<note><p>$notes</p></note>";
			# print $html map { "<p>$_</p>" } @notes;
		}

		print $csv '!';

		# FIXME: Should be a table mapping from records to profiles
		my $s_profile_image;

		# print 'f:', $person->form() if($person->form());

		my @objlist = $person->obje();
		if(scalar(@objlist)) {
			print "Downloading objects\n" if($opts{'v'});
			# TODO - find primary and do something different with that
			#	The obje should be in order with primary first, but FMP
			#	doesn't do that
			#	Gedcom doesn't seem to be able to handle extra _ tags,
			#	or if it can I can't work out how to make use of it
			warn $person->{"_prof"}, "\n" if($person->{'_prof'});
			warn $person->{"prof"}, "\n" if($person->{'prof'});
			warn $person->{"_PROF"}, "\n" if($person->{'_PROF'});
			warn $person->{"PROF"}, "\n" if($person->{'PROF'});
			warn $person->{"_prim"}, "\n" if($person->{'_prim'});
			warn $person->{"prim"}, "\n" if($person->{'prim'});
			warn $person->{"_PRIM"}, "\n" if($person->{'_PRIM'});
			# warn $person->tag_records("PRIM"), "\n" if($person->tag_records('PRIM'));
			# warn $person->tag_records("_PRIM"), "\n" if($person->tag_records('_PRIM'));
			# warn $person->get_value("_prof"), "\n" if($person->get_value('_prof'));
			# warn $person->get_value("prof"), "\n" if($person->get_value('prof'));
			# warn $person->get_value("_PROF"), "\n" if($person->get_value('_PROF'));
			# warn $person->get_value("PROF"), "\n" if($person->get_value('PROF'));
			# warn $person->get_value("_prim"), "\n" if($person->get_value('_prim'));
			# warn $person->get_value("prim"), "\n" if($person->get_value('prim'));
			# warn $person->get_value("_PRIM"), "\n" if($person->get_value('_PRIM'));
			my $profile_object = $person->tag_record('_PROF');
			if($profile_object) {
				$profile_object = $person->resolve_xref($profile_object->value());
			}
			my $printed_media_header = 0;

			my %downloadhistory;

			# Two passes, the first one where the links are pictures, the second where they are not
			for(my $pass = 1; $pass <= 2; $pass++) {
				print "Media pass $pass\n" if($opts{'v'});
				OBJE: foreach my $o(@objlist) {
					my $obje;
					if(ref($o) eq 'Gedcom::Record') {
						$obje = $o;	# e.g. Ancestry
					} else {
						$obje = $ged->resolve_xref($o);	# e.g. FMP
					}
					next if(!defined($obje));
					if(my $file = $obje->file()) {
						if(ref($file) eq 'Gedcom::Record') {
							# warn $file->tag(), "\n" if($file->tag());
							$file = $file->{'file'};
							next if($file eq '*');
						}
						if(!$printed_media_header) {
							print $html '<h2>Media</h2>';
							print $xml "\n\t\t<media>";
							$printed_media_header = 1;
						}

						warn $obje->{"_prim"}, "\n" if($obje->{'_prim'});
						warn $obje->{"prim"}, "\n" if($obje->{'prim'});
						warn $obje->{"_PRIM"}, "\n" if($obje->{'_PRIM'});
						warn $obje->{"PRIM"}, "\n" if($obje->{'PRIM'});
						warn $obje->{"_prof"}, "\n" if($obje->{'_prof'});
						warn $obje->{"prof"}, "\n" if($obje->{'prof'});
						warn $obje->{"_PROF"}, "\n" if($obje->{'_PROF'});
						warn $obje->{"PROF"}, "\n" if($obje->{'PROF'});
						warn $obje->{"_DATE"}, "\n" if($obje->{'_DATE'});
						warn $obje->{"_date"}, "\n" if($obje->{'_date'});
						# warn $obje->tag(), "\n" if($obje->tag());
						my $title = $obje->title() || $obje->tag_record('TITL', 1);
						$title =~ s/\s\s+/ /g;
						my $form = $obje->form();
						if((!$form) && $obje->items()) {
							# Family Tree Maker does this
							my @items = $obje->items();
							$file = $items[0]->{'value'};
							# TODO: Find the title
						}
						$file =~ s/\{0\}//g;
						$file =~ s/\r//g;
						if($opts{'d'} && ($file =~ /^https?:\/\//) && ($file !~ /\.jpe?g$/) && ($file !~ /ancestry.com.*image.*guid=/)) {
							$file =~ s/%2f/\//gi;

							my $localfile = 'static-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
							# FIXME: It should check if the remote image is newer than the local image
							if(!-r $localfile) {
								if($file =~ /^http:\/\/(\w+)\.findmypast\.(co[\w\.]+)\/(.+)/) {
									$file = "https://$1.findmypast.$2/$3";
								}
								print "Download non-image $file\n" if($opts{'v'});
								my $resp = $cached_browser->get($file);
								if($resp->is_success() && ($resp->content_type() eq 'image/jpeg')) {
									next OBJE if($pass == 2);
									my $key = $person->as_string() . ";$localfile";
									if($images{$key}) {
										# Flag a person having two images of the same
										# name
										complain({ person => $person, warning => "duplicate filename: $localfile" });
									}
									my $tmp;
									if($jpegtran) {
										open($tmp, '|-', "$jpegtran -progressive -outfile '$localfile'");
									} elsif($jpegoptim) {
										open($tmp, '|-', "$jpegoptim -q --all-progressive --stdin > '$localfile'");
									} else {
										open($tmp, '>', $localfile);
									}
									print $tmp $resp->decoded_content();
									close $tmp;
									$form = 'JPG';
									$images{$key} = 1;
									if($^O eq 'MSWin32') {
										copy($localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg');
									} else {
										link $localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
										chmod 0444, $localfile;
									}
								}
							}
						} elsif(($file =~ /^([A-Z]:[\/\\].+\.jpe?g+)/) || ($file =~ /^(\/.+\.jpe?g)/)) {
							next OBJE if($pass == 2);
							my $srcfile = $1;
							if(!-r $srcfile) {
								# Patch from github.com/cablespaghetti
								complain({ person => $person, warning => "$srcfile: file not found" });
								next OBJE;
							}
							my $localfile = 'static-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
							if(!-r $localfile) {
								if($jpegtran) {
									system("$jpegtran -progressive -outfile '$localfile' '$srcfile'");
								} elsif($jpegoptim) {
									copy($srcfile, $localfile);
									system("$jpegoptim -q --all-progressive '$localfile'");
								} else {
									copy($srcfile, $localfile);
								}
								if($^O eq 'MSWin32') {
									copy($localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg');
								} else {
									link $localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
								}
							}
							$form = 'JPG';
							my $key = $person->as_string() . ";$localfile";
							$images{$key} = 1;
						}
						if($form && (lc($form) eq 'jpg')) {
							next OBJE if($pass == 2);
							if($title) {
								print $html "<h3>$title</h3>";
							} else {
								print $html '<br>';
							}
							if($opts{'d'}) {
								if($downloadhistory{$file}) {
									# Ancestry does this
									print "Skip duplicate image $file\n" if($opts{'v'});
									next OBJE;
								}
								$downloadhistory{$file} = 1;

								# Get and stash a local copy
								if($file =~ /ancestry.com.+guid=.+&tid=/) {
									# Ancestry's Gedcoms are broken, perhaps pointing to an old
									# location that they forgot to fix
									print "Map from $file\n" if($opts{'v'});
									if($file =~ /guid=([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/) {
										# FIXME: Ancestry pictures attached from another
										# tree aren't downloaded.  This URL will generate a
										# 404
										$file = "https://mediasvc.ancestry.com/v2/image/namespaces/1093/media/$1.jpg?client=Trees";
									} elsif($opts{'w'}) {
										complain({ person => $person, warning => "BUG: update ACOM mapping for $file" });
										next OBJE;
									}
								}
								if($file =~ /^http:\/\/(\w+)\.findmypast\.(co[\w\.]+)\/(.+)/) {
									$file = "https://$1.findmypast.$2/$3";
								}
								print "Download image $file\n" if($opts{'v'});
								my $localfile = 'img/' . make_filename_from_object(object => $obje) . '.jpg';
								my $rc;
								if((-r "static-site/$localfile") ||
								   is_success($rc = getstore($file, "static-site/$localfile"))) {
									my $info = Image::Info::image_info("static-site/$localfile");
									my ($w, $h) = Image::Info::dim($info);
									if(!defined($w)) {
										complain({ person => $person, warning => "Can't get image information for static-site/$localfile" });
										# unlink "static-site/$localfile";
										next OBJE;
									}
									$h *= 175 / $w;
									$h = int($h);
									# print $html "<a href=\"$file\" target=\"_blank\">",
									my $escaped_file = $localfile;
									$escaped_file =~ s/&/&amp;/g;
									if($title) {
										print $html "<a href=\"$localfile\" target=\"_blank\">",
											'<img src="', $localfile, "\" alt=\"$title\" width=\"175\" height=\"$h\">",
											'</a>';
										print $csv "/$localfile---$title---$h----";
										my $escaped_title = $title;
										$escaped_title =~ s/&/&amp;/g;
										print $xml "\n\t\t\t<image>\n\t\t\t\t<file>$escaped_file</file>\n\t\t\t\t<title>$escaped_title</title>\n\t\t\t\t<height>$h</height>\n\t\t\t</image>";
									} else {
										print $html "<a href=\"$localfile\" target=\"_blank\">",
											'<img src="', $localfile, "\" width=\"175\" height=\"$h\">",
											'</a>';
										print $csv "/$localfile--- ---$h----";
										print $xml "\n\t\t\t<image>\n\t\t\t\t<file>$escaped_file</file>\n\t\t\t\t<height>$h</height>\n\t\t\t</image>";
									}
									if(defined($profile_object) && ($obje eq $profile_object)) {
										$s_profile_image = "static-site/$localfile";
									}
									unless(-r "dynamic-site/$localfile") {
										if($^O eq 'MSWin32') {
											copy("static-site/$localfile", "dynamic-site/$localfile");
										} else {
											link "static-site/$localfile", "dynamic-site/$localfile";
										}
									}
								} else {
									red_warning({ person => $person, warning => "download $file failed to static-site/$localfile: $rc" });

									if($title) {
										print $html "<a href=\"$file\" target=\"_blank\">",
											"<img src=\"$file\" alt=\"$title\" width=\"175\">",
											'</a>';
										print $csv "$file---$title---0----";
										$title =~ s/&/&amp;/g;
										print $xml "\n\t\t<image><url>$file</url><title>$title</title></image>";
									} else {
										print $html "<a href=\"$file\" target=\"_blank\">",
											"<img src=\"$file\" width=\"175\">",
											'</a>';
										print $csv "$file--- ---0----";
										print $xml "\n\t\t<image><url>$file</url></image>";
									}
									if(defined($profile_object) && ($obje eq $profile_object)) {
										$s_profile_image = $file;
									}
								}
							} else {
								# Use the remote copy
								if($title) {
									print $html "<a href=\"$file\" target=\"_blank\">",
										"<img src=\"$file\" alt=\"$title\" width=\"175\">",
										'</a>';
									print $csv "$file---$title---0----";
									$title =~ s/&/&amp;/g;
									print $xml "\n\t\t<image><url>$file</url><title>$title></title></image>";
								} else {
									print $html "<a href=\"$file\" target=\"_blank\">",
										"<img src=\"$file\" width=\"175\">",
										'</a>';
									print $csv "$file--- ---0----";
									print $xml "\n\t\t<image><url>$file</url></image>";
								}
								if(defined($profile_object) && ($obje eq $profile_object)) {
									$s_profile_image = $file;
								}
							}
						} else {
							next OBJE if($pass == 1);
							print $html "<a href=\"$file\" target=\"_blank\">",
								$title ? HTML::Entities::encode($title) : 'Media',
								'</a>';
							print $csv "$file---",
								$title ? HTML::Entities::encode($title) : 'Media',
								'---0----';
							if($file =~ /^https?:/) {
								$file = HTML::Entities::encode($file);
								if($title) {
									$title = HTML::Entities::encode($title);
									$title =~ s/&acirc;//g;
									print $xml "\n\t\t\t<image>\n\t\t\t\t<url>$file</url>\n\t\t\t\t<title>$title</title>\n\t\t\t</image>";
								} else {
									print $xml "\n\t\t\t<image>\n\t\t\t\t<url>$file</url>\n\t\t\t</image>";
								}
							} else {
								if($title) {
									$title = HTML::Entities::encode($title);
									$title =~ s/\xc3\xab/&#235;/g;	# eumlaut
									print $xml "\n\t\t\t<image>\n\t\t\t\t<file>$file</file>\n\t\t\t\t<title>$title</title>\n\t\t\t</image>";
								} else {
									print $xml "\n\t\t\t<image>\n\t\t\t\t<file>$file</file>\n\t\t\t</image>";
								}
							}
						}
						# if($obje->date()) {
							# die $obje->date();
						# }
						print $html '<br>';
					}
				}
			}
			if($printed_media_header) {
				print $xml "\n\t\t</media>";
			}
		}
		print $csv '!';

		if(defined($dot)) {
			print "Create family tree\n" if($opts{'v'});
			my $png = 'static-site/img/' . make_filename_from_object(object => $person) . '.png';
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/bin/cat')) {
				# print $fout 'digraph family { graph [rankdir=LR];';
				print $fout 'digraph family {',
					' subgraph parents { rank="min"; ';
				if($father) {
					print_graphviz({ person => $father, fout => $fout, format => 'static' });
				}
				if($mother) {
					print_graphviz({ person => $mother, fout => $fout, format => 'static' });
				}
				print $fout '} subgraph main { rank="same"; ';
				print_graphviz({ person => $person, fout => $fout, profile_image => $s_profile_image, format => 'static' });
				foreach my $spouse(@spouses) {
					print_graphviz({ person => $spouse, fout => $fout, format => 'static' });
				}
				print $fout '} subgraph children { rank="max"; ';
				# TODO: sort by date of birth
				foreach my $child(@children) {
					print_graphviz({ person => $child, fout => $fout, format => 'static' });
				}
				print $fout '} ';

				if($mother) {
					print $fout $mother->xref(), ' -> ', $person->xref(), ";\n";
				}
				if($father) {
					print $fout $father->xref(), ' -> ', $person->xref(), ";\n";
				}
				if(scalar(@spouses) == 2) {
					# Married twice, put the person in the middle,
					# it looks better
					# print $fout $person->xref(), ' -> ', $spouses[0]->xref(), " [dir=none];\n";
					print $fout $spouses[0]->xref(), ' -> ',
						$person->xref(), ' -> ',
						$spouses[1]->xref(), " [dir=none];\n";
				} else {
					foreach my $spouse(@spouses) {
						print $fout $person->xref(), ' -> ', $spouse->xref(), " [dir=none];\n";
						# print $fout $person->xref(), ' -> ', $spouse->xref(), " [dir=none];\n";
					}
				}
				foreach my $child(@children) {
					print $fout $person->xref(), ' -> ', $child->xref(), ";\n";
				}

				print $fout '}';
				close $fout;

				print $html '<h2>Family Tree</h2>';
				my $filename = make_filename_from_object(object => $person);
				my $dim = Image::Info::html_dim(Image::Info::image_info($png));
				print $html "<img src=\"img/$filename.png\" $dim", ' usemap="#family" alt="Family Tree">';
				$tmp->seek(0, SEEK_SET);
				foreach my $line(<$tmp>) {
					chomp $line;
					print $html $line;
				}
			}
			$png = "dynamic-site/img/" . make_filename_from_object(object => $person) . '.png';
			$tmp = File::Temp->new();
			$filename = $tmp->filename();
			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/bin/cat')) {
				# print $fout 'digraph family { graph [rankdir=LR];';
				# Best to agree with the colour in css/web.css
				# print $fout 'digraph family { bgcolor="#d6d6d6"',
				print $fout 'digraph family {',
					' subgraph parents { rank="min"; ';
				if($father) {
					print_graphviz({ person => $father, fout => $fout, format => 'dynamic' });
				}
				if($mother) {
					print_graphviz({ person => $mother, fout => $fout, format => 'dynamic' });
				}
				print $fout '} subgraph main { rank="same"; ';
				$profile_image = $s_profile_image;
				if(defined($profile_image)) {
					$profile_image =~ s/static/dynamic/;
				}
				$profile_thumbnail = print_graphviz({ person => $person, fout => $fout, profile_image => $profile_image, format => 'dynamic' });
				foreach my $spouse(@spouses) {
					print_graphviz({ person => $spouse, fout => $fout, format => 'dynamic' });
				}
				print $fout '} subgraph children { rank="max"; ';
				# TODO: sort by date of birth
				foreach my $child(@children) {
					print_graphviz({ person => $child, fout => $fout, format => 'dynamic' });
				}
				print $fout '} ';

				if($mother) {
					print $fout $mother->xref(), ' -> ', $person->xref(), ";\n";
				}
				if($father) {
					print $fout $father->xref(), ' -> ', $person->xref(), ";\n";
				}
				if(scalar(@spouses) == 2) {
					# Married twice, put the person in the middle,
					# it looks better
					# print $fout $person->xref(), ' -> ', $spouses[0]->xref(), " [dir=none];\n";
					print $fout $spouses[0]->xref(), ' -> ',
						$person->xref(), ' -> ',
						$spouses[1]->xref(), " [dir=none];\n";
				} else {
					foreach my $spouse(@spouses) {
						print $fout $person->xref(), ' -> ', $spouse->xref(), " [dir=none];\n";
						# print $fout $person->xref(), ' -> ', $spouse->xref(), " [dir=none];\n";
					}
				}
				foreach my $child(@children) {
					print $fout $person->xref(), ' -> ', $child->xref(), ";\n";
				}

				print $fout '}';
				close $fout;

				my $filename = make_filename_from_object(object => $person);
				my $dim = Image::Info::html_dim(Image::Info::image_info($png));
				print $csv "/img/$filename.png---$dim---";
				print $xml "\n\t\t<profile>/img/$filename.png</profile>";
				$tmp->seek(0, SEEK_SET);
				print $xml "\n\t\t<family_tree>";
				foreach my $line(<$tmp>) {
					chomp $line;
					print $csv $line;
					$line =~ s/</&lt;/g;
					$line =~ s/>/&gt;/g;
					$line =~ s/&/&amp;/g;
					$line =~ s/&amp;amp;/&amp;/g;
					$line =~ s/\xc3\xab/&#235;/g;	# eumlaut
					print $xml $line;
				}
				print $xml '</family_tree>';
			}
		} elsif(defined($dot)) {
			complain(warning => "$dot: $!");
		}
	}
	print $csv '!';

	foreach my $residence(@residencelist) {
		if(my $rdate = $residence->date()) {
			$place_records{'Living ' . year({ person => $person, string => $rdate })} = $residence;
		}
	}

	my @place_events = keys %place_records;
	if($opts{'m'} && ($opts{'l'} || !$is_alive) && (scalar(@place_events) || scalar(@note_locations))) {
		print "Create map\n" if($opts{'v'});
		my $map;
		my $current_place;
		my $annotation;

		# Sort put all events at a place on the same pointer
		# TODO: then sort in date order
		foreach my $event(sort { place({ record => $place_records{$a}, nopreposition => 1 }) cmp place({ record => $place_records{$b}, nopreposition => 1 }) } @place_events ) {
			my $record = $place_records{$event};
			my $place = place({ record => $record, nopreposition => 1 });
			if(defined($place) && ($place =~ /,.+,/)) {
				$place =~ s/^\s+//;
				if(defined($current_place) && ($place ne $current_place)) {
					if(!defined($map)) {
						# my %args = (geocoder => $geocoder, z_index => -1);
						my %args = (geocoder => $geocoder);
						if($javascript_key) {
							$args{'api_key'} = $javascript_key;
						}
						$map = HTML::GoogleMaps::V3->new(%args);
						$map->center($current_place);
					}
					add_marker(person => $person, map => $map, place => HTML::Entities::decode($current_place), annotation => $annotation);
					$current_place = $place;
					$annotation = undef;
				} elsif(!defined($current_place)) {
					$current_place = $place;
				}
				my $text = $event;
				$text =~ s/\/.+//;	# Remove count e.g. when more than one residence
				if($event !~ /^Living /) {	# Already put in above
					if($record->date()) {
						$text .= ' ' . year({ person => $person, record => $record });
					}
				}
				$annotation .= "<p>$text</p>";
			}
		}

		# FIXME: Merge into place_records, rather as was done with residencelist
		foreach my $location(@note_locations) {
			my $match;
			if($location->{'match'}) {
				$match = $location->{'match'};
			} else {
				$match = $location;
			}
			# print Data::Dumper->new([$match])->Dump();
			next if(defined($match->{'confidence'}) && ($match->{'confidence'} < 1.0));
			my $place = $match->{'location'};
			next if(!defined($place));	# The text didn't match a location
			if(defined($current_place) && ($place ne $current_place)) {
				# FIXME: no need to look up again, use $match->longt and lattt
				if(!defined($map)) {
					# my %args = (geocoder => $geocoder, z_index => -1);
					my %args = (geocoder => $geocoder);
					if($javascript_key) {
						$args{'api_key'} = $javascript_key;
					}
					$map = HTML::GoogleMaps::V3->new(%args);
					$map->center($current_place);
				}
				add_marker(person => $person, map => $map, place => HTML::Entities::decode($current_place), annotation => $annotation);
				$current_place = $place;
				$annotation = undef;
			} elsif(!defined($current_place)) {
				$current_place = $place;
			}
			$annotation .= '<p>' . $location->{'text'} . '</p>';
		}
		if($current_place) {
			if(!defined($map)) {
				# my %args = (geocoder => $geocoder, z_index => -1);
				my %args = (geocoder => $geocoder);
				if($javascript_key) {
					$args{'api_key'} = $javascript_key;
				}
				$map = HTML::GoogleMaps::V3->new(%args);
				$map->center($current_place);
			}
			add_marker(person => $person, map => $map, place => HTML::Entities::decode($current_place), annotation => $annotation);
		}
		if(defined($map)) {
			# Can't put $head into the head since it's far too
			# late now!
			my ($head, $map_div) = $map->onload_render();
			$head =~ s/\n\n*/\n/g;
			$head =~ s/http:/https:/;
			# if($opts{'M'}) {
				# # Don't include the key in the webpage.
				# $head =~ s/\?key=\w+?"/"/;
			# }
			print $html "$head<h2>Map</h2>$map_div\n";
			print $csv MIME::Base64::encode_base64url($head), '!', MIME::Base64::encode_base64url($map_div), '!';
			print $xml "\n\t\t<map>\n\t\t\t<head>", MIME::Base64::encode_base64url($head), "</head>\n\t\t\t<body>", MIME::Base64::encode_base64url($map_div), "</body>\n\t\t</map>";
		} else {
			print $csv '!!';
		}
	} else {
		print $csv '!!';
	}

	if($birth_dt && ($opts{'l'} || !$is_alive)) {
		print $csv $birth_dt->strftime('%Y/%m/%d');
		print $xml "\n\t\t<birth>", $birth_dt->strftime('%Y/%m/%d'), '</birth>';
	}
	print $csv '!';
	if($death_dt && ($opts{'l'} || !$is_alive)) {
		print $csv $death_dt->strftime('%Y/%m/%d');
		print $xml "\n\t\t<death>", $death_dt->strftime('%Y/%m/%d'), '</death>';
	}
	print $csv '!';

	my $dt;
	if($ENV{'LANG'}) {
		$dt = DateTime->now(locale => $ENV{'LANG'});
	} else {
		$dt = DateTime->now();
	}
	print $html '<p align="right"><i>',
		'Generated by <a href="https://github.com/nigelhorne/ged2site">ged2site</a>. ',
		'Last updated on ',
		$dt->strftime('%x'),
		# $dt->day(), ' ', $dt->month_name(), ' ', $dt->year(),
		'</i></p>';

	if($birth_dt && ($opts{'l'} || !$is_alive) && $me && ($relationship || ($person eq $me))) {
		print $timeline_xml '<event start="', $birth_dt->year();
		if($birth_dt->month() && $birth_dt->day()) {
			printf $timeline_xml '-%02d', $birth_dt->month();
			if($birth_dt->day()) {
				printf $timeline_xml '-%02d', $birth_dt->day();
			}
		}
		print $timeline_xml '" ';

		if($death_dt) {
			print $timeline_xml 'end="', $death_dt->year();
			if($death_dt->month() && $death_dt->day()) {
				printf $timeline_xml '-%02d', $death_dt->month();
				if($death_dt->day()) {
					printf $timeline_xml '-%02d', $death_dt->day();
				}
			}
			print $timeline_xml '" ';
		}

		my $localfile;
		if($profile_thumbnail) {
			$localfile = "dynamic-site/img/thumb-$profile_thumbnail";
			$localfile =~ s/thumbs\///;
			unless(-r $localfile) {
				if($^O eq 'MSWin32') {
					copy($profile_thumbnail, $localfile);
				} else {
					link($profile_thumbnail, $localfile);
				}
			}
			$localfile =~ s/^dynamic-site\///;
			print $timeline_xml "image=\"/$localfile\" ";
			$profile_thumbnail = $localfile;
		}

		# Don't need citations here, and also some phrases are missing
		# leading to double commas
		$fullbio =~ s/<span class="citation">[\d,]+?<\/span>([\s\.;,])/$1/g;
		$fullbio =~ s/,,/,/g;
		$fullbio =~ s/href="\?page=/href="cgi-bin\/page.fcgi?page=/g;
		my $xref = $person->xref();
		print $timeline_xml 'title="', $person->as_string(), '" ',
			'link="/cgi-bin/page.fcgi?page=people&amp;entry=', $xref, '"',
			'>', HTML::Entities::encode($fullbio),
			"<\/event>\n";

		print $visjs "{\ncontent: '<a href=\"cgi-bin/page.fcgi?page=people&entry=$xref\">",
			$person->as_string(), "</a>',\n",
			'start: \'', $birth_dt->year();

		if($birth_dt->month() && $birth_dt->day()) {
			printf $visjs '-%02d', $birth_dt->month();
			if($birth_dt->day()) {
				printf $visjs '-%02d', $birth_dt->day();
			}
		}
		print $visjs "'";

		if($death_dt) {
			print $visjs ",\nend: '", $death_dt->year();
			if($death_dt->month() && $death_dt->day()) {
				printf $visjs '-%02d', $death_dt->month();
				if($death_dt->day()) {
					printf $visjs '-%02d', $death_dt->day();
				}
			}
			print $visjs "'";
		}

		print $visjs ",\ntitle: '";
		if($profile_thumbnail) {
			print $visjs "<img src=\"/$profile_thumbnail\" alt=\"", $person->as_string(), "\"><p>";
			print $csv $profile_thumbnail;
			print $xml "\n\t\t<thumbnail>$profile_thumbnail</thumbnail>";
		}
		$fullbio =~ s/'/\&#39;/g;
		print $visjs '<h2>', $person->as_string(), "</h2><hr>$fullbio'\n},\n";
	}

	my $m;
	if($opts{'l'} || !$is_alive) {
		foreach my $spouse(@spouses) {
			my $date;
			if(my $rec = $spouse->get_record('fams marriage')) {
				$date = $rec->date();
			} elsif($rec = $spouse->get_record('marriage')) {
				$date = $rec->date();
			}
			if($date && ($date =~ /\d$/)) {
				if(my $marriage_dt = date_to_datetime(date => $date)) {
					if($marriage_dt->month() && $marriage_dt->day()) {
						$m .= '---' if($m);
						$m .= $marriage_dt->strftime('%Y/%m/%d');
					}
				} elsif($date =~ /^\d{3,4}/) {
					$m .= '---' if($m);
					$m .= $date;
				}
			}
		}
	}

	if(defined($m)) {
		print $csv "!$m!$sex!";
		print $xml "\n\t\t<marriage>$m</marriage>\n\t\t<sex>$sex</sex>";
	} else {
		print $csv "!!$sex!";
		print $xml "\n\t\t<sex>$sex</sex>";
	}

	my $birth_country = '';

	if($placeofbirth && ($placeofbirth =~ /(.+[a-z]) USA$/)) {
		complain({ person => $person, warning => "Comma missing before USA in birth location '$placeofbirth'" });
		$placeofbirth = "$1, USA";
		$birth_country = 'United States';
	} elsif($placeofbirth && ($placeofbirth =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'England') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			$birth_country = 'United States';
		} elsif($c eq 'United States of America') {
			$birth_country = 'United States';
		} elsif($c eq 'U.S.A.') {
			$birth_country = 'United States';
		} elsif($c eq 'Scotland') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Isle of Man') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			$birth_country = 'United Kingdom';
		} elsif(($c eq 'Preuen') || ($c eq 'Deutschland')) {	# Prussia
			$birth_country = 'Germany';
		} elsif(($c eq 'Holland') || ($c eq 'The Netherlands')) {
			$birth_country = 'Netherlands';
		} elsif($c eq 'NL') {
			$birth_country = 'Netherlands';
			complain({ person => $person, warning => 'Assuming country of birth is Netherlands' });
		} elsif(($c =~ /[A-Z]{2}/) && ($us->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of birth is USA" });
			$birth_country = 'United States';
			$placeofbirth .= ', USA';
		} elsif($us->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is USA" });
			$birth_country = 'United States';
			$placeofbirth .= ', USA';
		} elsif(($c =~ /[A-Z]{2}/) && ($ca->{code2province}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of birth is Canada" });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif($ca->{province2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Canada" });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif(uc($c) eq 'NFLD') {
			complain({ person => $person, warning => 'Assuming country of birth is Canada' });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif(($c eq 'Norfolk') || ($c eq 'Kent') || ($c eq 'Sussex') || ($c eq 'Northumberland')) {
			$birth_country = 'United Kingdom';
			complain({ person => $person, warning => 'Assuming country of birth is UK' });
		} elsif($c =~ 'England,?\sUK') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Scot') {
			complain({ person => $person, warning => "$c: birth country should be Scotland'" });
			$birth_country = 'United Kingdom';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			$birth_country = $b->code_alpha2();
		} else {
			complain({ person => $person, warning => "Unknown birth country: '$c' in '$placeofbirth'" });
		}
	}

	my $death_country = '';

	if($placeofdeath && ($placeofdeath =~ /(.+[a-z]) USA$/)) {
		complain({ person => $person, warning => "Comma missing before USA in death location '$placeofdeath'" });
		$placeofdeath = "$1, USA";
	} elsif($placeofdeath && ($placeofdeath =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'England') {
			$death_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			$death_country = 'United States';
		# } elsif($c eq 'Texas') {
			$death_country = 'United States';
		} elsif(($c =~ /[A-Z]{2}/) && ($us->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			$death_country = 'United States';
		} elsif($us->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			$death_country = 'United States';
		} elsif($c eq 'United States of America') {
			$death_country = 'United States';
		} elsif($c eq 'U.S.A.') {
			$death_country = 'United States';
		} elsif($c eq 'Scotland') {
			$death_country = 'United Kingdom';
		} elsif($c eq 'Scot') {
			complain({ person => $person, warning => "$c: death country should be Scotland'" });
			$death_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			$death_country = 'United Kingdom';
		} elsif(($c eq 'Norfolk') || ($c eq 'Kent') || ($c eq 'Sussex')) {
			$death_country = 'United Kingdom';
			complain({ person => $person, warning => 'Assuming country of death is UK' });
		} elsif(($c eq 'Nova Scotia') || (uc($c) eq 'NFLD') || ($c eq 'Newfoundland') || ($c eq 'NS')) {
			complain({ person => $person, warning => "Country 'Canada' missing from death record" });
			$death_country = 'Canada';
		} elsif(($c =~ /[A-Z]{2,3}/) && ($ca->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of death is Australia" });
			# $death_country = 'Australia';
		} elsif($ca->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of death is Australia" });
			# $death_country = 'Australia';
		} elsif(($c eq 'Holland') || ($c eq 'The Netherlands')) {
			$death_country = 'Netherlands';
		} elsif($c eq 'Isle of Man') {
			$death_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			$death_country = 'United Kingdom';
		} elsif(($c eq 'Preuen') || ($c eq 'Deutschland')) {	# Prussia
			$death_country = 'Germany';
		} elsif($c =~ /Can\./) {
			complain({ person => $person, warning => 'Assuming country of death is Canada'});
			$death_country = 'Canada';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			$death_country = $b->code_alpha2();
		} else {
			complain({ person => $person, warning => "Unknown death country: '$c' in '$placeofdeath'" });
		}
	}

	# TODO:  use known_locations array

	if($geocoder && ($opts{'l'} || !$is_alive) && ($placeofbirth || $placeofdeath)) {
		print $xml "\n\t\t<locations>";
		if($placeofbirth) {
			if(my @locations = $geocoder->geocode($placeofbirth)) {
				# if(scalar(@locations) > 1) {
					# if($opts{'f'}) {
						# die $person->as_string(), ": Ambiguous birth location $placeofbirth";
					# }
					# red_warning({ person => $person, warning => "Ambiguous birth location $placeofbirth" });
				# } elsif(!defined($locations[0]->{'error'})) {
				print $xml "\n\t\t\t<birth>";
				if($birth_country) {
					print $xml "\n\t\t\t\t<country>$birth_country</country>";
				}
				if(defined($locations[0]->{geometry}{location}{lat}) && !defined($locations[0]->{'error'})) {
					print $csv $locations[0]->{geometry}{location}{lat}, ',',
						$locations[0]->{geometry}{location}{lng};
					print $xml "\n\t\t\t\t<lat>", $locations[0]->{geometry}{location}{lat}, '</lat>',
						"\n\t\t\t\t<long>", $locations[0]->{geometry}{location}{lng}, '</long>';
				}
				print $xml "\n\t\t\t</birth>";
			} else {
				complain({ person => $person, warning => "Unknown birth location $placeofbirth" });
			}
		}
		print $csv '!';
		if($placeofdeath) {
			if(my @locations = $geocoder->geocode($placeofdeath)) {
				# if(scalar(@locations) > 1) {
					# if($opts{'f'}) {
						# die $person->as_string(), ": Ambiguous death location $placeofdeath";
					# }
					# red_warning({ person => $person, warning => "Ambiguous death location $placeofdeath" });
				# } elsif(!defined($locations[0]->{'error'})) {
				print $xml "\n\t\t\t<death>";
				if($death_country) {
					print $xml "\n\t\t\t\t<country>$death_country</country>";
				}
				if(defined($locations[0]->{geometry}{location}{lat}) && !defined($locations[0]->{'error'})) {
					print $csv $locations[0]->{geometry}{location}{lat}, ',',
						$locations[0]->{geometry}{location}{lng};
					print $xml "\n\t\t\t\t<lat>", $locations[0]->{geometry}{location}{lat}, '</lat>',
						"\n\t\t\t\t<long>", $locations[0]->{geometry}{location}{lng}, '</long>';
				}
				print $xml "\n\t\t\t</death>";
			} else {
				complain({ person => $person, warning => "Unknown death location $placeofdeath" });
			}
		}
		print $csv '!';
		if(scalar(@residencelist)) {
			foreach my $residence(@residencelist) {
				print $xml "\n\t\t\t<residence>";
				if(my $rdate = $residence->date()) {
					print $xml "\n\t\t\t\t<date>$rdate</date>";
				}
				if(my $rplace = place({ person => $person, record => $residence, nopreposition => 1, encode => 0 })) {
					$rplace =~ s/^\s+//;
					$rplace =~ s/\xc3\xb1/&#241;/g;	# ntilde
					$rplace =~ s/\s&\s/ &amp; /g;
					print $xml "\n\t\t\t\t<location>$rplace</location>";
				}
				print $xml "\n\t\t\t</residence>";
			}
		}

		print $xml "\n\t\t</locations>";

		my $xref = $person->xref();
		my $military_count = 0;
		foreach my $event(@events) {
			if(my $type = $event->type()) {
				if($type eq 'Military service') {
					if($military_count == 0) {
						print $xml "\n\t\t<military>";
						$all_military{$xref} = ();
					}
					$military_count++;
					my $entry;
					print $xml "\n\t\t\t<entry>";
					if(my $date = year(record => $event)) {
						print $xml "\n\t\t\t\t<date>",
							"\n\t\t\t\t\t$date",
							"\n\t\t\t\t</date>";
						$entry->{'date'} = $date;
					}
					if(my $place = place({ person => $person, record => $event, nopreposition => 1 })) {
						$place =~ s/^\s+//;
						print $xml "\n\t\t\t\t<location>",
							"\n\t\t\t\t\t$place",
							"\n\t\t\t\t</location>";
						$entry->{'place'} = $place;
					}
					if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
						$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
						$notes =~ s/[\s\.]+$//;
						$notes =~ s/<br>/ /g;
						print $xml "\n\t\t\t\t<notes>",
							"\n\t\t\t\t\t$notes",
							"\n\t\t\t\t</notes>";
						$entry->{'notes'} = $notes;
					}
					print $xml "\n\t\t\t</entry>";
					push @{$all_military{$xref}}, $entry;
				}
			}
		}
		if($military_count > 0) {
			print $xml "\n\t\t</military>";
		}

		if(scalar(@occupations)) {
			print $xml "\n\t\t<occupations>";

			foreach my $occupation(@occupations) {
				$occupation =~ s/&/&amp;/g;
				print $xml "\n\t\t\t<occupation>$occupation</occupation>";
				push @{$all_occupations{$occupation}}, $xref;
			}

			print $xml "\n\t\t</occupations>";
		}
	} else {
		print $csv '!!';
	}

	print $csv "$birth_country!$death_country!";

	if($person->{'warnings'}) {
		print "Create warnings\n" if($opts{'v'});
		my $ufinder = URI::Find::Schemeless->new(sub {
			my($uri, $orig_uri) = @_;

			my $u = URI->new($orig_uri);
			if($u && (ref($u) ne 'URI::_generic')) {
				$uri =~ s/:$//;
				return "<a href=\"$uri\">" .
					HTML::Entities::encode($u->host()) .
					'</a>';
			}
			return $orig_uri;
		});
		my @issues = map { my $s = HTML::Entities::decode($_); if($s =~ /<a href="/i) { $s } else { $ufinder->find(\$s); "<p>$s</p>" } } @{$person->{'warnings'}};
		print $html '<h2>Known Issues</h2>';
		print $csv @issues;
		print $xml "\n\t\t<issues>";
		foreach my $issue(@issues) {
			print $html HTML::Entities::encode($issue);
			$issue =~ s/^<p>//;
			$issue =~ s/<\/p>$//;
			$issue = HTML::Entities::encode($issue);
			$issue =~ s/&eacute;/&#233;/g;
			$issue =~ s/&Atilde;&copy;/&#233;/g;	# ACOM bizarre
			$issue =~ s/&Atilde;&laquo;/&#235;/g;	# ACOM bizarre
			print $xml "\n\t\t\t<issue>$issue</issue>";
		}
		print $xml "\n\t\t</issues>";
	}
	print $html '</body></html>';
	close $html;

	$printed{$person->xref()} = 1;

	# Find this person's previous record to put changes into the blog
	my $person_in_last_run;
	my $birth_in_last_run;
	my $marriage_in_last_run;
	my $death_in_last_run;
	if($current_people) {
		foreach my $p($current_people->root()->children('person')) {
			my $entry = $p->first_child('entry');
			next if($entry->first_child()->pcdata() ne $person->xref());
			if($firstname && (my $f = $p->first_child('firstname'))) {
				next if($f->first_child()->pcdata() ne $firstname);
			}
			if($surname && (my $s = $p->first_child('surname'))) {
				next if($s->first_child()->pcdata() ne $surname);
			}
			if($birth_in_last_run = $p->first_child('birth')) {
				$birth_in_last_run = $birth_in_last_run->first_child()->pcdata();
			}
			if($marriage_in_last_run = $p->first_child('marriage')) {
				$marriage_in_last_run = $marriage_in_last_run->first_child()->pcdata();
				if(($marriage_in_last_run =~ /\-\-\-/) || (scalar(@spouses) >= 2)) {
					# Married more than once
					$marriage_in_last_run = undef;
				}
			}
			if($death_in_last_run = $p->first_child('death')) {
				$death_in_last_run = $death_in_last_run->first_child()->pcdata();
			}
			$person_in_last_run = $p;
			last;
		}
	}

	# Add entries to the changes.psv file
	if($opts{'l'} || !$is_alive) {
		if(defined($person_in_last_run)) {
			if($birth_dt) {
				my $b = $birth_dt->strftime('%Y/%m/%d');
				my $change;
				if($birth_in_last_run) {
					if($b ne $birth_in_last_run) {
						$change = "Changed date of birth from $birth_in_last_run to $b";
					}
				} else {
					$change = "Added date of birth as $b";
				}
				if($change) {
					my $p = Class::Simple->new();
					$p->readonly_person($person);
					$p->readonly_change($change);
					push @{$changes{'changes'}}, $p;
				}
			}
			if($marriage_dt) {
				my $m = $marriage_dt->strftime('%Y/%m/%d');
				my $change;
				if($marriage_in_last_run) {
					if($m ne $marriage_in_last_run) {
						$change = "Changed date of marriage from $marriage_in_last_run to $m";
					}
				} else {
					$change = "Added date of marriage as $m";
				}
				if($change) {
					my $p = Class::Simple->new();
					$p->readonly_person($person);
					$p->readonly_change($change);
					push @{$changes{'changes'}}, $p;
				}
			}
			if($death_dt) {
				my $d = $death_dt->strftime('%Y/%m/%d');
				my $change;
				if($death_in_last_run) {
					if($d ne $death_in_last_run) {
						$change = "Changed date of death from $death_in_last_run to $d";
					}
				} else {
					$change = "Added date of death as $d";
				}
				if($change) {
					my $p = Class::Simple->new();
					$p->readonly_person($person);
					$p->readonly_change($change);
					push @{$changes{'changes'}}, $p;
				}
			}
		} else {
			push @{$changes{'added_people'}}, $person;
		}
	}

	print "Done\n" if($opts{'v'});
}

sub Gedcom::Individual::as_string
{
	my $self = shift;
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $name;

	if($args{'use_aka'}) {
		my $n2 = $self->tag_record('NAME', 2);
		if(defined($n2) && (ref($n2) eq 'Gedcom::Record') && defined($n2->type()) && ($n2->type() eq 'AlsoKnownAs') && ($n2->value() ne $self->name())) {
			$name = $n2->value();
		} else {
			return;
		}
	} else {
		$name = $self->name();
	}

	$name =~ s/\///g;

	# FIXME: Correctly handle other names, relies on Lingua::EN::NameParse
	#	too much

	$name = Unicode::Diacritic::Strip::strip_diacritics($name);
	# $name =~ tr//can/;
	# $name =~ s//c/g;
	# $name =~ s//a/g;
	# $name =~ s//n/g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'} // $name_components{'initials_1'};
	my $middle_name = $name_components{'middle_name'};
	my $surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	if($name_components{'non_matching'}) {
		if($name =~ /(\w{2,})\s(\w{2,})\s(\w+)\s(\w{2,})/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			my $rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
			$surname .= $rest;

			# Remove the middle name, since it's come in from the non_matching
			$middle_name = undef;
			delete $args{'middle_names'};
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $has_maiden_name;
	if($args{'nee'}) {
		my $sex = get_value({ person => $self, value => 'sex' });
		if(defined($sex) && ($sex eq 'F')) {
			my @husbands = $self->husband();
			if(my $husband = pop @husbands) {
				$surname = $husband->surname();
				$has_maiden_name = 1;
			} elsif(my $spouse = $self->spouse()) {
				complain({ person => $self, warning => 'married, but no husband relationship' });
				$surname = $spouse->surname();
				$has_maiden_name = 1;
			}
		}
	}

	my $rc;

	if($args{'title'} && $name_components{'title_1'}) {
		$rc = $name_components{'title_1'};
		if($rc) {
			$rc .= ' ';
		}
	}

	if($first_name) {
		$rc .= $first_name;
	} else {
		$rc .= $self->given_names();
	}

	if($args{'middle_names'}) {
		if($middle_name) {
			$rc .= " $middle_name";
		} elsif($name =~ /\s([A-Z])\s.+/) {
			# Just an initial has been given
			$rc .= " $1";
		}
	}

	if($surname) {
		if($rc) {
			$rc .= ' ';
		}
		$rc .= normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	} elsif($args{'print_unknown'}) {
		$rc .= ' UNKNOWN';
	}

	if($has_maiden_name && $self->surname()) {
		$rc .= ' (n&eacute;e ' . normalize_name($self->surname()) . ')';
	}

	if($opts{'w'} && !defined($rc)) {
		complain({ warning => "Can't parse the name of '$name'" });
		$args{'include_years'} = 1;
		$rc = 'Unknown person';
	}

	if($args{'include_years'}) {
		my $dob = dateofbirth($self);

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			if($dob =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yob = "c$1";	# Get the "1951" from "Feb 1951"
				}
				$yob = "c$year";
			} else {
				$yob = $1;
			}
		} else {
			$dob = get_value({ person => $self, value => 'baptism date' });
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = dateofdeath($self);

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			if($dod =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yod = "c$1";	# Get the "1951" from "Feb 1951"
				} else {
					$yod = "c$year";
				}
			} else {
				$yod = $1;
			}
		} else {
			$dod = get_value({ person => $self, value => 'burial date' });
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		$rc .= ' ' if($yob || $yod);

		if($yob) {
			$rc .= "$yob ";
		}

		$rc .= '-' if($yob || $yod);

		if($yod) {
			return "$rc $yod";
		}
	}

	if(!defined($rc)) {
		complain({ warning => [ "Can't determine the name for record ", $self->xref() ] });
		return '';
	}

	$rc =~ tr/"/'/;	# fix issues with Graphviz and others

	return $rc;
}

sub normalize_name
{
	# my $name = shift;

	# my $rc;
	# foreach my $word(split(/-| |'/, lc($name))) {
		# $rc .= '-' if($rc && ($name =~ /-/));
		# $rc .= "'" if($rc && ($name =~ /'/));
		# $rc .= ' ' if($rc && ($name =~ / /));
		# $rc .= ucfirst($word);
	# }

	# return $rc;

	return Lingua::EN::NameCase::nc(shift);
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	my $sex = get_value({ person => $self, value => 'sex' });

	if(defined($sex)) {
		if($sex eq 'F') {
			return 'She';
		}
		if($sex eq 'M') {
			return 'He';
		}
	}
	return 'They';
}

sub Gedcom::Individual::possessive
{
	my $self = shift;

	my $rc = {
		'He' => 'His',
		'She' => 'Her',
		'They' => 'Their',
	};

	return $rc->{$self->pronoun()};
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship {
	my $self = shift;
	my $other = shift;

	die $self->as_string() if($other eq $self);

	if($self->mother() && $other->mother() && $self->father() && $other->father()) {
		my $sex = get_value({ person => $other, value => 'sex' });
		if(($self->mother() eq $other->mother()) && ($self->father() eq $other->father())) {
			return ($sex eq 'M') ? 'brother' : 'sister';
		}
		if(($self->mother() eq $other->mother()) || ($self->father() eq $other->father())) {
			return ($sex eq 'M') ? 'half-brother' : 'half-sister';
		}
	}

	return $self->relationship_down($other) || $self->relationship_up($other);
}

sub Gedcom::Individual::relationship_up
{
	my $self = shift;
	my $other = shift;
	my @ancestors;

	unless(@myancestors) {
		@myancestors = $self->ancestors();
	}
	if($me && ($self eq $me)) {
		unless(@myancestors) {
			@myancestors = $me->ancestors();
		}
		return unless scalar(@myancestors);
		@ancestors = @myancestors;
	} else {
		@ancestors = $self->ancestors();
	}

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	foreach my $person1(@ancestors) {
		die $person1->as_string() if($person1 eq $self);
		if($person1->xref() eq $other->xref()) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title = ($sex eq 'M') ? 'father' : 'mother';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} elsif($steps == 3) {
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	foreach my $person1(@ancestors) {
		foreach my $person2(@ancestors2) {
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# TODO - apparently fixed in Github, awaiting new version on CPAN
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }

			if($person1 eq $person2) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				# die $steps1 if($steps1 > 23);
				return if($steps1 > 23);
				my $steps2 = stepsabove($other, $person2, 0);
				# die $steps2 if($steps2 > 23);
				return if($steps2 > 23);

				# TODO: It would be nice to do this as an algorithm
				my %male_relationships = (
					1 << 24 | 1 => 'brother',
					1 << 24 | 2 => 'nephew',
					1 << 24 | 3 => 'great-nephew',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'uncle',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'third times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				my %female_relationships = (
					1 << 24 | 1 => 'sister',
					1 << 24 | 2 => 'niece',
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'aunt',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'third times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);

				my $rc = ($sex eq 'M') ?
					$male_relationships{($steps1 << 24) | $steps2} :
					$female_relationships{($steps1 << 24) | $steps2};
				if(defined($rc) && ($rc =~ /cousin/)) {
					my $myfather = $self->father();
					my $mymother = $self->mother();
					if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
						if($me && ($self eq $me)) {
							$rc .= " on the father's side";
						} else {
							$rc .= ' on ' .
								lcfirst($self->possessive()) .
								" father's side";
						}
					} elsif($mymother && (stepsabove($mymother, $person2, 0) > 0)) {
						if($me && ($self eq $me)) {
							$rc .= " on the mother's side";
						} else {
							$rc .= ' on ' .
								lcfirst($self->possessive()) .
								" mother's side";
						}
					}
				}
				if(!defined($rc)) {
					# die $other->as_string(), ": $steps1, $steps2";
					complain({ person => $other, warning => "TODO: $steps1, $steps2" });
				}
				return $rc;
			}
		}
	}
}

sub Gedcom::Individual::relationship_down
{
	my $self = shift;
	my $other = shift;
	my @descendents;

	if($me && ($self eq $me)) {
		unless(@mydescendents) {
			@mydescendents = $me->descendents();
		}
		return unless scalar(@mydescendents);
		@descendents = @mydescendents;
	} else {
		@descendents = $self->descendents();
	}

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	# print __LINE__, ': ', $self->as_string(), '/', $other->as_string(), "\n";
	# my $i = 0;
	# while((my @call_details = caller($i++))) {
		# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
	# }
	foreach my $person1(@descendents) {
		# print "\t", $person1->as_string(), "\n";
		die $person1->as_string() if($person1 eq $self);
		if($person1 eq $other) {
			# Direct desendent
			my $steps = stepsabove($other, $self, 0);
			my $title = ($sex eq 'M') ? 'son' : 'daughter';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} elsif($steps == 3) {
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}
}

sub stepsabove
{
	my $person = shift;
	my $target = shift;
	my $count = shift;

	return -1 if($count == -1);

	if($person->xref() eq $target->xref()) {
		return $count;
	}

	my @father = $person->father();
	if(my $father = $father[0]) {
		my $rc = stepsabove($father, $target, $count + 1);
		return $rc if($rc != -1);
	}

	my @mother = $person->mother();
	if(my $mother = $mother[0]) {
		return stepsabove($mother, $target, $count + 1);
	}

	return -1;
}

sub year
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $string = $params{'string'} || $params{'date'};

	if(!defined($string)) {
		$string = $params{'record'};
		return unless($string);

		if(ref($string) eq 'Gedcom::Record') {
			$string = $string->date();
			return unless($string);
		}
	}

	if($string =~ /^\d{3,4}$/) {
		return "in $string";
	}
	if($string =~ /^(Abt|ca?)\.?\s*(.+)/i) {
		my $rc = $2;
		if($opts{'w'}) {
			if(my $must_postdate = $params{'must_postdate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt < $must_postdate)) {
					complain({ person => $params{'person'}, warning => "Something is wrong with the date $string which should be after $must_postdate" });
				}
			}
			if(my $must_predate = $params{'must_predate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt > $must_predate)) {
					complain({ person => $params{'person'}, warning => "Something is wrong with the date $string which should be before $must_predate" });
				}
			}
		}
		if($params{'circa'}) {
			return $params{'circa'} . " $rc";
		}
		return "<i>c.</i> $2";
	}
	if(($string =~ /^bet (.+) and (.+)/i) ||
	   ($string =~ /^Fro?m (.+) to (.+)/i)) {
		my $from = year({ %params, string => $1 });
		my $to = year({ %params, string => $2 });
		$from =~ s/^(in|on|c.) //;
		$to =~ s/^(in|on|c.) //;
		return "from $from to $to";
	}

	if($string =~ /(.+)\s(\d{4})\/\d{2}/) {
		my $year = $2 + 1;
		complain({ person => $params{'person'}, warning => "old-style date ($string) should be in $year" });
		$string = "$1 $year";
	}

	if(($string =~ /^\d/) && ($string !~ /[a-z]$/i)) {
		my $person = $params{'person'};
		if($string =~ /^31 Nov/) {
			complain({ person => $person, warning => "$string is invalid, there are only 30 days in November" });
			return;
		}
		if(my $d = date_parser_cached(date => $string)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if(my $must_postdate = $params{'must_postdate'}) {
				complain({
					person => $person,
					warning => [ "Something is wrong with the date $string which should be after ", $must_postdate->strftime('%x') ],
					# stack_trace => 1,
				}) if($d < $must_postdate);
			}
			if(my $must_predate = $params{'must_predate'}) {
				complain({ person => $person, warning => "Something is wrong with the date $string which should be before " . $must_predate->strftime('%x') }) if($d > $must_predate);
			}
			if($ENV{'LANG'}) {
				$d->set_locale($ENV{'LANG'});
			}
			return 'on ' . $d->strftime('%x');
		}
		if($@) {
			# RT 107354
			chomp $@;
			if($opts{'f'}) {
				if($person) {
					die $person->as_string(), ": $@";
				} else {
					die $@;
				}
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => $@ });
			}
		}
		return "on $string";
	}
	if($string =~ /^bef.? (\d{3,4})/i) {
		return "before $1";
	}
	if($string =~ /^by.? (\d{3,4})/i) {
		return "by $1";
	}
	if($string =~ /^By (\d{3,4})/i) {
		if(my $person = $params{'person'}) {
			complain({ person => $person, warning => "says 'By' instead of 'Bef'" });
		} else {
			complain("says 'By' instead of 'Bef'");
		}
		return "before $1";
	}
	if($string =~ /^aft.? (\d{3,4})/i) {
		return "after $1";
	}

	$string = ucfirst(lc($string));
	if($params{'nopreposition'}) {
		return $string;
	}
	return "in $string";
}

sub place {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	my $address = $params{'address'};

	if(!defined($place)) {
		$place = $params{'record'};
		return unless($place);

		if(ref($place) eq 'Gedcom::Record') {
			my $p = $place;
			$address = $place->address();
			if(ref($address) eq 'Gedcom::Record') {
				$place = getaddress($address);
				$address = undef;
			} else {
				$place = $place->place();
			}
			if(!defined($place)) {
				if(!$params{'allow_empty'}) {
					if(my $date = $p->date()) {
						if($date =~ /^bet\s*(.+)/i) {
							complain({ person => $params{'person'}, warning => "Location for the event between $1 is empty" });
						} else {
							complain({ person => $params{'person'}, warning => "Location for the event on $date is empty" });
						}
					} else {
						complain({ person => $params{'person'}, warning => 'Location is empty' });
					}
				}
				return;
			}
		}
	} elsif(ref($address) eq 'Gedcom::Record') {
		$place = getaddress($address);
		$address = undef;
	}

	if((!defined($address)) &&
	   ($place !~ /USA$/) && ($place !~ /United States$/) &&
	   ($place =~ /(.+),\s*(.+,\s*.+,\s*.+)$/)) {
		$address = $1;
		$place = $2;
	}

	# Google maps (and possibly others) sometimes works better with full names
	if($address) {
		if($address =~ /(.+)\sSt\.?$/) {
			$address = "$1 Street";
		} elsif($address =~ /(.+)\sAve\.?$/) {
			$address = "$1 Avenue";
		} elsif($address =~ /(.+)\sRd\.?$/) {
			$address = "$1 Road";
		}
	}

	my $there = $params{'there'};

	if($there && ($place eq $there)) {
		if($address) {
			if($place =~ /^(.+?),.+,/) {
				if($params{'nopreposition'}) {
					return " $address, $1";
				} else {
					return " at $address, $1";
				}
			}
		} else {
			return ' there';
		}
	}

	# The more consistent the data, the fewer lookups on Geocoders and the smoother the English output
	if($place =~ /(.+?)\s*United States$/i) {
		$place = "$1 USA";
	} elsif($place =~ /States\s*$/) {
		complain({ person => $params{'person'}, warning => "Unexpected text at the end of the place '$place'" });
	}

	if($params{'person'}) {
		validate_place({ person => $params{'person'}, place => $place });
	}

	if($place =~ /^\d/) {
		if(my $places_printed = $params{'places_printed'}) {
			$places_printed->{" at$place"} = 1;
			if($place =~ /(.+),(.+?),(.+?),(.+?),(.+?)$/) {
				if($places_printed->{" in$3,$4,$5"}) {
					$places_printed->{"at $1,$2,$3"} = 1;
					return " at $1,$2,$3";
				}
			}
			if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
				$places_printed->{" in$2,$3,$4"} = 1;
			}
		}
		return " at $place";
	}

	if($place eq 'USA') {
		if($params{'nopreposition'}) {
			return ' USA';
		}
		return ' in the USA';
	}

	if($address) {
		if($params{'nopreposition'}) {
			$place = " $address, $place";
		} else {
			$place = " at $address, $place";
		}
	} elsif($params{'nopreposition'}) {
		$place = " $place";
	} elsif($place =~ /^Isle of /) {
		$place = " on the $place";
	} else {
		$place = " in $place";
	}

	# Only print the town if the location has already been printed
	if(my $places_printed = $params{'places_printed'}) {
		if($places_printed->{$place} && $place =~ /^(.+?),/) {
			return $1;
		}
		if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
			my $str = "$2,$3,$4";
			if($params{'person'}) {
				validate_place({ person => $params{'person'}, place => $place });
			}
			if($places_printed->{" in$str"}) {
				if(($4 eq ' USA') || ($4 eq ' Canada')) {
					return "$1,$3";
				}
				return $address ? "$1,$2" : "$1 in$2";
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2";
			}
			$str = "$3,$4";
			if($places_printed->{" in$str"}) {
				return "$1,$2,$3";
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2,$3";
			}
			$places_printed->{" in$str"} = 1;
			$places_printed->{" in$2,$3,$4"} = 1;
		} elsif($place =~ /(.+),(.+),(.+)$/) {
			if($places_printed->{" in$2,$3"}) {
				# We did place, county, country before, so just
				# return place, county
				return "$1,$2";
			}
			$places_printed->{" in$2,$3"} = 1;
		}
		$places_printed->{$place} = 1;
	}
	if(!defined($params{'encode'})) {
		$params{'encode'} = 1;
	}
	if($params{'encode'}) {
		return HTML::Entities::encode($place);
	}
	return $place;
}

sub getaddress {
	my $address = shift;

	my $rc;

	if(my $city = $address->city()) {
		$rc = $city;
	}
	if(my $state = $address->state()) {
		if($rc) {
			$rc .= ', ';
		}
		$rc .= $state;
	}
	if(my $country = $address->country()) {
		if($rc) {
			$rc .= ', ';
		}
		$rc .= $country;
	}

	return $rc;
}

# paragraph => 1: ignore spacing and put it all into one paragraph
sub notes
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record = $params{'record'};
	my $person = $params{'person'};
	my $paragraph = $params{'paragraph'};
	my @notes = $record->get_record('note');
	my $note_locations = $params{note_locations};
	my $encode = $params{'encode'} // 1;

	# my @deathnotes = get_value({ person => $person, value => 'death note' });
	my $rc = $record->get_value();
	$rc .= '.' if($rc && !scalar(@notes));

	foreach my $note(@notes) {
		if($note) {
			if(ref($note) eq 'Gedcom::Record') {
				$note = $note->full_value();	# Include CONC records
			# } else {
				# complain("Note record is just description ($note), infomation may have been lost");
			}
			$note =~ s/\r//g;
			next if($note =~ /^\s*$/);
			if(!$paragraph) {
				$note =~ s/\n+/; /g;
			}
			$note =~ s/\s\s+/ /g;
			$note =~ s/\s+$//g;
			$note =~ s/\.$//;
			$note =~ s/\xe2\x80\x9c/"/g;	# left quotation
			$note =~ s/\xe2\x80\x9d/"/g;	# right quotation
			$note =~ s/\x80"/"/g;
			$note =~ s/\xe2\x80\x99/\'/g;
			$note =~ s/[\x93\x94]/"/g;
			$note =~ s/[\x91\x92]/'/g;
			$note =~ s/[\xc2\xe2]//g;
			if($paragraph) {
				if($encode) {
					$rc .= '<p>' . HTML::Entities::encode($note) . '.</p>';
				} else {
					$rc .= "<p>$note.</p>";
				}
			} else {
				if($rc) {
					$rc .= ' ';
				}
				if($encode) {
					$rc .= HTML::Entities::encode($note);
				} else {
					$rc .= $note;
				}
				$rc .= '.' if($note !~ /(\.|<\/p>)$/);
			}
		} else {
			complain('Notes field is empty');
		}
	}
	if((!defined($rc)) || (length($rc) == 0)) {
		return;
	}
	$rc =~ s/([\.:]); /$1 /g;

	my @matches;

	if(defined($note_locations)) {
		my $region;

		if($record) {
			$region = $record->place();
		}
		if(!$region && (my $person = $params{'person'})) {
			$region = get_value({ person => $person, value => 'birth place' });
			if(!$region) {
				$region = get_value({ person => $person, value => 'death place' });
			}
		}
		if($region && ($region =~ /^.+,\s([[a-z\s]+)$/i)) {
			if($1 =~ /(England|United Kingdom)/i) {
				$region = 'gb';
			} elsif($1 =~ /(USA|US|United States)/i) {
				$region = 'us';
			} elsif(lc($1) eq 'Canada') {
				$region = 'ca';
			} elsif(lc($1) eq 'Australia') {
				$region = 'au';
			} else {
				$region = undef;
			}
		}

		if($freegeocoder) {
			@matches = $freegeocoder->geocode(scantext => $rc, region => $region);
		} elsif($textgeocoder && ($rc =~ /[\s,]/)) {
			@matches = $textgeocoder->geocode(scantext => $rc, region => $region);
		}

		foreach my $hr(@matches) {
			if(!ref($hr)) {
				next;
			}
			if($hr->{'error'}) {
				if($hr->{'error'}->{'description'} =~ /^We currently throttle/) {
					$textgeocoder = undef;
					last;
				}
				# die "$rc: ", $hr->{'error'}->{'description'};
			} else {
				my $matches = $hr;
				if($matches->{'match'}) {
					$matches = $matches->{'match'};
				}
				if(ref($matches) eq 'ARRAY') {
					my $text;
					if(length($rc) > 15) {
						$text = substr($rc, 0, 24) . '...';
					} else {
						$text = $rc;
					}
					foreach my $match(@{$matches}) {
						# print Data::Dumper->new([$match])->Dump();
						# my $place = $match->{'location'};
						# print "$place\n";
						$match->{'text'} = $text;
						push @{$note_locations}, $match;
					}
				} elsif(ref($matches) eq 'HASH') {
					# my $match = $matches;
					# print Data::Dumper->new([$match])->Dump();
					# my $place = $match->{'location'};
					if(length($rc) > 15) {
						$hr->{'text'} = substr($rc, 0, 24) . '...';
					} else {
						$hr->{'text'} = $rc;
					}
					push @{$note_locations}, $hr;
				}
			}
		}
	}

	if($paragraph) {
		$rc =~ s/\n{2,}/<\/p><p>/g;
	} else {
		$rc =~ s/\s\s+/ /g;
	}
	$rc =~ s/\n/<br>/g;
	$rc =~ s/ $//;
	$rc =~ s/!/\&excl;/g;	# ! is the sep_char

	my $ufinder = URI::Find::Schemeless->new(sub {
		my($uri, $orig_uri) = @_;

		if($orig_uri =~ /(.+):$/) {
			$orig_uri = $1;
		}
		my $u = URI->new($orig_uri);
		if($u && (ref($u) ne 'URI::_generic')) {
			# Some sites give 404 on HEAD but work on GET
			if((!head($orig_uri)) && !get($orig_uri)) {
				complain({ person => $person, warning => "$orig_uri: in notes is not found" });
			}
			$uri =~ s/:$//;
			return "<a href=\"$uri\">" .
				$u->host() .
				'</a>';
		}
		return $orig_uri;
	});

	$ufinder->find(\$rc);

	if($language eq 'English') {
		if($ENV{'LANG'} =~ /^en_US/) {
			return Lingua::EN::ABC::b2a($rc);
		} elsif($ENV{'LANG'} =~ /^en_CA/) {
			return Lingua::EN::ABC::b2c($rc);
		} else {
			return Lingua::EN::ABC::a2b($rc);
		}
	}
	return $rc;
}

sub validate_place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	if(!$place) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'place is not optional';
	}

	$place =~ s/^\s+//;
	$place =~ s/^at\s+//;
	if(defined($places{$place})) {
		return $places{$place};
	}

	# US and Canada are more logical, using city,county,state,country, than other countries
	if($opts{'w'} && (($place !~ /,.*,.*,.*/) || ($place =~ /USA|Canada/i))) {
		if($place =~ /(.*),\s*Independent Cities\s*(.*)/i) {
			$place = "$1$2";
		}
		$place =~ s/^(in|at)\s//;
		if(defined($places{$place})) {
			return $places{$place};
		}
		# my $ap;
		# my $p = $place;
		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# $ap = Lingua::EN::AddressParse->new(country => 'US', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
		# } elsif($place =~ /England$/) {
			# $ap = Lingua::EN::AddressParse->new(country => 'GB', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
			# $p .= ', United Kingdom';
		# }
		# if($ap) {
			# my $error = $ap->parse("$address, $p");
			# print $ap->report();
		# }

		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# if(my $href = Geo::StreetAddress::US->parse_location($place)) {
				# if($href->{'state'} && !$us->{code2state}{$href->{'state'}} && !$us->{state2code}{$href->{'state'}) {
				# die $href->{'state'};
					# complain({ person => $params{'person'}, warning => "Unknown state in $place" });
				# }
			# }
		# }
		if((($place =~ /USA$/) || ($place =~ /United States$/) || ($place =~ /U\.S\.A\./)) &&
		    ($place =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
			my $state = uc($1);
			if((!$us->{code2state}{$state}) && !$us->{state2code}{$state}) {
				complain({ person => $params{'person'}, warning => "Unknown state '$state' in $place" });
			} elsif($place =~ /\sWard \d+,/) {
				complain({ person => $params{'person'}, warning => "Census ward number left in location '$place'" });
			}
		}

		print "Look up location $place\n", if($opts{'v'});
		if($opts{'w'}) {
			# Strange locations in censuses
			if($place =~ /Royal Navy/) {
				return 0;
			}
			# Force wantarray for improved caching in
			# G:C:L
			if(($place eq 'England') || ($place eq 'Scotland')) {
				$place = 'United Kingdom';
			} elsif($place eq 'U.S.A.') {
				$place = 'USA';
			}
			my @locations = $geocoder->geocode($place);
			if(scalar(@locations) == 0) {
				# Don't die because there are many
				# false positives as locations
				# may no longer exist
				if(my $person = $params{'person'}) {
					warn colored($person->as_string({ include_years => 1 }) . ": unknown location $place", 'red');
				} else {
					warn colored("Unknown location $place", 'red');
				}
				$places{$place} = 0;
				return 0;
			} elsif(($place !~ /,/) && (!country2code($place))) {
				if(my $person = $params{'person'}) {
					complain({ person => $person, warning => "Country not included in country, or misspelt country '$place'" });
				} else {
					complain("Country not included in country, or misspelt country '$place'");
				}
				$places{$place} = 0;
				return 0;
			}
		}
	}
	$places{$place} = 1;
	return 1;
}

sub person_line_html
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	if($opts{'l'} || !is_alive(%params)) {
		if(my $dob = dateofbirth($person)) {
			return '<a href="' . make_filename_from_person(person => $person) . '">' .
				$person->given_names() .
				'</a> was born ' .
				year({ person => $person, date => $dob });
		} elsif(get_value({ person => $person, value => 'baptism date' })) {
			return '<a href="' . make_filename_from_person(person => $person) . '">' .
				$person->given_names() .
				'</a> was born c. ' .
				get_value({ person => $person, value => 'baptism date' });
		}
		return '';
	}
	return '<a href="' . make_filename_from_person(person => $person) . '">' .
		$person->given_names() .
		'</a>';
}

sub person_line_csv
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	if($opts{'l'} || !is_alive(%params)) {
		if(my $dob = dateofbirth($person)) {
			return '<a href="?page=people&entry=' . $person->xref() . '">' .
				$person->given_names() .
				'</a> was born ' .
				year({ person => $person, date => $dob });
		} elsif(get_value({ person => $person, value => 'baptism date' })) {
			return '<a href="?page=people&entry=' . $person->xref() . '">' .
				$person->given_names() .
				'</a> was born c. ' .
				get_value({ person => $person, value => 'baptism date' });
		}
		return '';
	}
	return '<a href="?page=people&entry=' . $person->xref() . '">' .
		$person->given_names() .
		'</a>';
}

sub places_are_the_same
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record1 = $params{'first'};
	my $record2 = $params{'second'};

	die 'first is not optional' unless $record1;
	die 'second is not optional' unless $record2;

	my $place1 = $record1->place();
	return 0 unless(defined($place1));
	my $place2 = $record2->place();
	return 0 unless(defined($place2));

	my $person = $params{'person'};
	if($person) {
		validate_place({ person => $person, place => $place1 });
		validate_place({ person => $person, place => $place2 }) unless($place1 eq $place2);
	}

	if($place1 =~ /(.+?)\s*United States$/i) {
		$place1 = "$1 USA";
	}
	if(my $address = $record1->address()) {
		$place1 = "$address, $place1";
	}
	if(my $address = $record2->address()) {
		$place2 = "$address, $place2";
	}
	if($place2 =~ /(.+?)\s*United States$/i) {
		if($person) {
			complain({ person => $person, warning => "Changing 'United States' to 'USA' in $place2" });
		} else {
			complain("Changing 'United States' to 'USA' in $place2");
		}
		$place2 = "$1 USA";
	}
	if($place2 =~ /(.+)\sSt\.?$/) {
		if($person) {
			complain({ person => $person, warning => "Changing 'St' to 'Street' in $place2" });
		} else {
			complain("Changing 'St' to 'Street' in $place2");
		}
		$place2 = "$1 Street";
	} elsif($place2 =~ /(.+)\sAve\.?$/) {
		if($person) {
			complain({ person => $person, warning => "Changing 'Ave' to 'Avenue' in $place2" });
		} else {
			complain("Changing 'Ave' to 'Avenue' in $place2");
		}
		$place2 = "$1 Avenue";
	} elsif($place2 =~ /(.+)\sRd\.?$/) {
		if($person) {
			complain({ person => $person, warning => "Changing 'Rd' to 'Road' in $place2" });
		} else {
			complain("Changing 'Rd' to 'Road' in $place2");
		}
		$place2 = "$1 Road";
	}
	return 1 if($place1 eq $place2);
	if(compare($place1, $place2) > 0.5) {
		if($person) {
			complain({ $person => $person, warning => "The places '$place1' and '$place2' seem similar; is there a typo?" });
		} else {
			complain("The places '$place1' and '$place2' seem similar; is there a typo?");
		}
	}
	return 0;
}

sub sibling_baptism_string
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $siblings = $params{'siblings'};
	my $date = $params{'date'};
	my $birthdate = $params{'birthdate'};

	return '' if(scalar(@{$siblings}) == 0);

	my @onsameday;
	foreach my $sibling(@{$siblings}) {
		my $dateofsiblingbaptism = get_value({ person => $sibling, value => 'baptism date' });
		if($dateofsiblingbaptism && ($dateofsiblingbaptism eq $date)) {
			push @onsameday, $sibling;
		}
	}
	my $allsamesex = 1;
	if(scalar(@onsameday) > 1) {
		foreach my $sibling(@onsameday) {
			if($sibling->sex() ne $person->sex()) {
				$allsamesex = 0;
				last;
			}
		}
		if($allsamesex) {
			foreach my $sibling(@onsameday) {
				my $dateofsiblingbirth = dateofbirth($sibling);
				if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
					$allsamesex = 0;	# Fudge to force special twin handler
				}
			}
		}
	} else {
		$allsamesex = 0;
	}

	if($allsamesex) {
		return ', the same day as ' . lcfirst($person->possessive()) . ' ' .
			($onsameday[0]->sex() eq 'M' ? 'brothers ' : 'sisters ') .
			Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @onsameday), {final_sep => ''});
	}
	my $count = 0;
	my $rc = '';
	foreach my $sibling(@onsameday) {
		if($count == 0) {
			$rc = ', the same day as ';
		} elsif($count < (scalar(@onsameday) - 1)) {
			$rc .= ', ';
		} elsif($count == (scalar(@onsameday) - 1)) {
			$rc .= ' and ';
		}
		$rc .= lcfirst($person->possessive()) . ' ';
		my $dateofsiblingbirth = dateofbirth($sibling);
		if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
			$rc .= 'twin ';
		}
		$rc .= ($sibling->sex() eq 'M' ? 'brother ' : 'sister ') .
			$sibling->given_names();
		$count++;
	}
	return $rc;
}

sub complain
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'warning'} = shift;
	}

	if(!defined($params{'warning'})) {
		my @call_details = caller(0);
		die "What do you want to say on line $call_details[2]?";
	}

	# Support warning being a ref to an array
	if(ref($params{'warning'}) eq 'ARRAY') {
		$params{'warning'} = join('', @{$params{'warning'}});
	}
	if($opts{'f'}) {
		my @call_details = caller(0);
		if($params{'person'}) {
			die $params{'person'}->as_string(), ': ', ucfirst($params{'warning'}), ' at line ', $call_details[2];
		}
		die ucfirst($params{'warning'}), ' at line ', $call_details[2];
	}

	if($opts{'w'}) {
		$params{'caller'} = 1;
		red_warning(%params);
	}
}

sub red_warning
{
	if($opts{'w'}) {
		my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

		die "What do you want to say?" unless($params{'warning'});

		my $warning = HTML::Entities::decode($params{'warning'});
		my @call_details = caller($params{'caller'} || 0);
		if($params{'person'}) {
			warn colored(['red'], $params{'person'}->as_string(middle_names => 1), ": $warning at line ", $call_details[2]);
			push @{$params{'person'}->{'warnings'}}, $warning;
		} else {
			if($opts{'W'}) {
				print STDERR $params{'warning'}, "\n";
			} else {
				warn colored(['red'], $params{'warning'}, ' at line ', $call_details[2]);
			}
		}
		if($params{'stack_trace'}) {
			my $i = 0;
			while((my @call_details = (caller($i++)))) {
				print STDERR "\t", colored($call_details[1] . ':' . $call_details[2] . ' calling function ' . $call_details[3], 'red'), "\n";
			}
		}
	}
}

# Cache gedcom values
sub get_value
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# if($fetcher) {
		# my $args = {
			# object => $params{'person'},
			# message => 'get_value',
			# arg => $params{'value'}
		# };

		# # Doesn't use the prefetching feature, but will automatically cache which is nice
		# # $fetcher->prime($args);
		# return $fetcher->get($args);
	# }
	my $person = $params{'person'};
	if(!defined($person)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: person argument is mandatory';
	}
	return $params{'person'}->get_value($params{'value'});
}

sub get_source
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# my $args = {
		# object => $params{'gedcom'},
		# message => 'get_source',
		# arg => $params{'source'}
	# };

	# # Doesn't use the prefetching feature, but will automatically cache which is nice
	# # $fetcher->prime($args);
	# return $fetcher->get($args);
	if(ref($params{'source'})) {
		if($params{'source'}->title()) {
			return $params{'source'};
		}
		return;
	}
	return $params{'gedcom'}->get_source($params{'source'});
}

# Inspired by Tree::Family.  That module doesn't quite do what I want, so
# I've mercilessly re-used the ideas of what to do from it.
sub print_graphviz
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $colour = $params{'colour'};
	my $profile_image = $params{'profile_image'};

	if(!defined($colour)) {
		my $gender = get_value({ person => $person, value => 'sex' }) || $person->sex();
		if(defined($gender)) {
			$gender = $gender;
		} else {
			complain({ person => $person, warning => 'unknown sex' });
			$gender = 'M';	# Avoid "Use of uninitialized value" in Tree::Family
		}
		$colour = ($gender eq 'M' ? '#093AB5' : '#C666B8');
	}

	print $fout $person->xref(), ' [shape=box,fontsize="10",',
		"color=\"$colour\",";

	if($params{'format'} eq 'dynamic') {
		print $fout 'href="?page=people&entry=', $person->xref(), '",';
	} else {
		print $fout 'href="', make_filename_from_person(person => $person), '",';
	}

	my $label = $person->as_string();
	my $dob = dateofbirth($person);
	my $dod = dateofdeath($person);

	my $thumbnail;

	# If you get 'Warning: No loadimage plugin for "jpeg:cairo"', do this
	# instead:
	# if(0) {
	if($profile_image && (defined($dod) || $opts{'l'})) {
		if(!-r $profile_image) {
			die $person->as_string(), ": can't read $profile_image";
		}
		if(defined($dob)) {
			$dob .= "<TR><TD>b. $dob</TD></TR>";
		} else {
			$dob = '';
		}
		if(defined($dod)) {
			$dod .= "<TR><TD>d. $dod</TD></TR>";
		} else {
			$dod = '';
		}
		# Create a thumbnail
		my $image = Image::Magick->new();
		$image->read($profile_image);
		my ($thumb, $x, $y) = Image::Magick::Thumbnail::create($image, 100);
		my @thumbname = File::Basename::fileparse($profile_image);
		# use PNG to try to avoid
		#	'Warning: No loadimage plugin for "jpeg:cairo"'
		$thumbname[0] =~ s/\.jpg$/.png/i;
		$thumbnail = "thumbs/$thumbname[0]";
		$thumb->Write($thumbnail);

		# FIXME: TABLE isn't supported by Graphviz
		print $fout "label=<<TABLE border=\"0\" cellborder=\"0\"><TR><TD><IMG SRC=\"thumbs/$thumbname[0]\" scale=\"true\"/></TD></TR><TR><TD>$label</TD></TR>$dob$dod</TABLE>>",
			",labelloc=b";

		# print $fout ",image=\"$profile_image\",labelloc=b";

		chmod 0444, $thumbnail;
	} elsif(defined($dod) || $opts{'l'}) {
		if(defined($dob)) {
			$label .= "\\nb. $dob";
		}
		if(defined($dod)) {
			$label .= "\\nd. $dod";
		}
		print $fout "label=\"$label\"";
	} else {
		print $fout "label=\"$label\"";
	}

	print $fout "];\n";

	return $thumbnail;
}

sub is_alive
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	if($person->get_record('death') || dateofdeath($person)) {
		return 0;
	}
	if($person->get_record('burial')) {
		return 0;
	}
	my $dob = dateofbirth($person);

	if(!defined($dob)) {
		return 0;	# Err on the side of caution
				# TODO: Look at children's lifespan for a clue
	}

	my $year = (localtime)[5];
	$year += 1900 if($year < 1900);

	if(($dob =~ /^\d{3,4}$/) && ($dob < ($year - 100))) {
		return 0;
	}
	if($dob =~ /^abt (\d{4})$/i) {
		$dob = $1;
	}
	if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
		if(my $d = date_parser_cached(date => $dob)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($d->strftime('%Y') < ($year - 120)) {
				return 0;
			}
		}
	}
	return 1;
}

sub make_filename_from_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	die if(!defined($person));

	my $rc = $person->as_string(include_years => 1);
	$rc =~ tr/ /-/s;
	$rc =~ tr/ /-/s;
	$rc =~ tr/"/'/s;
	$rc =~ tr/\//-/s;
	$rc =~ s/--+/-/g;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	return "$rc.html";
}

sub make_filename_from_object
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $object = $params{'object'};

	my $rc = $object->title();
	if(!$rc) {
		return $object->xref();
	}
	$rc =~ tr/ /-/s;
	$rc =~ tr/'/-/s;
	$rc =~ tr/\//-/s;
	$rc =~ s/--+/-/g;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	return $rc;
}

# Parse Gedcom format dates
# Genealogy::Gedcom::Date is expensive, so cache results
sub date_parser_cached
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	my $date = $params{'date'};

	if($date =~ /^([A-Z]{3})\s+(\d{1,2}),\s+(\d{3,4})$/i) {
		complain(warning => "Changing US format date '$date' to Gedcom format '$2 $1 $3'");
		$date = "$2 $1 $3";
	}

	if($all_dates{$date}) {
		print "$date is already known\n" if($opts{'v'});
		return $all_dates{$date};
	}
	if($date !~ /\d$/) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: illegal date should have been trapped by now';
	}
	print "Parse date $date\n" if($opts{'v'});
	my $d;
	eval {
		$d = $date_parser->parse(date => $date);
	};
	if($d && (ref($d) eq 'ARRAY')) {
		$d = @{$d}[0];
		$all_dates{$date} = $d;
	}
	return $d;
}

# Try hard to convert a Gedcom date to a DateTime object.
# If a date range is given, return a two element array in array context, or undef in scalar context
sub date_to_datetime
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	if(my $date = $params{'date'}) {
		if($date =~ /^\s*(\d{3,4})\s*\-\s*(\d{3,4})\s*$/) {
			complain("Changing date '$date' to 'bet $1 and $2'");
			$date = "bet $1 and $2";
		}
		if($date =~ /^bet (.+) and (.+)/i) {
			if(wantarray) {
				my $rc0 = date_to_datetime($1);
				my $rc1 = date_to_datetime($2);
				if($rc0 < $rc1) {
					return ($rc0, $rc1);
				}
				complain("Invalid date range $date");
			}
			return;
		}
		if($date !~ /^\d{3,4}$/) {
			if($date =~ /[A-Z]{4}/i) {
				complain(warning => "Unparseable date $date - often because the month name isn't 3 letters");
				return;
			}
			if(($date =~ /^\d/) && (my $d = date_parser_cached($date))) {
				return $dfn->parse_datetime($d->{'canonical'});
			}
			if(($date !~ /^(Abt|ca?)/i) && ($date =~ /^[\w\s]+$/)) {
				# ACOM exports full month names and non-standard format dates e.g. U.S. format MMM, DD YYYY
				if(my $rc = $dfn->parse_datetime($date)) {
					return $rc;
				}
				complain(warning => "Can't parse date '$date'");
			}
		}
	}
	undef;
}

sub add_marker
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $map = $params{'map'};
	my $place = $params{'place'};

	$place =~ s/\s\s+/ /g;
	if($place =~ /\d/) {	# We have the address, so no need to include the name of the building in the search
		# FIXME: changes Silver Spring, MD 20910, USA to 20910, USA
		$place =~ s/^\D+(.+)/$1/;
	}

	$place =~ s/'//g;
	$place =~ s/&quot;//g;
	$place =~ s/ & / and /g;

	# OSM isn't that clever with fuzzy matching
	while(my($key, $value) = each %location_mappings) {
		if($place =~ /(.*)$key(.*)/) {
			$place = "$1$value$2";
			last;
		}
	}

	if(my $annotation = $params{'annotation'}) {
		if($map->add_marker(point => $place, html => "$place<br>$annotation")) {
			return;
		}
		red_warning({ person => $person, warning => "$place isn't found", stack_trace => 1 });
		if($place =~ /,?(.+?),(.+?),(.+?),(.+?)$/) {
			$place = "$1, $2, $3, $4";
			if($map->add_marker(point => $place, html => "$place<br>$annotation")) {
				return;
			}
			$place = "$2, $3, $4";
			$place =~ s/^\s+//;
			$map->add_marker(point => $place, html => "$place<br>$annotation");
		}
	} else {
		if($map->add_marker(point => $place, html => $place)) {
			return;
		}
		red_warning({ person => $person, warning => "$place isn't found", stack_trace => 1 });
		if($place =~ /,?(.+?),(.+?),(.+?),(.+?)$/) {
			$place = "$1, $2, $3, $4";
			if($map->add_marker(point => $place, html => $place)) {
				return;
			}
			$place = "$2, $3, $4";
			$map->add_marker(point => $place, html => $place);
		}
	}
}

sub cite
{
	# my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif((scalar(@_) % 2 == 0) && defined($_[0]) && ($_[0] !~ /^\d+$/)) {
		%params = @_;
	} else {
		$params{'citations'} = \@_;
	}

	return '' unless($params{'citations'});
	my @citations = @{$params{'citations'}};
	return '' unless($citations[0]);
	return '' unless(scalar(@citations));

	return '<span class="citation">' . join(',', List::Util::uniq(sort { $a <=> $b } (@citations))) . '</span>';
}

sub get_all_residences
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	die "Usage: get_all_residences(\$person')" unless($person);

	my @residences = $person->residence();
	my @rc;
	my $index = 0;
	foreach my $residence(@residences) {
		$index++;
		if(!ref($residence)) {
			my $r = $person->tag_record('RESI', $index);
			if(ref($r) eq 'Gedcom::Record') {
				$residence = $r;
			}
		}
		if(ref($residence) eq 'Gedcom::Record') {
			push @rc, $residence;
		}
	}
	my @events = $person->event();
	$index = 0;
	foreach my $event(@events) {
		$index++;
		if(!ref($event)) {
			my $e = $person->tag_record('EVEN', $index);
			if(ref($e) eq 'Gedcom::Record') {
				$event = $e;
			}
		}
		next if(ref($event) ne 'Gedcom::Record');
		my $type = $event->type();
		next if(!defined($type));
		# if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation')) {
		if(($type =~ /Census/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation') || ($type eq 'Story')) {
			push @rc, $event;
		}
	}
	my @censuses = $person->census();
	$index = 0;
	foreach my $census(@censuses) {
		$index++;
		if(!ref($census)) {
			my $c = $person->tag_record('CENS', $index);
			if(ref($c) eq 'Gedcom::Record') {
				$census = $c;
			}
		}
		if(ref($census) eq 'Gedcom::Record') {
			push @rc, $census;
		}
	}

	return @rc;
}

sub get_all_occupations
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	die "Usage: get_all_occupations(\$person')" unless($person);

	my @occupations = get_value({ person => $person, value => 'occupation' });

	if((scalar(@occupations) == 1) && !defined($occupations[0])) {
		return;
	}

	while($occupations[0] && ($occupations[0] =~ /^scho(ol|lar)/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /wife$/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /unemployed/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /Unpaid domestic duties/i)) {
		shift @occupations;
	}
	# TODO: sortout case
	if(scalar(@occupations)) {
		if($occupations[0] =~ /works? on (.+)/i) {
			$occupations[0] = "$1 worker";
		} elsif(($occupations[0] eq 'Ag Lab') ||
			($occupations[0] eq 'Ag Labourer') ||
			($occupations[0] eq 'Ag Labourer Pauper') ||
			($occupations[0] eq 'Farm Labourer') ||
			($occupations[0] eq 'Agricultural Farm Labourer') ||
			($occupations[0] eq 'Ordinary Agricultural Labourer') ||
			($occupations[0] eq 'work on farm') ||
			($occupations[0] eq 'Labourer (Ag)')) {
			$occupations[0] = 'Agricultural Labourer';
		} elsif($occupations[0] eq 'Poultry Farming') {
			$occupations[0] = 'Poultry Farmer';
		} elsif($occupations[0] eq 'Platelayer Railway') {
			$occupations[0] = 'Railway Platelayer';
		} elsif($occupations[0] eq 'General Servant Domestic') {
			$occupations[0] = 'Domestic Servant';
		} elsif($occupations[0] eq 'Lorry Driver Heavy Worker') {
			$occupations[0] = 'Lorry Driver';
		} elsif($occupations[0] =~ /^Shop Assistant (.*)/) {
			$occupations[0] = "$1's Shop Assistant";
		} elsif($occupations[0] =~ /(.*) Assistant$/i) {
			$occupations[0] = "$1's Assistant" unless($1 =~ /'s$/);
		} elsif($occupations[0] =~ /Clerk (.*)/) {
			$occupations[0] = "$1 Clerk";
		} elsif($occupations[0] =~ /Salesman (.*)/i) {
			$occupations[0] = "$1 Salesman";
		} elsif($occupations[0] =~ /Foreman (.*)/i) {
			$occupations[0] = "$1 Foreman";
			$occupations[0] =~ s/^of the //i;
		} elsif($occupations[0] =~ /Labourer Gas Stoker/) {
			$occupations[0] = 'Gas Stoker';
		} elsif($occupations[0] eq 'Under Gardener Domestic') {
			$occupations[0] = 'Domestic Gardener';
		} elsif($occupations[0] eq 'Domestic servant') {
			$occupations[0] = 'Domestic Servant';
		} elsif($occupations[0] eq 'Market gardener') {
			$occupations[0] = 'Market Gardener';
		} elsif($occupations[0] eq "Brewer's Labourer") {
			$occupations[0] = 'Brewery Labourer';
		} elsif($occupations[0] eq 'Gardener domestic') {
			$occupations[0] = 'Gardener and Domestic';
		} elsif($occupations[0] =~ /^General serv.+dom/) {
			$occupations[0] = 'Domestic General Server';
		} elsif($occupations[0] eq 'Plate Glass Cutter') {
		} elsif($occupations[0] =~ /(.+)([a-z])s\s+([a-z]+)$/i) {
			# Don't change Bus Driver to Bu's Driver
			$occupations[0] = "$1$2's $3" unless(("$1$2" eq 'Bu') || ("$1$2" eq 'Harnes'));
		}
	}
	while(scalar(@occupations) > 1) {
		if(($occupations[0] =~ /^labou?rer/i) && ($occupations[1] =~ /^labou?rer/i)) {
			shift @occupations;
		} elsif(lc($occupations[0]) eq lc($occupations[1])) {
			shift @occupations;
		} else {
			last;
		}
	}

	if(scalar(@occupations)) {
		if($occupations[0]) {
			if($language eq 'English') {
				if($ENV{'LANG'} =~ /^en_US/) {
					$occupations[0] = Lingua::EN::ABC::b2a(lc($occupations[0]));
				} elsif($ENV{'LANG'} =~ /^en_CA/) {
					$occupations[0] = Lingua::EN::ABC::b2c(lc($occupations[0]));
				} else {
					$occupations[0] = Lingua::EN::ABC::a2b(lc($occupations[0]));
				}
			} elsif(($language eq 'French') && ($occupations[0] eq 'Postman')) {
				$occupations[0] = (($person->sex() eq 'M') ? 'Facteur' : 'Factrisse');
			}
			$occupations[0] =~ s/[\(\)]//g;
			$occupations[0] =~ s/\s+Own Account//i;
			if($occupations[0] =~ /works? (on|for) (.+)/i) {
				$occupations[0] = "$1 Worker";
			} elsif($occupations[0] =~ /^Cleaner\s+(.+)/i) {
				$occupations[0] = "$1 Cleaner";
			} else {
				$occupations[0] = ucfirst($occupations[0]);
			}
		} else {
			complain({
				person => $person,
				warning => 'Occupation is empty'
			});
			shift @occupations;
		}
	}

	return @occupations;
}

# Document a complete journey when both a departure and an arrival record exist
sub journey
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $arrival = $params{'arrival'};
	my $departure = $params{'departure'};

	my $rc;
	my $yod;
	my $yoa;
	my $dod = $departure->date();
	my $doa = $arrival->date();
	my $only_have_departure_year;

	if($doa && ($doa =~ /(\d{3,4})/)) {
		$yoa = $1;
		$doa =~ s/\s?\d{3,4}//;
		if($dod && ($dod =~ /(\d{3,4})/)) {
			$yod = $1;
			$dod =~ s/\s?\d{3,4}//;
			if($dod =~ /^\d/) {
				$dod = "on $dod";
			} else {
				$dod = "during $yod";
				$only_have_departure_year = 1;
			}
			if($doa =~ /^\d/) {
				$doa = "on $doa";
			} elsif($yoa == $yod) {
				$doa = 'later that same year';
			} else {
				$doa = "during $yoa";
			}
		}
	}
	$rc = $person->pronoun();
	if($language eq 'French') {
		$rc = ($rc eq 'He') ? 'Il' : 'Elle';
	}
	if($yoa || $yod) {
		my $year = $yoa // $yod;
		if($language eq 'French') {
			$rc = " En $year " . lc($rc);
		} else {
			$rc = " In $year " . lc($rc);
		}
	# } else {
		# $yod = year({ person => $person, record => $departure });
		# $yoa = year({ person => $person, record => $arrival });
	}

	if($language eq 'French') {
		$rc .= ' a voyag';
	} elsif($ENV{'LANG'} =~ /^en_US/) {
		$rc .= ' traveled';
	} else {
		$rc .= ' travelled';
	}

	if(defined($departure->place())) {
		$rc .= (($language eq 'French') ? ' de' : ' from') . place({ person => $person, record => $departure, nopreposition => 1 });
		if(my $notes = notes(record => $departure)) {
			$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
			$notes =~ s/\.$//;
			$rc .= " ($notes)";
		}
	} else {
		complain({ person => $person, warning => 'Departure record has no location' });
	}
	if(defined($arrival->place())) {
		$rc .= (($language eq 'French') ? ' ' : ' to') . place({ person => $person, record => $arrival, nopreposition => 1 });
		if(my $notes = notes(record => $arrival)) {
			$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
			$notes =~ s/\.$//;
			$rc .= " ($notes)";
		}
	} else {
		complain({ person => $person, warning => 'Arrival record has no location' });
	}

	if(defined($dod) && !$only_have_departure_year) {
		return "$rc, departing $dod and";
	}

	return "$rc arriving $doa";
}

# Compare two dates. Approximate dates are compared.
# TODO: handle when only months are known
sub datecmp
{
	my ($left, $right) = @_;

	if((!defined($left)) || !defined($right)) {
		if(!defined($left)) {
			print STDERR "BUG: left not defined\n";
		}
		if(!defined($right)) {
			print STDERR "BUG: right not defined\n";
		}
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		return 0;
	}
	if(!ref($left)) {
		if($left =~ /^(Abt|ca?)\s+(.+)/i) {
			$left = $2;
		}
		if($left !~ /^\d{3,4}$/) {
			my @l = $dfg->parse_datetime($left);
			my $rc = $l[1] || $l[0];
			if(!defined($rc)) {
				print STDERR "Date parse failure: ($left):\n";
				my $i = 0;
				while((my @call_details = caller($i++))) {
					print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
				}
				return 0;
			}
			$left = $rc;
		}
	}
	if(!ref($right)) {
		if($right =~ /^(Abt|ca?)\s+(.+)/i) {
			$right = $2;
		}
		if($right =~ /^\d{3,4}$/) {
			if(ref($left)) {
				return $left->year() <=> $right;
			} else {
				return $left <=> $right;
			}
		}
		# if(!$dfg->parse_datetime($right)) {
			# my $i = 0;
			# while((my @call_details = caller($i++))) {
				# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			# }
			# die join('<=>', @_);
		# }
		my @r = $dfg->parse_datetime($right);
		$right = $r[0];
	}
	if((!ref($left)) && ref($right)) {
		return $left <=> $right->year();
	}
	if(ref($left) && (!ref($right))) {
		return $left->year() <=> $right;
	}

	return $left <=> $right;
}

sub chronicling_america
{
	my ($person, $chronicling_params) = @_;

	return unless($opts{'w'});

	if(!defined($chronicling_params->{'firstname'})) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die $person->as_string(), ': BUG: no first name given';
	}
	if(length($chronicling_params->{'state'}) <= 2) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die $person->as_string(), ': BUG: state "', $chronicling_params->{'state'}, '" too short';
	}

	if(my $loc = Genealogy::ChroniclingAmerica->new($chronicling_params)) {
		while(my $url = $loc->get_next_entry()) {
			if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^fr/)) {
				complain({ person => $person, warning => "Visitez $url" });
			} else {
				complain({ person => $person, warning => "Check out $url" });
			}
		}
	}
}

sub HTML::GoogleMaps::V3::_text_to_point {
    my ( $self,$point_text ) = @_;

    # IE, already a long/lat pair
	return [ reverse @$point_text ] if ref( $point_text ) eq 'ARRAY';

    if ( my @loc = $self->{geocoder}->geocode( location => $point_text ) ) {
	if ( my $location = $loc[0] ) {
		##################################################
		# ADDITION:
		if(ref($location) eq 'Geo::Location::Point') {
			if((!defined($location->lat())) || !defined($location->long())) {
				return 0;
			}
			return [ $location->lat(), $location->long() ];
		}
		# END OF ADDITION
		##################################################

	    if ( ref( $location ) ne 'HASH' ) {
		warn "$point_text didn't return a HASH ref as first element from ->geocode";
		return 0;
	    }

	    if(defined($location->{geometry}{location}{lat}) && defined($location->{geometry}{location}{lng})) {
		return [
		    $location->{geometry}{location}{lat},
		    $location->{geometry}{location}{lng},
		];
	    }
	}
    }

    # Unknown
    return 0;
}

# FIXME: once RT127603 has been fixed
sub Geo::Coder::PlaceFinder::ua
{
	my $self = shift;

	if(my $ua = shift) {
		return $self->{_ua} = $ua;
	}

	return $self->{_ua};
}

# See https://github.com/OpenCageData/perl-Geo-Coder-OpenCage/issues/8
sub Geo::Coder::OpenCage::ua {
	my $self = shift;

	# if(my $ua = shift) {
		# $self->{ua} = $ua;
	# }
	return $self->{ua};
}

sub dateofbirth {
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};


	my $dateofbirth = get_value({ person => $person, value => 'birth date' });
	if((!defined($dateofbirth)) && (my $birth = $person->get_record('birth'))) {
		return $birth->date();
	}
	if(defined($dateofbirth) && (lc($dateofbirth) eq 'unknown')) {
		return;
	}
	return $dateofbirth;
}

sub dateofdeath {
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	my $dateofdeath = get_value({ person => $person, value => 'death date' });
	if((!defined($dateofdeath)) && (my $death = $person->get_record('death'))) {
		return $death->date();
	}
	if(defined($dateofdeath) && (lc($dateofdeath) eq 'unknown')) {
		return;
	}
	return $dateofdeath;
}
