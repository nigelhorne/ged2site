#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015-2016, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# TODO: Move from CSV to XML

use strict;
use warnings;
use autodie qw(:all);
# use warnings::unused;

# BEGIN {
	# *CORE::GLOBAL::die = \&main::die;
# }

use Gedcom;
use Getopt::Std;
use Gedcom;
use Lingua::EN::NameCase;
use Lingua::EN::NameParse;
use Lingua::EN::Numbers::Ordinate;
use Lingua::EN::ABC;
# use Lingua::EN::AddressParse;
use DateTime::Format::Natural;
use Genealogy::Gedcom::Date;
use DateTime::Duration;
use Geo::Coder::OSM;
# use Geo::Coder::Canada;
use Tie::Static;
use Term::ANSIColor;
use HTML::Entities;
use HTTP::Cache::Transparent;
use File::Spec;
use File::Temp;
use LWP::Simple;
use File::Basename;
use Image::Info;
use URI;
use URI::Find::Schemeless;
use LWP::UserAgent;
use HTML::GoogleMaps::V3;
use Sort::Key::DateTime;
use String::ProgressBar;
use Text::Names;
use MIME::Base64;
use Memoize;
use Time::HiRes;
use File::Copy;
no lib '.';

my %opts;
getopts('cdfFg:h:lmM:wv', \%opts);
die "Usage: $0 [ -c ] [ -d ] [ -F ] [ -f ] [ -g google verification ] [ -h home-person-name ] [ -l ] [ -m ] [ -w ] filename [ filename2 ]\n" unless($ARGV[0]);

my $me;
my @myancestors;
my %warned;
my %printed;
my %places;
my $surnames;
my %censuses;
my %images;
my %all_events;	# Maps events to people

my $nameparser = Lingua::EN::NameParse->new(extended_titles => 1);
my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);
my $ged2;
if($ARGV[1]) {
	$ged2 = Gedcom->new(gedcom_file => $ARGV[1], read_only => 1);
}
my $dfn = DateTime::Format::Natural->new();
my $geocoder = Geo::Coder::OSM->new();
my $date_parser = Genealogy::Gedcom::Date->new();
my $ninemonths = DateTime::Duration->new(months => 9);
my $sixteenyears = DateTime::Duration->new(years => 16);
my $year_1000 = DateTime->new(year => 1000, month => 1, day => 1);

# FIXME: Do this properly
my %censusmaps = (
	'1841 England Census' => '1841 UK Census',
	'1841 England, Wales & Scotland Census - Findmypast' => '1841 UK Census',
	'1851 England Census' => '1851 UK Census',
	'1851 England, Wales & Scotland Census - Findmypast' => '1851 UK Census',
	'1861 England Census' => '1861 UK Census',
	'1861 England, Wales & Scotland Census - Findmypast' => '1861 UK Census',
	'1871 England Census' => '1871 UK Census',
	'1871 England, Wales & Scotland Census - Findmypast' => '1871 UK Census',
	'1881 England Census' => '1881 UK Census',
	'1881 England, Wales & Scotland Census - Findmypast' => '1881 UK Census',
	'1881 Isle of Man Census' => '1881 Isle of Man Census',
	'1891 England Census' => '1891 UK Census',
	'1891 England, Wales & Scotland Census - Findmypast' => '1891 UK Census',
	'1901 England Census' => '1901 UK Census',
	'1901 England, Wales & Scotland Census - Findmypast' => '1901 UK Census',
	'1911 England Census' => '1911 UK Census',
	'1911 England Census Summary Books' => '1911 UK Census',
	'1911 Census for England & Wales - Findmypast' => '1911 UK Census',

	'1851 Census of Canada East, Canada West, New Brunswick, and Nova Scotia' => '1851 Canadian Census',
	'1861 Census of Canada' => '1861 Canadian Census',
	'1871 Census of Canada' => '1871 Canadian Census',
	'Kent County, New Brunswick Census, 1871: Eight Subdistricts' => '1811 Canadian Census',
	'1881 Census of Canada' => '1881 Canadian Census',
	'1891 Census of Canada' => '1891 Canadian Census',
	'1901 Census of Canada' => '1901 Canadian Census',
	'1906 Canada Census of Manitoba, Saskatchewan, and Alberta' => '1906 Canadian Census',
	'1911 Census of Canada' => '1911 Canadian Census',
	'1916 Canada Census of Manitoba, Saskatchewan, and Alberta' => '1916 Canadian Census',
	'1921 Census of Canada' => '1921 Canadian Census',

	'1850 United States Federal Census' => '1850 US Census',
	'US Census 1850 - Findmypast' => '1850 US Census',

	'1860 United States Federal Census' => '1860 US Census',
	'US Census 1860 - Findmypast' => '1860 US Census',

	'US Census 1870 - Findmypast' => '1870 US Census',
	'1870 United States Federal Census' => '1870 US Census',

	'1880 United States Federal Census' => '1880 US Census',

	'US Census 1900 - Findmypast' => '1900 US Census',
	'1900 United States Federal Census' => '1900 US Census',

	'1910 United States Federal Census' => '1910 US Census',
	'US Census 1910 - Findmypast' => '1910 US Census',

	'1920 United States Federal Census' => '1920 US Census',
	'US Census 1920 - Findmypast' => '1920 US Census',

	'US Census 1930 - Findmypast' => '1930 US Census',
	'1930 United States Federal Census' => '1930 US Census',

	'US Census 1940 - Findmypast' => '1940 US Census',
	'1940 United States Federal Census' => '1940 US Census',
);

# sub realdie
# {
	# CORE::die (@_);
# }

# sub die {
	# my @arg = shift;
# 
	# print STDERR "@arg\n" if($arg[0]);
# 
	# my $i = 0;
	# while((my @call_details = (caller($i++)))) {
		# print STDERR $call_details[1], ':', $call_details[2], ' in function ', $call_details[3], "\n";
	# }
# 
	# realdie @arg;
# }

# $ged->validate();

if($opts{h}) {
	$me = $ged->get_individual($opts{h});
	unless($me) {
		die "$0: Can't find '$opts{h}' in $ARGV[0]";
	}
}

my $dot;
my $jpegtran;
my $jpegoptim;
if($opts{'F'}) {
	if(-x '/usr/bin/dot') {
		$dot = '/usr/bin/dot';
	} elsif(-x '/usr/local/bin/dot') {
		$dot = '/usr/local/bin/dot';
	} elsif(-x '/sw/bin/dot') {
		$dot = '/sw/bin/dot';
	}

	if(!defined($dot)) {
		if($opts{'f'}) {
			die 'Graphviz not found, no family trees';
		}
		if($opts{'w'}) {
			red_warning(warning => 'Graphviz not found, no family trees');
		}
	} else {
		require Image::Magick::Thumbnail;
		Image::Magick::Thumbnail->import();
		print "Using $dot\n" if($opts{'v'});
	}
}

my @dirlist = ('static-site', 'dynamic-site/databases');
if($dot || $opts{'d'}) {
	push @dirlist, 'static-site/img';
	push @dirlist, 'dynamic-site/img';
	push @dirlist, 'thumbs';

	if(-x '/usr/bin/jpegtran') {
		$jpegtran = '/usr/bin/jpegtran';
	} elsif(-x '/usr/local/bin/jpegtran') {
		$jpegtran = '/usr/local/bin/jpegtran';
	} elsif(-x '/opt/local/bin/jpegtran') {
		$jpegtran = '/opt/local/bin/jpegtran';
	} elsif(-x '/sw/bin/jpegtran') {
		$jpegtran = '/sw/bin/jpegtran';
	}
	if(-x '/usr/bin/jpegoptim') {
		$jpegoptim = '/usr/bin/jpegoptim';
	} elsif(-x '/usr/local/bin/jpegoptim') {
		$jpegoptim = '/usr/local/bin/jpegoptim';
	} elsif(-x '/sw/bin/jpegoptim') {
		$jpegoptim = '/sw/bin/jpegoptim';
	}
}

my $gedcal;
if(-x '/usr/bin/gedcal') {
	$gedcal = '/usr/bin/gedcal';
} elsif(-x '/usr/local/bin/gedcal') {
	$dot = '/usr/local/bin/gedcal';
} elsif(-x '../gedcal/gedcal') {
	$gedcal = '../gedcal/gedcal';
}

if($gedcal) {
	push @dirlist, 'static-site/calendar';
}

foreach my $dir(@dirlist) {
	mkdir $dir if(!-d $dir);
}

if($opts{'d'}) {
	# Download copies of objects rather than link to them, useful if the
	# objects are on pay sites such as FMP
	my $cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'http-cache-transparent');
	if(!-d $cachedir) {
		mkdir $cachedir || die "$cachedir: $!";
	}
	HTTP::Cache::Transparent::init({
		BasePath => $cachedir,
		Verbose => $opts{'v'} ? 1 : 0,
		NoUpdate => 24 * 60 * 60,
	});
}

my @everyone = $ged->individuals();
my $total = scalar(@everyone);
my $index = 0;
my $dtl = DateTime::Locale->load($ENV{'LANG'});

my $pr;
if(!$opts{'w'}) {
	$pr = String::ProgressBar->new(max => $total, length => 60);
}

memoize('Gedcom::Individual::as_string');
memoize('stepsabove');

# Would be nice to use XML, but that needs DBD::AnyData which doesn't build
# open(my $xml, '>', 'dynamic-site/databases/people.xml');
# print $xml '<?xml version="1.0" encoding="US-ASCII"?><table>';
open(my $csv, '>', 'dynamic-site/databases/people.csv');
print $csv "entry!title!home!alive!bio!father!mother!children!citations!notes!media!family_tree!warnings!map_head!map_body!dob!dod\n";
foreach my $person($ged->individuals()) {
	$index++;
	if(!$opts{'w'}) {
		$| = 1;
		$pr->update($index);
		$pr->write();
		$| = 0;
	}
	if(!$printed{$person->{'xref'}}) {
		# FIXME: change &eacute; to e
		# print $xml "<person person_id=\"$index\">";
		print_person({ person => $person });
		# print $xml '</person>';
		print $csv "\n";
	}
}
# print $xml '</table>';
# close $xml;
close $csv;

if(!$opts{'w'}) {
	print "\n$index records processed\n";
}

my $name;
if($me) {
	$name = 'of ' . $me->as_string(nee => 1);
} else {
	$name = 'on this site';
}

if($opts{'w'}) {
	open(my $html, '>', 'static-site/todo.html');
	print $html "<html><head><title>Errors in the Family Tree $name</title>",
		"</head><body><center><h1>Errors in the Family Tree $name</h1>";
	if($me) {
		print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	print $html ' | [ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="censuses.html">Census Index</a> ]',
		' | [ <a href="calendar/index.html">Calendar</a> ]',
		' | [ <a href="history.html">Family History</a> ]</center><br>';

	open(my $csv, '>', 'dynamic-site/databases/todo.csv');
	print $csv "entry!person!title!error\n";
	my $index = 1;

	foreach my $person($ged->individuals()) {
		if($person->{'warnings'}) {
			print $html '<h2>',
				'<a href="', make_filename_from_person(person => $person), '">', $person->as_string(include_years => 1), '</a></h2>',
				map { HTML::Entities::encode($_) . '<br>' } @{$person->{'warnings'}};
			foreach my $warning(@{$person->{'warnings'}}) {
				print $csv "$index!",
					$person->{'xref'}, '!',
					$person->as_string(include_years => 1), '!',
					HTML::Entities::encode($warning), "\n";
				$index++;
			}
		}
	}
	close $csv;
	close $html;
}

print "Creating census index\n";
open(my $html, '>', 'static-site/censuses.html');
print $html "<html><head><title>Censuses in the Family Tree $name</title>",
	"</head><body><center><h1>Censuses in the Family Tree $name</h1></center><br><ul>";

open($csv, '>', 'dynamic-site/databases/censuses.csv');
print $csv "entry!census!person\n";

$index = 1;
foreach my $census(sort keys(%censuses)) {
	my $filename = $census;
	$filename =~ tr/ /_/;
	print $html "<li><a href=\"$filename.html\">$census</a></li>";

	open(my $chtml, '>', "static-site/$filename.html");
	print $chtml "<html><head><title>The Family Tree $name - $census</title>",
		'</head>',
		"<body><center><h1>The Family Tree $name - $census</h1>";
	if($me) {
		print $chtml '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	print $chtml ' | [ <a href="surnames.html">Surnames Index</a> ]';
	if($opts{'w'}) {
		print $chtml ' | [ <a href="todo.html">Errors</a> ]';
	}
	if($gedcal) {
		print $chtml ' | [ <a href="calendar/index.html">Calendar</a> ]';
	}
	print $chtml ' | [ <a href="censuses.html">Census Index</a> ]',
		' | [ <a href="history.html">Family History</a> ]</center><br>',
		'<ul>';

	foreach my $name(sort keys %{$censuses{$census}}) {
		print $chtml '<li>',
			'<a href="', make_filename_from_person(person => $censuses{$census}->{$name}), '">',
			$name,
			'</a></li>';
		print $csv "$index!$census!", $censuses{$census}->{$name}->{'xref'}, "\n";
		$index++;
	}

	print $chtml '</ul></body></html>';
	close $chtml;
}
print $html '</ul></body></html>';
close $html;
close $csv;

print "Creating surname index\n";
open($html, '>', 'static-site/surnames.html');
print $html "<html><head><title>Surnames in the Family Tree $name</title>",
	"</head><body><center><h1>Surnames in the Family Tree $name</h1>";
if($me) {
	print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
}
print $html ' | [ <a href="surnames.html">Surnames Index</a> ]',
	' | [ <a href="censuses.html">Census Index</a> ]',
	' | [ <a href="calendar/index.html">Calendar</a> ]';
if($opts{'w'}) {
	print $html ' | [ <a href="todo.html">Errors</a> ]';
}
print $html ' | [ <a href="history.html">Family History</a> ]</center><br><ul>';

open($csv, '>', 'dynamic-site/databases/surnames.csv');
print $csv "entry!surname!person\n";
$index = 1;

foreach my $surname(sort keys %{$surnames}) {
	my $filename = $surname;
	if($filename eq '') {
		$filename = 'UNKNOWN';
	}
	print $html "<li><a href=\"$filename.html\">$filename</a> (";
	my $count = scalar(keys %{$surnames->{$surname}});
	if($count == 1) {
		print $html '1 person';
	} else {
		print $html "$count people";
	}
	print $html ')</li>';

	open(my $shtml, '>', "static-site/$filename.html");
	print $shtml "<html><head><title>The Family Tree $name - $surname</title>",
		'</head>',
		"<body><center><h1>The Family Tree $name - $surname</h1>";
	if($me) {
		print $shtml '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	if($gedcal) {
		print $shtml ' | [ <a href="calendar/index.html">Calendar</a> ]';
	}
	print $shtml ' | [ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="history.html">Family History</a> ]';
	if($opts{'w'}) {
		print $shtml ' | [ <a href="todo.html">Errors</a> ]';
	}
	print $shtml ' | [ <a href="censuses.html">Census Index</a> ]</center><br>',
		'<ul>';

	foreach my $person(sort keys %{$surnames->{$surname}}) {
		# print "\t$person maps to ", $surnames->{$surname}->{$person}, "\n";
		print $shtml '<li>',
			'<a href="', make_filename_from_person(person => $surnames->{$surname}->{$person}), "\">$person</a>",
			'</li>';
		print $csv "$index!$filename!", $surnames->{$surname}->{$person}->{'xref'}, "\n";
		$index++;
	}

	print $shtml '</ul></body></html>';
	close $shtml;
}

print $html '</ul></body></html>';
close $html;
close $csv;

if($opts{'g'}) {
	open($html, '>', "static-site/$opts{g}.html");
	print $html "google-site-verification: $opts{g}.html";
	close $html;
	open($html, '>', "dynamic-site/$opts{g}.html");
	print $html "google-site-verification: $opts{g}.html";
	close $html;
}

if($gedcal) {
	print "Creating calendar\n";
	if(open(my $fout, '>', 'static-site/calendar/index.html')) {
		print $fout "<html><head><title>Genealogy Calendar $name</title></head>",
			"<body><center><h1>Genealogy Calendar $name</h1>";
		if($me) {
			print $fout '[ <a href="../', make_filename_from_person(person => $me), '">Home</a> ]';
		}
		print $fout ' | [ <a href="../surnames.html">Surnames Index</a> ]',
			' | [ <a href="../censuses.html">Census Index</a> ]';
		if($opts{'w'}) {
			print $fout ' | [ <a href="todo.html">Errors</a> ]';
		}
		print $fout ' | [ <a href="../history.html">Family History</a> ]</center><br><ul>';
		my $pr = String::ProgressBar->new(max => 12, length => 60);
		foreach my $month(1..12) {
			if(open(my $fin, '-|', "$gedcal -dHLm $month '$ARGV[0]'")) {
				$| = 1;
				$pr->update($month);
				$pr->write();
				$| = 0;
				print $fout "<li><a href=\"$month.html\">", @{$dtl->month_format_wide()}[$month - 1], '</a></li>';
				open(my $mout, '>', "static-site/calendar/$month.html");
				while(<$fin>) {
					print $mout $_;
				}
			}
		}
		print "\n";
		print $fout '</ul></body></html>';
	}
}

# TODO - this is a POC which seems to work
if(open(my $fout, '>', 'static-site/history.html')) {
	print "Creating family history page\n";
	print $fout "<html><head><title>Family History $name</title></head>",
		"<body><center><h1>Family History $name</h1>";
	if($me) {
		print $fout '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	print $fout ' | [ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="censuses.html">Census Index</a> ]';
	if($opts{'w'}) {
		print $fout ' | [ <a href="todo.html">Errors</a> ]';
	}
	print $fout ' | [ <a href="calendar/index.html">Calendar</a> ]</center><br>',
		'<ul>';
	my @sorted_events = Sort::Key::DateTime::dtkeysort { $all_events{$_}->{'date'} } keys %all_events;
	my $year;
	open(my $csv, '>', 'dynamic-site/databases/history.csv');
	print $csv "entry!year!month!day!person!title!event\n";
	my $index = 1;
	foreach my $e(@sorted_events) {
		$e = $all_events{$e};
		my $date = $e->{'date'};
		if(!(defined($year)) || ($date->year() != $year)) {
			$year = $date->year();
			if($year) {
				print $fout '</ul>';
			}
			print $fout "<h2>$year</h2><ul>";
		}
		my $person = $e->{'person'};
		print $fout '<li>', @{$dtl->month_format_wide()}[$date->month() - 1], ' ',
			$date->day(), ': <a href="',
			make_filename_from_person(person => $person), '">',
			$e->{'person'}->as_string(), '</a>: ', $e->{'event'}, '</li>';
		print $csv "$index!$year!",
			$date->month(), '!',
			$date->day(), '!',
			$person->{'xref'}, '!',
			$person->as_string(), '!',
			$e->{'event'}, "\n";
		$index++;
	}
	close $csv;
	print $fout '</ul></body></html>';
	close $fout;
}

sub print_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# Gather the information on this person
	my $person = $params{'person'};
	my $dob = get_value({ person => $person, value => 'birth date' });

	print 'Checking ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

	my @siblings = $person->siblings();
	my $mother = $person->mother();
	my $father = $person->father();
	my @spouses = $person->spouse();

	# TODO: Properly chart which spouse a child comes from
	# FIXME: This current algorithm misses children from all the marriages
	my $family;
	foreach my $f($person->fams()) {
		if($f->number_of_children()) {
			$family = $f;
			last;
		}
	}

	if($opts{'w'} && (!$family) && (scalar(@siblings) == 0) && (!$mother) && (!$father) && (scalar(@spouses) == 0)) {
		if($opts{'f'}) {
			die $person->as_string() . ': not connected to the tree';
		}
		red_warning({ person => $person, warning => 'not connected to the tree' });
	}

	my $year = $params{'year'} || (localtime)[5];
	$year += 1900 if($year < 1900);

	my $yob;	# Year of birth
	if($dob && ($dob =~ /.*?(\d{3,4})/)) {
		$yob = $1;
	} elsif($dob) {
		if($opts{'w'} && !$warned{$person}) {
			if($opts{'f'}) {
				die $person->name(), ": invalid date of birth $dob\n";
			}
			warn $person->name(), ": invalid date of birth $dob\n";
			$warned{$person} = 1;
		}
	}

	my $death = $person->get_record('death');
	my $dateofdeath = get_value({ person => $person, value => 'death date' });
	if((!$dateofdeath) && $death) {
		$dateofdeath = $death->date();
	}

	my $person2;
	if($ged2) {
		$person2 = $ged2->get_individual($person->as_string());
		if($opts{'w'}) {
			if(!defined($person2)) {
				if($opts{'f'}) {
					die $person->as_string() . ": not found in $ARGV[1]";
				}
				red_warning({
					person => $person,
					warning => "not found in $ARGV[1]"
				})
			}
		}
	}
	my $title = $person->as_string({
		include_years => 1,
		nee => 1,
		middle_names => 1,
		title => 1,
	});

	my $name = $person->name();
	$name =~ s/\///g;
	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	my $firstname = $name_components{'given_name_1'};
	# my $surname = $name_components{'surname_2'} || $name_components{'surname_1'};
	my $surname = ucfirst(lc($person->surname())); # RT109786

	my $was_alive = was_alive(person => $person, year => $year);
	if($was_alive && !$opts{'l'}) {
		$title = $firstname;
	}

	open(my $html, '>', 'static-site/' . make_filename_from_person(person => $person));
	# print $xml '<entry>', $person->{'xref'}, "</entry><title>$title</title>";
	print $csv $person->{'xref'}, "!$title!";

	if($me && ($person eq $me)) {
		my $name = $person->as_string(nee => 1);

		open(my $html, '>', 'static-site/index.html');
		print $html "<html><head><title>The Family Tree $name</title>",
			'<meta http-equiv="Refresh" content="1;URL=', make_filename_from_person(person => $person), '">';
		if($ENV{'LANG'}) {
			my $lang = $ENV{'LANG'};
			$lang =~ s/\.UTF-8//;
			$lang =~ tr/_/-/;
			$lang = lc($lang);
			print $html "<meta http-equiv=\"Content-Language\" content=\"$lang\">";
		}
		print $html '</head>',
			"<body><h1>The Family Tree $name</h1><a href=\"", make_filename_from_person(person => $person), "\">$name</a></body></html>";
		close $html;
		# print $xml '<home>1</home>';
		print $csv '1!';
	} else {
		print $csv '0!';
	}

	if($opts{'m'}) {
		print $html "<html><head><title>$title</title></head><body onload=\"html_googlemaps_initialize()\"><center><h1>$title</h1>",
	} else {
		if($opts{'M'}) {
			die "$0: -M makes no sense without -m";
		}
		print $html "<html><head><title>$title</title></head><body><center><h1>$title</h1>",
	}
	if(defined($me)) {
		print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	if($gedcal) {
		print $html ' | [ <a href="calendar/index.html">Calendar</a> ]';
	}
	print $html ' | [ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="censuses.html">Census Index</a> ]';
	if($opts{'w'}) {
		print $html ' | [ <a href="todo.html">Errors</a> ]';
	}
	print $html ' | [ <a href="history.html">Family History</a> ]</center><p>';

	my $bio;

	if($was_alive && !$opts{'l'}) {
		# print $xml '<alive>1</alive>';
		print $csv '1!';
		$bio = '<i>This is the record of a living person, so much data will not be shown.</i></p><p>';
	} else {
		print $csv '0!';
		$surnames->{$surname}->{$title} = $person;
	}

	my ($birth_dt, $marriage_dt, $death_dt);
	my $birth = $person->get_record('birth');
	my $dateofbirth = get_value({ person => $person, value => 'birth date' });
	if((!$dateofbirth) && $birth) {
		$dateofbirth = $birth->date();
	}

	my %citations;
	my $citationcount = 0;
	my @birthcitations;
	my @deathcitations;
	if($opts{'c'}) {
		if($birth) {
			if($opts{'w'}) {
				foreach my $s($birth->source()) {
					if(!defined(get_source({ gedcom => $ged, person => $person, source => $s }))) {
						if($opts{'f'}) {
							die $person->as_string(), ': Citation is missing a source';
						}
						red_warning({ person => $person, warning => 'Citation is missing a source' });
					}
				}
			}
			my @s = sort { (get_source({ gedcom => $ged, person => $person, source => $a }) && get_source({ gedcom => $ged, person => $person, source => $b })) ? get_source({ gedcom => $ged, person => $person, source => $a })->title() cmp get_source({ gedcom => $ged, person => $person, source => $b })->title() : 0 } $birth->source();
			my $previous;
			foreach my $src(@s) {
				# $src = $ged->get_source($src) unless ref($src);
				$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
				if(defined($src) && $src->title()) {
					if($previous && ($src->title() eq $previous)) {
						next;
					}
					$previous = $src->title();
					push @birthcitations, ++$citationcount;
					$citations{$citationcount} = $src;
				}
			}
		}
		if($death) {
			my @s = $death->source();
			foreach my $src(@s) {
				$src = $ged->get_source($src) unless ref($src);
				my $seen;
				foreach my $bc(@birthcitations) {
					if($src eq $citations{$bc}) {
						push @deathcitations, $bc;
						$seen++;
						last;
					}
				}
				if(!$seen) {
					push @deathcitations, ++$citationcount;
					$citations{$citationcount} = $src;
				}
			}
		}
	}

	my %place_records;

	my $placeofbirth = get_value({ person => $person, value => 'birth place' });
	if((!$placeofbirth) && $birth) {
		$placeofbirth = $birth->place();
	}

	my $baptism = $person->get_record('baptism');
	my $dateofbaptism = get_value({ person => $person, value => 'baptism date' });
	if((!$dateofbaptism) && $baptism) {
		$dateofbaptism = $baptism->date();
	}
	my $placeofbaptism = get_value({ person => $person, value => 'baptism place' });
	if((!$placeofbaptism) && $baptism) {
		$placeofbaptism = $baptism->place();
	}

	my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage');
	if((!defined($marriage)) && scalar(@spouses)) {
		$marriage = $spouses[0]->get_record('marriage');
	}
	my $dateofmarriage = get_value({ person => $person, value => 'marriage date' });
	if((!$dateofmarriage) && $marriage) {
		$dateofmarriage = $marriage->date();
	}
	my $placeofmarriage = get_value({ person => $person, value => 'marriage place' });
	if((!$placeofmarriage) && $marriage) {
		$placeofmarriage = $marriage->place();
	}

	my $placeofdeath = get_value({ person => $person, value => 'death place' });
	if((!$placeofdeath) && $death) {
		$placeofdeath = $death->place();
	}

	my $burial = $person->get_record('burial');
	my $dateofburial = get_value({ person => $person, value => 'burial date' });
	if((!$dateofburial) && $burial) {
		$dateofburial = $burial->date();
	}
	my $placeofburial = get_value({ person => $person, value => 'burial place' });
	if((!$placeofburial) && $burial) {
		$placeofburial = $burial->place();
	}

	if($dateofbirth && ($dateofbirth !~ /^\d{3,4}$/) && ($dateofbirth =~ /^\d/) && ($dateofbirth !~ /[a-z]$/i)) {
		my $d;
		eval {
			$d = $date_parser->parse(date => $dateofbirth);
		};
		if($d) {
			$d = @{$d}[0];
			if($d) {
				$birth_dt = $dfn->parse_datetime($d->{'canonical'});
			}
		}
	}
	if($dateofmarriage && ($dateofmarriage !~ /^\d{3,4}$/) && ($dateofmarriage =~ /^\d/) && ($dateofmarriage !~ /[a-z]$/i)) {
		my $d;
		eval {
			$d = $date_parser->parse(date => $dateofmarriage);
		};
		if($d) {
			if($d = @{$d}[0]) {
				$marriage_dt = $dfn->parse_datetime($d->{'canonical'});
				if($birth_dt && $opts{'w'} && ($marriage_dt < ($birth_dt + $sixteenyears))) {
					if($opts{'f'}) {
						die $person->as_string(),
							': married when less than 16 years old';
					}
					red_warning({
						person => $person,
						warning => 'married when less than 16 years old'
					});
				}
			}
		}
	}
	if($dateofdeath && ($dateofdeath !~ /^\d{3,4}$/) && ($dateofdeath =~ /^\d/)) {
		my $d;
		eval {
			$d = $date_parser->parse(date => $dateofdeath);
		};
		if($d) {
			$d = @{$d}[0];
			if($d) {
				$death_dt = $dfn->parse_datetime($d->{'canonical'});
			}
		}
	}

	if($opts{'l'} || !$was_alive) {
		# RT114091
		if($birth_dt && ($birth_dt >= $year_1000)) {
			$all_events{'B' . $person->{'xref'}} = { person => $person, event => 'Birth', date => $birth_dt };
		}
		if($marriage_dt && ($marriage_dt >= $year_1000)) {
			$all_events{'M' . $person->{'xref'}} = { person => $person, event => 'Marriage', date => $marriage_dt };
		}
		if($death_dt && ($death_dt >= $year_1000)) {
			$all_events{'D' . $person->{'xref'}} = { person => $person, event => 'Death', date => $death_dt };
		}
	}

	if($placeofbirth) {
		$place_records{'Birth'} = $birth;
	}
	if($placeofbaptism) {
		if($ENV{'LANG'} =~ /^en_US/) {
			$place_records{'Baptized'} = $baptism;
		} else {
			$place_records{'Baptised'} = $baptism;
		}
	}
	if($placeofmarriage) {
		$place_records{'Marriage'} = $marriage;
	}
	if($placeofdeath) {
		$place_records{'Death'} = $death;
	}
	if($placeofburial) {
		$place_records{'Burial'} = $burial;
	}

	my $marriagecitation;
	my @burialcitations;
	if($opts{'c'}) {
		if($marriage) {
			my $src = $marriage->source();
			if($src) {
				$src = $ged->get_source($src) unless ref($src);
				if(!defined($src)) {
					if($opts{'w'}) {
						my $src = $marriage->source();
						if($opts{'f'}) {
							die $person->as_string(), ": marriage citation can't find source $src";
						}
						red_warning({ person => $person, warning => "marriage citation can't find source $src" });
					}
				} elsif($birthcitations[0] && ($citations{$birthcitations[0]} eq $src)) {
					$marriagecitation = $birthcitations[0];
				} elsif($deathcitations[0] && ($citations{$deathcitations[0]} eq $src)) {
					$marriagecitation = $deathcitations[0];
				} else {
					$marriagecitation = ++$citationcount;
					$citations{$marriagecitation} = $src;
				}
			}
		}
		if($burial) {
			my @s = $burial->source();
			foreach my $src(@s) {
				$src = $ged->get_source($src) unless ref($src);
				if(!defined($src)) {
					if($opts{'w'}) {
						my $src = $burial->source();
						if($opts{'f'}) {
							die $person->as_string(), ": burial citation can't find source $src";
						}
						red_warning({ person => $person, warning => "burial citation can't find source $src" });
					}
					next;
				}
				my $seen;
				foreach my $dc(@deathcitations) {
					if($src eq $citations{$dc}) {
						push @burialcitations, $dc;
						$seen++;
						last;
					}
				}
				if(!$seen) {
					if($marriagecitation && ($citations{$marriagecitation} eq $src)) {
						push @burialcitations, $marriagecitation;
					} else {
						push @burialcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
			}
		}
	}

	my $pronoun = $person->pronoun();
	my $sex = $person->sex();
	my @occupations = $person->get_value('occupation');

	my @children;
	foreach my $f($person->fams()) {
		@children = (@children, $f->children());
	}
	my $numberofchildren = scalar(@children);

	my $relationship;
	my $spouserelationship;
	my $spouse;
	my %places_printed;

	if($dateofbirth && $opts{'w'} && scalar(@siblings)) {
		foreach my $sibling(@siblings) {
			my $siblingbirth = get_value({ person => $sibling, value => 'birth date' });
			if($siblingbirth && ($siblingbirth eq $dateofbirth) &&
			  (($sibling->name() eq $person->name()) || Text::Names::samePerson($sibling->name(), $person->name()))) {
				if($opts{'f'}) {
					die $person->name(), ': Possible duplicate person';
				}
				red_warning({ person => $sibling, warning => 'possible duplicate person' });
			}
		}
	}

	if($me && ($person ne $me)) {
		$relationship = $me->relationship($person);
		if((!$relationship) && scalar(@spouses)) {
			if($person->spouse() eq $me) {
				$relationship = ($sex eq 'F') ? 'wife' : 'husband';
			} else {
				foreach my $s(@spouses) {
					$spouserelationship = $me->relationship($s);
					if($spouserelationship) {
						$spouse = $s;
						last;
					}
				}
			}
		}
	}

	# TODO: print all occupations
	while($occupations[0] && (lc($occupations[0]) =~ /^school/i)) {
		shift @occupations;
	}

	if($occupations[0]) {
		$bio = 'A';
		if($occupations[0] =~ /^[aeiou]/i) {
			$bio .= 'n';
		}
		$bio .= ' ' . HTML::Entities::encode(lc($occupations[0]));
		if(!($father || $mother || $spouserelationship)) {
			$bio .= ', ';
		}
	} elsif(scalar(@occupations)) {
		if($opts{'w'}) {
			if($opts{'f'}) {
				die $person->as_string, ': occupation is empty';
			}
			red_warning({
				person => $person,
				warning => 'occupation is empty'
			});
		}
		shift @occupations;
	}

	my $print_sibling_count = 0;
	if($father || $mother) {
		if(scalar(@occupations)) {
			$bio .= ' and the ';
		} else {
			$bio .= 'The ';
		}

		if($birth_dt && ($opts{'l'} || !$was_alive)) {
			if(scalar(@siblings)) {
				# If possible, sort siblings by date of birth
				my $all_siblings_have_dob = 1;
				foreach my $sibling(@siblings) {
					my $dob = get_value({ person => $sibling, value => 'birth date' });
					if((!$dob) || ($dob =~ /[\/\-]/) || !$date_parser->parse(date => $dob)) {
						$all_siblings_have_dob = 0;
						last;
					}
					my $d;
					eval {
						$d = $date_parser->parse(date => $dob);
					};
					if($d) {
						$d = @{$d}[0];
					}
					if($@ || !defined($d)) {
						if($opts{'f'}) {
							die $sibling->as_string(),
								" has an invalid date of birth: $dob";
						}
						if($opts{'w'}) {
							red_warning({
								person => $sibling,
								warning => "has an invalid date of birth: $dob"
							});
						}
						$all_siblings_have_dob = 0;
						last;
					}
				}
				if($all_siblings_have_dob) {
					@siblings = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => get_value({ person => $_, value => 'birth date'}))}[0]->{'canonical'}) } @siblings;
				}
				my $count = 1;
				$print_sibling_count = 1;
				foreach my $sibling(@siblings) {
					my $dob = get_value({ person => $sibling, value => 'birth date' });
					if($dob) {
						my $d;
						eval {
							$d = $date_parser->parse(date => $dob);
						};
						if($d) {
							$d = @{$d}[0];
						}
						if($d) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if($opts{'w'} &&
							  ($dob =~ /^\d/) && ($dob !~ /[a-z]$/i) &&
							  ($d < $birth_dt) &&
							  ($d > ($birth_dt - $ninemonths))) {
								if($opts{'f'}) {
									die $sibling->as_string(),
										' was born less than 9 months before ',
										$person->as_string();
								}
								red_warning({
									person => $sibling,
									warning => 'Born less than 9 months before ' . $person->as_string()
								});
							}
							$count++ if($d && ($d < $birth_dt));
						} else {
							$print_sibling_count = 0;
							last;
						}
					}
				}
				if($print_sibling_count) {
					if((scalar(@siblings)) && ($count == (scalar(@siblings) + 1))) {
						$bio .= ((scalar(@siblings) > 1) ? 'youngest' : 'younger');
					} else {
						$bio .= ordinate($count);
					}
					$bio .= ' of ' . (scalar(@siblings) + 1) . ' children';
				} else {
					$bio .= 'child';
				}
			} else {
				# $bio .= ' only child of';
				$bio .= 'child';
			}
		} else {
			$bio .= 'child';
		}

		$bio .= ' of';

		print $html $bio;
		print $csv $bio;

		$bio = '';

		if($opts{'l'} || !$was_alive) {
			if($father) {
				print $html ' <a href="', make_filename_from_person(person => $father), '">',
					$father->as_string(),
					'</a>';
				print $csv ' <a href="?page=people&entry=', $father->{'xref'}, '">'.
					$father->as_string(),
					'</a>';

				my @occupations = $father->get_value('occupation');
				# TODO: print $html all occupations
				if($occupations[0]) {
					print $html ' (a';
					print $csv ' (a';
					if($occupations[0] =~ /^[aeiou]/i) {
						print $html 'n';
						print $csv 'n';
					}
					print $html ' ', HTML::Entities::encode(lc($occupations[0])), ')';
					print $csv ' ', HTML::Entities::encode(lc($occupations[0])), ')';
				}
				if($mother) {
					print $html ' and';
					print $csv ' and';
				}
			}
			if($mother) {
				print $html ' <a href="', make_filename_from_person(person => $mother), '">',
					$mother->as_string(give_maidenname => 0),
					'</a>';
				print $csv ' <a href="?page=people&entry=', $mother->{'xref'}, '">'.
					$mother->as_string(),
					'</a>';

				my @occupations = $mother->get_value('occupation');
				# TODO: print $html all occupations
				if($occupations[0]) {
					print $html ' (a';
					print $csv ' (a';
					if($occupations[0] =~ /^[aeiou]/i) {
						print $html 'n';
						print $csv 'n';
					}
					print $html ' ', lc($occupations[0]), ')';
					print $csv ' ', lc($occupations[0]), ')';
				}
			}
		} else {
			if($father) {
				print $html ' <a href="', make_filename_from_person(person => $father), '">',
					$father->given_names(),
					'</a>';
				print $csv ' <a href="?page=people&entry=', $father->{'xref'}, '">',
					$father->given_names(),
					'</a>';
				if($mother) {
					print $html ' and';
					print $csv ' and';
				}
			}
			if($mother) {
				print $html ' <a href="', make_filename_from_person(person => $mother), '">',
					$mother->given_names(),
					'</a>';
				print $csv ' <a href="?page=people&entry=', $mother->{'xref'}, '">',
					$mother->given_names(),
					'</a>';
			}
		}
	}

	if($firstname) {
		if((!$was_alive) || $opts{'l'} || (!defined($me)) || ($person ne $me)) {
			if($father || $mother || $occupations[0]) {
				$bio .= ', ';
			}
			if($opts{'l'} || $was_alive) {
				$bio .= "<b>$firstname</b>";
				if($relationship) {
					if(($dob || $marriage) && (!($was_alive || $opts{'l'}))) {
						$bio .= ',';
					} elsif($was_alive) {
						$bio .= ' is';
					} else {
						$bio .= ' was';
					}
				}
			} else {
				$bio .= "<b>$firstname " .
					$name_components{'surname_1'} .
					'</b>';
				$bio .= ',' if($relationship);
			}
		}
	} else {
		$bio .= $pronoun;
	}

	print $html $bio;
	print $csv $bio;

	$bio = '';

	my $haveprintedspousename;
	if($relationship) {
		print $html " the $relationship of ",
			'<a href="', make_filename_from_person(person => $me), '">',
			$me->as_string(nee => 1),
			'</a>';
		print $csv " the $relationship of ",
			'<a href="?page=people&home=1">',
			$me->as_string(nee => 1),
			'</a>';
	} elsif($spouserelationship) {
		if($sex eq 'F') {
			print $html ', the wife of';
			print $csv ', the wife of';
		} else {
			print $html ', the husband of';
			print $csv ', the husband of';
		}
		print $html ' <a href="', make_filename_from_person(person => $spouse), '">',
			$spouse->as_string({ middle_names => 1, title => 1 }),
			"</a>, the $spouserelationship of ",
			'<a href="', make_filename_from_person(person => $me), '">',
			$me->as_string(nee => 1),
			'</a>,';
		print $csv ' <a href="?page=people&entry=', $spouse->{'xref'}, '">',
			$spouse->as_string({ middle_names => 1, title => 1 }),
			"</a>, the $spouserelationship of ",
			'<a href="?page=people&home=1">',
			$me->as_string(nee => 1),
			'</a>,';
		$haveprintedspousename = 1;
	}

	if(my $aka = $person->as_string({ use_aka => 1 })) {
		print $html " (also known as $aka)";
		print $csv " (also known as $aka)";
	}

	my $end_of_sentence = 0;

	if($opts{'l'} || !$was_alive) {
		if(($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism)) {
			if($dateofbirth || $placeofbirth) {
				# print $html ',' if($print_sibling_count && (!$opts{'a'}) && !$opts{'p'});

				$bio = ',' if($relationship);
				$bio .= ' was born';
				if($placeofbirth) {
					my $p = place({ person => $person, place => $placeofbirth });
					$bio .= $p;
					$places_printed{$p} = 1;
				}
				if($dateofbirth) {
					$bio .= ' ' . year({
						person => $person,
						date => $dateofbirth,
						must_predate => $death_dt
					});
				}
				$bio .= "[$_]" foreach(@birthcitations);
				if($dateofbaptism || $placeofbaptism) {
					if(scalar(@spouses)) {
						$bio .= ', was';
					} else {
						$bio .= ' and';
					}
				}
				$end_of_sentence = 0;
			}
			if($opts{'w'}) {
				if($mother && $yob && (my $mumdateofbirth = get_value({ person => $mother, value => 'birth date' }))) {
					if($mumdateofbirth =~ /.*?(\d{3,4})/) {
						$mumdateofbirth = $1;
						if(($yob - $mumdateofbirth) <= 13) {
							if($opts{'f'}) {
								die "something is wrong with the date of birth which is less than 13 years after the mother was born ($mumdateofbirth)";
							}
							red_warning({
								person => $person,
								warning => "something is wrong with the date of birth which is less than 13 years after the mother was born ($mumdateofbirth)"
							});
						}
					}
				}
				if($father && $yob && (my $daddateofbirth = get_value({ person => $father, value => 'birth date' }))) {
					if($daddateofbirth =~ /.*?(\d{3,4})/) {
						$daddateofbirth = $1;
						if(($yob - $daddateofbirth) <= 13) {
							if($opts{'f'}) {
								die "something is wrong with the date of birth which is less than 13 years after the father was born ($daddateofbirth)";
							}
							red_warning({
								person => $person,
								warning => "something is wrong with the date of birth which is less than 13 years after the father was born ($daddateofbirth)"
							});
						}
					}
				}
				if($death_dt || ($dateofdeath && ($dateofdeath =~ /^\d{3,4}$/))) {
					# TODO: Add more checking
					my $yod;
					if($death_dt) {
						$yod = $death_dt->year();
					} elsif($dateofdeath =~ /^(\d{3,4})$/) {
						$yod = $1;
					} else {
						die "BUG: Impossible case";
					}
					foreach my $bc(@birthcitations) {
						my $citation = $citations{$bc};
						my $title = $citation->title();
						if($title =~ /^(\d{3,4})\s/) {
							if($1 > $yod) {
								if($opts{'f'}) {
									die $person->as_string(),
										": Year of citation of $title is after the death year of $yod"
								}
								red_warning({
									person => $person,
									warning => "Year of citation of $title is after the death year of $yod"
								});
							}
						}
					}
				}
			}
			if($dateofbaptism || $placeofbaptism) {
				$bio .= ' ';
				unless($dateofbirth || $placeofbirth) {
					$bio .= 'was ';
				}
				if($ENV{'LANG'} =~ /^en_US/) {
					$bio .= 'baptized';
				} else {
					$bio .= 'baptised';
				}
				if($placeofbaptism) {
					if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
						$bio .= ' there';
					} else {
						my $p = place({ person => $person, place => $placeofbaptism });
						$bio .= $p;
						$places_printed{$p} = 1;
					}
				}
				if($dateofbaptism) {
					$bio .= ' ' . year({
						person => $person,
						date => $dateofbaptism,
						must_postdate => $birth_dt,
						must_predate => $death_dt
					}) . sibling_baptism_string({
						person => $person,
						siblings => \@siblings,
						date => $dateofbaptism,
						birthdate => $dateofbirth,
					});
				}
			}
			if(scalar(@spouses)) {
				$bio .= ' and';
			} else {
				$bio .= '.';
				$end_of_sentence = 1;
			}
		} elsif($dateofbaptism || $placeofbaptism) {
			$bio .= " $pronoun was ";

			if($ENV{'LANG'} =~ /^en_US/) {
				$bio .= 'baptized';
			} else {
				$bio .= 'baptised';
			}
			if($placeofbaptism) {
				if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
					$bio .= ' there';
				} else {
					my $opts = {
						person => $person,
						place => $placeofbaptism,
						places_printed => \%places_printed
					};
					my $address = $baptism->address();
					if($address) {
						$opts{'address'} = $address;
					}
					my $p = place($opts);
					$bio .= $p;
					$places_printed{$p} = 1;
				}
			}
			if($dateofbaptism) {
				$bio .= ' ' . year({
					person => $person,
					date => $dateofbaptism,
					must_postdate => $birth_dt,
					must_predate => $death_dt
				}) . sibling_baptism_string({
					person => $person,
					siblings => \@siblings,
					date => $dateofbaptism,
					birthdate => $dateofbirth,
				});
			}
			if(scalar(@spouses)) {
				$bio .= ' and';
				$end_of_sentence = 0;
			} else {
				$bio .= '.';
				$end_of_sentence = 1;
			}
		}

		my $all_children_are_alive = 1;

		if($yob && ($year >= $yob + 150)) {
			$all_children_are_alive = 0;
		} else {
			foreach my $child(@children) {
				if(!was_alive(person => $child, year => $year)) {
					$all_children_are_alive = 0;
					last;
				}
			}
		}

		if(scalar(@spouses) &&
		   ((!$spouserelationship) || $placeofmarriage || $dateofmarriage)) {
			$bio .= '<p>' . ucfirst($pronoun) if($end_of_sentence);

			if(scalar(@spouses) == 1) {
				if($placeofmarriage || $dateofmarriage) {
					$bio .= ' married ';
				} else {
					$bio .= ' was married to ';
				}
				my $parentheses = 0;
				if($haveprintedspousename) {
					$nameparser->parse($spouses[0]->name());

					my %name_components = $nameparser->components();
					$bio .= $name_components{'given_name_1'};
				} else {
					print $html $bio;
					print $csv $bio;
					$bio = '';
					if($opts{'l'} || !$was_alive) {
						print $html '<a href="', make_filename_from_person(person => $spouses[0]), '">',
							$spouses[0]->as_string(),
							'</a>';
						print $csv '<a href="?page=people&entry=', $spouses[0]->{'xref'}, '">',
							$spouses[0]->as_string(),
							'</a>';
					} else {
						print $html '<a href="', make_filename_from_person(person => $spouses[0]), '">',
							$spouses[0]->given_names(),
							'</a>';
						print $csv '<a href="?page=people&entry=', $spouses[0]->{'xref'}, '">',
							$spouses[0]->as_string(),
							'</a>';
					}
					$haveprintedspousename = 1;
				}
				if($numberofchildren) {
					if($parentheses || ((!$placeofmarriage) && (!$dateofmarriage))) {
						$bio .= ', ';
					} else {
						$bio .= ' (';
						$parentheses = 1;
					}
					if(my $soccupation = $spouses[0]->occupation()) {
						$bio .= 'a';
						if($soccupation =~ /^[aeiou]/i) {
							$bio .= 'n';
						}
						$bio .= ' ' . lc($soccupation) . ', ';
					}
					$bio .= 'with whom ' . lcfirst($pronoun);
					if((!$all_children_are_alive) || (!$opts{'l'}) || ($yob && ($year > $yob + 100))) {
						$bio .= ' had ';
					} elsif((!$dateofdeath) && (!$dateofburial) && ($spouses[0]) && !$spouses[0]->death()) {
						$bio .= ' has had ';
					} else {
						$bio .= $dateofdeath || $dateofburial ? ' had ' : ' has ';
					}
					if($numberofchildren == 1) {
						if($all_children_are_alive) {
							$bio .= '1 surviving child, ';
						} else {
							$bio .= '1 child, ';
						}
					} else {
						if($all_children_are_alive) {
							$bio .= "$numberofchildren surviving children: ";
						} else {
							$bio .= "$numberofchildren children: ";
						}
					}
					if($numberofchildren == 1) {
						$bio .= $children[0]->given_names();
					} elsif($numberofchildren > 1) {
						print $html $bio;
						print $csv $bio;
						$bio = '';
						my $childnames = join(', ', map {
							'<a href="' . make_filename_from_person(person => $_) . '">'.
								$_->given_names() . '</a>'
						} @children);
						substr($childnames, rindex($childnames, ', '), 2, ' and ');
						print $html $childnames;
						$childnames = join(', ', map {
							'<a href="?page=people&entry=' . $_->{'xref'} . '">'.
								$_->given_names() . '</a>'
						} @children);
						substr($childnames, rindex($childnames, ', '), 2, ' and ');
						print $csv $childnames;
					}
				} else {
					my @spouse_occupations = $spouses[0]->get_value('occupation');
					if($spouse_occupations[0]) {
						$bio = ' (a ' . HTML::Entities::encode(lc($spouse_occupations[0]));
						$parentheses = 1;
					}
				}
				if($opts{'l'} || !$was_alive) {
					if($parentheses) {
						$bio .= ')';
					} elsif(($dateofmarriage || $placeofmarriage) && $numberofchildren) {
						$bio .= ',';
					}
					if($placeofmarriage && $dateofmarriage &&
					   ($placeofbaptism and ($placeofmarriage eq $placeofbaptism))) {
						$bio .= ' there ' .
							year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt);
					} else {
						if($placeofmarriage) {
							my $args = {
								place => $placeofmarriage,
								person => $person,
								places_printed => \%places_printed
							};
							if($marriage && (my $address = $marriage->address())) {
								$args->{'address'} = $address;
							}
							my $p = place($args);
							$bio .= $p;
							$places_printed{$p} = 1;
						}
						$bio .= ' ' . year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt) if($dateofmarriage);
					}
					$bio .= "[$marriagecitation]" if($marriagecitation);
				}
			} elsif($opts{'l'} || !$was_alive) {
				$bio .= ' was married ';
				if(scalar(@spouses) == 2) {
					$bio .= 'twice';
				} else {
					$bio .= scalar(@spouses) . ' times';
				}

				my $names;
				my $spousenumber = 0;
				foreach my $spouse(@spouses) {
					# $names .= ', ' if($names);
					$names .= ' <a href="' . make_filename_from_person(person => $spouse) . '">' .
						$spouse->as_string() . '</a>';
					my $dateofmarriage = get_value({ person => $spouse, value => 'marriage date' });
					if(!defined($dateofmarriage)) {
						my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage');
						if($marriage) {
							$dateofmarriage = $marriage->date();
						}
					}
					my $placeofmarriage = get_value({ person => $spouse, value => 'marriage place' });
					if(!defined($placeofmarriage)) {
						my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage');
						if($marriage) {
							$placeofmarriage = $marriage->place();
						}
					}
					if($dateofmarriage && $placeofmarriage) {
						$names .= ' (' .
							year({ string => $dateofmarriage }) .
							place({ person => $spouse, place => $placeofmarriage, places_printed => \%places_printed }) .
							')';
					} elsif($placeofmarriage) {
						$names .= ' (' .
							place({ person => $spouse, place => $placeofmarriage, places_printed => \%places_printed }) .
							')';
					} elsif($dateofmarriage) {
						$names .= ' (' .
							year({ string => $dateofmarriage }) .
							')';
					}
					$spousenumber++;
					if($spousenumber == (scalar(@spouses) - 1)) {
						$names .= ' and';
					} elsif($spousenumber < (scalar(@spouses) - 1)) {
						$names .= ',';
					}
				}
				# substr($names, rindex($names, ', '), 2, ' and ');
				$bio .= ", to$names";
				$bio .= "[$marriagecitation]" if($marriagecitation);

				# Determine if all the children are from one marriage, since that's
				# easier to print.
				# FIXME:  handle where offspring are from more than one marriage
				if($numberofchildren) {
					my %childrenbyspouse;
					foreach my $family ($person->fams()) {
						if($family->number_of_children() &&
						   ($spouse = ($sex eq 'M') ? $family->wife() : $family->husband())) {
							my $spouse = ($sex eq 'M') ? $family->wife() : $family->husband();
							foreach my $child($person->children()) {
								foreach my $spouseschild($spouse->children()) {
									if($spouseschild eq $child) {
										$childrenbyspouse{$spouse}++;
										last;
									}
								}
							}
						}
					}
					my $parentofall;
					foreach my $spouse(@spouses) {
						if($parentofall && $childrenbyspouse{$spouse}) {
							$parentofall = undef;
							last;
						}
						if($childrenbyspouse{$spouse}) {
							$parentofall = $spouse;
						}
					}
					$bio .= ". $pronoun " .
						($all_children_are_alive ? 'has ' : 'had ');
					if($numberofchildren == 1) {
						if($all_children_are_alive) {
							$bio .= '1 surviving child';
						} else {
							$bio .= '1 child';
						}
						if($parentofall) {
							$bio .= ' with ' . $parentofall->as_string();
						} else {
							die "BUG: parentofall not set when only one child";
						}
						# TODO: make hyperlink to the persons record, unless surviving
						$bio .= ', ' . $children[0]->given_names();
					} else {
						if($all_children_are_alive) {
							$bio .= "$numberofchildren surviving children";
						} else {
							$bio .= "$numberofchildren children";
						}
						my $childnames;
						if($parentofall) {
							if($numberofchildren == 2) {
								$bio .= ', both with ' . $parentofall->as_string();
							} else {
								$bio .= ', all with ' . $parentofall->as_string();
							}
							# TODO: only add hyperlink to dead children
							$childnames = join(', ', map {
								'<a href="' . make_filename_from_person(person => $_) . '">' .
									$_->given_names() . '</a>'
							} @children);
						} elsif($sex eq 'M') {
							$childnames = join(', ', map {
								my $mother = $_->mother();
								'<a href="' . make_filename_from_person(person => $_) . '">' .
									$_->given_names() . '</a>' .
								' (with ' . 
								'<a href="' . make_filename_from_person(person => $mother) . '">' .
									$mother->given_names() . '</a>' .
								')'
							} @children);
						} else {
							$childnames = join(', ', map {
								my $father = $_->father();
								'<a href="' . make_filename_from_person(person => $_) . '">' .
									$_->given_names() . '</a>' .
								' (with ' . 
								'<a href="' . make_filename_from_person(person => $father) . '">' .
									$father->given_names() . '</a>' .
								')'
							} @children);
						}
						substr($childnames, rindex($childnames, ', '), 2, ' and ');
						$bio .= ": $childnames";
					}
				}
			}
			$end_of_sentence = 0;
		} elsif($numberofchildren) {
			if($end_of_sentence) {
				$bio .= " $pronoun";
			}
			$bio .= ' had ' .
				($numberofchildren == 1) ? '1 child, ' : "$numberofchildren children, ";
			if($numberofchildren == 1) {
				$bio .= $children[0]->given_names();
			} else {
				my $childnames = join(', ', map { $_->given_names() } @children);
				substr($childnames, rindex($childnames, ', '), 2, ' and ');
				$bio .= $childnames;
			}
			$end_of_sentence = 0;
		}
	}

	my $printed_residence = 0;
	my %citationnotes;
	my @residences = $person->residence();
	my @events = $person->event();

	if($opts{'l'} || !$was_alive) {
		# FMP stores Censuses as events
		my $index = 0;
		foreach my $event(@events) {
			$index++;
			if(!ref($event)) {
				my $e = $person->tag_record('EVEN', $index);
				if(ref($e) eq 'Gedcom::Record') {
					$event = $e;
				} else {
					red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
				}
			}
			if((ref($event) eq 'Gedcom::Record') &&
			   ($event->type() =~ /^Census U[KS] (\d{4})$/)) {
			   	my $newresidence = 1;
				foreach my $residence(@residences) {
					if((ref($residence) eq 'Gedcom::Record') &&
					  $residence->date() &&
					  $event->date() &&
					  $residence->date() eq $event->date()) {
						$newresidence = 0;
						last;
					}
				}
				push @residences, $event if($newresidence);
			}
		}

		if(scalar(@residences)) {
			# FIXME, handle duplicate locations better
			my @residencelist;
			my %residencecitations;

			# This is an attempt to handle
			# https://github.com/pjcj/Gedcom.pm/issues/13
			my $index = 0;
			foreach my $residence(@residences) {
				$index++;
				if(!ref($residence)) {
					my $r = $person->tag_record('EVEN', $index);
					if(ref($r) eq 'Gedcom::Record') {
						$residence = $r;
					} else {
						$r = $person->record(['residence', $index]);
						if(ref($r) eq 'Gedcom::Record') {
							$residence = $r;
						} else {
							red_warning({ person => $person, warning => "Residence record is just description ($residence), infomation has been lost" });
						}
					}
				}
				if(ref($residence) eq 'Gedcom::Record') {
					my $place = $residence->place();
					if(my $address = $residence->address()) {
						if($place) {
							$place = "$address, $place";
						} elsif($opts{'f'}) {
							die $person->string(), ": address set to $address but place is empty";
						} else {
							red_warning({
								person => $person,
								warning => "address set to $address but place is empty"
							});
						}
					}
					if(defined($place)) {
						if(my $dor = $residence->date()) {
							if($placeofbirth && $dob && ($dor eq $dob)) {
								next;
							}
							if($placeofmarriage && $dateofmarriage && ($dor eq $dateofmarriage)) {
								next;
							}
						}
						push @residencelist, $residence;
						if(my $src = $residence->source()) {
							$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
							my $note = notes(record => $residence);
							foreach my $c(@birthcitations) {
								if($src eq $citations{$c}) {
									$residencecitations{$residence} = $c;
									if($note) {
										$citationnotes{$c} = $note;
									}
									last;
								}
							}
							unless($residencecitations{$residence}) {
								if($deathcitations[0] && ($src eq $citations{$deathcitations[0]})) {
									$residencecitations{$residence} = $deathcitations[0];
									if($note) {
										$citationnotes{$deathcitations[0]} = $note;
									}
								} else {
									$residencecitations{$residence} = ++$citationcount;
									$citations{$citationcount} = $src;
									if($note) {
										$citationnotes{$citationcount} = $note;
									}
								}
							}
						}
					} elsif(!defined($place)) {
						red_warning({ person => $person, warning => 'Residence record contains no location' });
					}
				}
			}

			# TODO: See RT110333

			# Sort residences chronologically
			# FIXME: This messes citations
			my $all_residences_have_date = 1;
			foreach my $residence(@residencelist) {
				my $date = $residence->date();
				if((!$date) || !defined($date_parser->parse(date => $date))) {
					if($opts{'f'}) {
						die $person->name(), ': Contains a residence without a date';
					}
					red_warning({ person => $person, warning => 'Contains a residence without a date' });
					$all_residences_have_date = 0;
					last;
				}
				$date = $date_parser->parse(date => $date);
				if(scalar(@{$date}) == 0) {
					# e.g. "Apr/May/Jun 2016"
					$all_residences_have_date = 0;
					last;
				}
			}
			if($all_residences_have_date) {
				@residencelist = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @residencelist;
			}
			my $count = 0;
			my $have_printed = 0;
			my $prev_date;
			foreach my $residence(@residencelist) {
				if(($count == 0) || !places_are_the_same({ person => $person, first => $residence, second => $residencelist[$count - 1] })) {
					if($birth && $dob && $residence->date() && ($residence->date() eq $dob) &&
					   places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						# This residence record is for the place of birth, which is
						# printed elsewhere
						$count++;
						next;
					}
					if(!$have_printed) {
						$bio .= '.' unless($end_of_sentence);
						$bio .= ' During ' .
							lc($person->possessive()) .
							' life ' . lcfirst($pronoun) . ' lived';
						$have_printed = 1;
					}
					if($birth && places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						$bio .= ' at ' . ($person->pronoun() eq 'She' ? 'her' : 'his') . ' birthplace';
					} else {
						my $p = place({
							person => $person,
							record => $residence,
							places_printed => \%places_printed
						});
						$places_printed{$p} = 1;
						$bio .= HTML::Entities::encode($p);
						$places_printed{$p} = 1;
						$place_records{"Residence/$count"} = $residence;
					}
				}
				# Citation residence notes print later
				if((!$opts{'c'}) && (my $notes = notes({ record => $residence }))) {
					$notes =~ s/\.$//;
					$notes = lcfirst($notes);
					$bio .= " ($notes)";
				}
				if(my $date = $residence->date()) {
					my $this_date = year({ person => $person, date => $date });
					if($prev_date && ($prev_date eq $this_date)) {
						if($opts{'f'}) {
							die $person->name(), "Two residence records for $date";
						}
						red_warning({ person => $person, warning => "two residence records for $date" });
					}
					$bio .= " $this_date";
					$prev_date = $this_date;
					# Find if they are an adult living with an adult sibling
					if(scalar(@siblings) && $birth_dt && $residence->address()) {
						my $diff = $dfn->parse_datetime($date) - $birth_dt;
						if($diff->in_units('years') >= 40) {
							# Safe to assume both are adults at this time
							foreach my $sibling(@siblings) {
								my @srs = $sibling->residence();
								foreach my $sr(@srs) {
									if((ref($sr) eq 'Gedcom::Record') &&
									   $sr->date() && ($sr->date() eq $date) &&
									   places_are_the_same({ first => $residence, second => $sr })) {
										$bio .= ' when ' .
											lcfirst($person->pronoun()) .
											' was living with ' .
											lcfirst($person->possessive()) .
											($sibling->sex() eq 'F') ? ' sister, ' : ' brother, ' .
											'<a href="' . make_filename_from_person(person => $sibling) . '">' .
												$sibling->given_names() .
											'</a>';
									}
								}
							}
						}
					}
				}
				if($residencecitations{$residence}) {
					$bio .= '[' . $residencecitations{$residence} . ']';
				}
				if($residence->place() &&
				  (!$residence->date()) &&
				  ($count <= (scalar(@residencelist) - 1)) &&
				  ($residencecitations{$residence})) {
					my $peek = $residencelist[$count + 1];
					if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
						if($residencecitations{$peek}) {
							$bio .= '[' . $residencecitations{$peek} . ']';
						}
					}
				}
				$count++;
				if($count < (scalar(@residencelist) - 1)) {
					$bio .= ';';
				} elsif($count == (scalar(@residencelist) - 1)) {
					if($count > 1) {
						$bio .= ';';
					}
					$bio .= ' and';
				}
				$printed_residence = 1;
			}
			if($printed_residence) {
				$bio .= '.';
				$end_of_sentence = 1;
			}
		}
	} else {
		print $csv '.!!!';
	}

	if($placeofburial || $dateofburial) {
		if((!$dateofdeath) && !$placeofdeath) {
			$bio .= '.' if((!$end_of_sentence) && (scalar(@spouses) || $numberofchildren));
			if($dateofburial) {
				$bio .= " $pronoun was buried " .
					year({ person => $person, date => $dateofburial });
				if($placeofburial) {
					if($placeofbirth && ($placeofburial eq $placeofbirth)) {
						$bio .= ' in ' .
							lcfirst($person->possessive()) .
							' home town of ';
						my $city = $placeofburial;
						if($city =~ /^(.+?),/) {
							$bio .= $1;
						} else {
							my $opts = {
								person => $person,
								place => $placeofburial,
								there => $placeofdeath,
								places_printed => \%places_printed,
								must_postdate => $birth_dt
							};
							if(my $address = $burial->address()) {
								$opts->{'address'} = $address;
							}
							$bio .= place($opts);
						}
					} else {
						$bio .= place({ person => $person, place => $placeofburial, there => $placeofdeath, places_printed => \%places_printed, must_postdate => $birth_dt });
					}
				}
				my $b = get_value({ person => $person, value => 'burial note' });
				if($b) {
					$b =~ tr/\r//;
					$bio .= " ($b)";
				}
			} elsif($placeofbirth && ($placeofburial eq $placeofbirth)) {
				$bio .= " $pronoun was buried in " .
					lcfirst($person->possessive()) .
					' home town of ';
				my $city = $placeofburial;
				if($city =~ /^(.+?),/) {
					$bio .= $1;
				} else {
					$bio .= place({ person => $person, place => $placeofburial });
				}
			} else {
				$bio .= " $pronoun is buried",
					place({ person => $person, record => $burial, places_printed => \%places_printed, there => $placeofmarriage });
			}
			$end_of_sentence = 0;
		} elsif($dateofdeath || $placeofdeath) {
			$bio .= '.' if(!$end_of_sentence);
			$bio .= " $pronoun died";
			if($dateofdeath) {
				$bio .= ' ' . year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
			}
			if($placeofdeath) {
				my $p = place({ person => $person, record => $death, places_printed => \%places_printed });
				$bio .= $p;
				$places_printed{$p} = 1;
			}
			if(my $d = get_value({ person => $person, value => 'death' })) {
				$d =~ tr/\r//;
				$d =~ tr/\n/ /;
				$d =~ s/\.$//;
				$bio .= ' (' . HTML::Entities::encode($d) . ')';
			}
			$bio .= "[$_]" foreach(@deathcitations);
			my $opts = {
				person => $person,
				place => $placeofburial,
				there => $placeofdeath,
				places_printed => \%places_printed,
				must_postdate => $birth_dt,
			};
			# if(my $address = $burial->address()) {
			if(my $address = get_value({ person => $person, value => 'burial address' })) {
				$opts->{'address'} = $address;
			}
			if($dateofburial) {
				$bio .= ' and was buried';
				if($placeofburial) {
					$bio .= place($opts);
				}
				$bio .= ' ' . year({ person => $person, date => $dateofburial });
				if(my $b = get_value({ person => $person, value => 'burial note' })) {
					$b =~ tr/\r//;
					$bio .= " ($b)";
				}
			} else {
				$bio .= ' and is buried' . place($opts);
			}
			$end_of_sentence = 0;
		}
		$bio .= "[$_]" foreach(@burialcitations);
	} elsif($placeofdeath || $dateofdeath) {
		# TODO - extract marriage banns information
		if($person->marriage_bann()) {
			# die 'foo';
		}
		if($placeofdeath && (scalar(@spouses) <= 1) && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
			if($end_of_sentence) {
				$bio .= 'That';
			} else {
				$bio .= ', which';
			}
			$bio .= ' is also where ' . lcfirst($pronoun);
		} else {
			$bio .= '.' if(!$end_of_sentence);
			$bio .= " $pronoun";
		}
		$bio .= ' died';
		if($dateofdeath) {
			if($dateofbirth && ($dateofdeath eq $dateofbirth)) {
				$bio .= ' on the same day';
			} elsif($placeofdeath && $placeofmarriage && (scalar(@spouses) == 1) && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
				$bio .= ' ' . year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
			} elsif($placeofbirth && $placeofdeath && ($placeofdeath eq $placeofbirth) && ($placeofdeath =~ /^(.+?),.*/) && !$printed_residence) {
				$bio .= " in $1 " .
					year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
			} else {
				$bio .= ' ' . year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
				if($placeofdeath && ((scalar(@spouses) > 1) || (!$placeofmarriage) || ($placeofdeath ne $placeofmarriage) || $printed_residence)) {
					$bio .= place({ person => $person, record => $death, places_printed => \%places_printed });
				}
			}
		} elsif((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage)) {
			$bio .= place({ person => $person, place => $placeofdeath });
		}
		$bio .= "[$_]" foreach(sort @deathcitations);

		# Print notes about the death, if any
		if(defined($death) && (my $d = get_value({ person => $person, value => 'death' }))) {
			$d =~ tr/\r//;
			$d =~ s/\.$//;
			$bio .= ' (' . HTML::Entities::encode($d) . ')';
		}
		$end_of_sentence = 0;
	}
	$bio .= '.' if(!$end_of_sentence);
	$end_of_sentence = 1;

	if((scalar(@events) == 2) &&
	   (ref($events[0]) eq 'Gedcom::Record') &&
	   (ref($events[1]) eq 'Gedcom::Record') &&
	   ((($events[0]->type() eq 'Arrival') && ($events[1]->type() eq 'Departure')) ||
	    (($events[1]->type() eq 'Arrival') && ($events[0]->type() eq 'Departure')))) {
		# Simple case - one journey made
		$bio .= '. ' if(!$end_of_sentence);
		$bio .= ' ';

		my $arrival = ($events[0]->type() eq 'Arrival') ? $events[0] : $events[1];
		my $departure = ($events[0]->type() eq 'Departure') ? $events[0] : $events[1];
		my $yod;
		my $yoa;
		my $dod = $departure->date();
		my $doa = $arrival->date();
		if($doa && $dod && ($doa =~ /(\d{3,4})/)) {
			$yoa = $1;
			$doa =~ s/\s?\d{3,4}//;
			if($dod =~ /(\d{3,4})/) {
				$yod = $1;
				$dod =~ s/\s?\d{3,4}//;
				if($dod =~ /^\d/) {
					$dod = "on $dod";
				} else {
					$dod = "during $dod";
				}
				if($doa =~ /^\d/) {
					$doa = "on $doa";
				} else {
					$doa = "during $doa";
				}
			}
		}
		if($departure || !$doa) {
			if($yod && $yoa && ($yod == $yoa)) {
				$bio .= "During $yod " . lc($person->pronoun());
			} else {
				$bio .= $person->pronoun();

				# $yod = year({ person => $person, record => $departure });
				# $yoa = year({ person => $person, record => $arrival });
			}

			if($ENV{'LANG'} =~ /^en_US/) {
				$bio .= ' traveled';
			} else {
				$bio .= ' travelled';
			}

			$bio .= ' from ' .
				$departure->place() .
				' to ' .
				$arrival->place();

			if(defined($dod)) {
				$bio .= ", departing $dod and";
			}

			$bio .= " arriving $doa. ";

			if($ENV{'LANG'} =~ /^en_US/) {
				$place_records{'Traveled from'} = $departure;
				$place_records{'Traveled to'} = $arrival;
			} else {
				$place_records{'Travelled from'} = $departure;
				$place_records{'Travelled to'} = $arrival;
			}
		} else {
			$bio .= ucfirst(year({ person => $person, record => $arrival })) .
				' ' . lcfirst($person->pronoun()) .
				' arrived' .
				place({ person => $person, record => $arrival });

			if(my $notes = notes({ record => $arrival, person => $person })) {
				$notes = lcfirst($notes);
				$bio .= " ($notes)";
			}
			print '.';
			if($ENV{'LANG'} =~ /^en_US/) {
				$place_records{'Traveled to'} = $arrival;
			} else {
				$place_records{'Travelled to'} = $arrival;
			}
		}
		$end_of_sentence = 1;
	} elsif(scalar(@events) == 1) {
		$bio .= '.' if(!$end_of_sentence);
		$end_of_sentence = 1;

		my $event = $person->event();
		if(!ref($event)) {
			my $e = $person->tag_record('EVEN');
			if(ref($e) eq 'Gedcom::Record') {
				$event = $e;
			} else {
				red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
				$bio .= ' ' . ucfirst($event) . '.';
			}
		}
		if(ref($event) eq 'Gedcom::Record') {
			my $type = $event->type();
			if($type eq 'Arrival') {
				$bio .= ' ' . $person->pronoun() . ' arrived' .
					place({ person => $person, record => $events[0] }) .
					' ' .
					year({ person => $person, record => $events[0] }) .
					'.';
				if($ENV{'LANG'} =~ /^en_US/) {
					$place_records{'Traveled to'} = $event;
				} else {
					$place_records{'Travelled to'} = $event;
				}
			} elsif($type eq 'Military service') {
				$bio .= '.' if(!$end_of_sentence);
				$bio .= " $pronoun served in the military";
				if(my $place = place({ person => $person, record => $event })) {
					$bio .= $place;
				}
				if(my $date = year(record => $event)) {
					$bio .= " $date";
				}

				if(my $notes = notes(record => $event)) {
					$notes = lcfirst($notes) unless($notes eq 'RAF');
					$notes =~ s/\.$//;
					$bio .= " ($notes)";
				}
				$end_of_sentence = 0;
			} elsif(($type !~ /^Census U[KS] (\d{4})$/) && ($type ne 'Race')) {
				red_warning({ person => $person, warning => "Unhandled event type: $type" });
				if(my $notes = notes(record => $event)) {
					$notes = ucfirst($notes);
					$bio .= " ($notes)";
					$end_of_sentence = 0;
				}
			}
		}
	} else {
		my $mentioned_military;
		my $index = 0;
		my $previous;
		foreach my $event(@events) {
			$index++;
			if(!ref($event)) {
				my $e = $person->tag_record('EVEN', $index);
				if(ref($e) eq 'Gedcom::Record') {
					$event = $e;
				} else {
					red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
					$bio .= ' ' . ucfirst($event) . '.';
				}
			}
			if(ref($event) eq 'Gedcom::Record') {
				my $type = $event->type();
				if($type eq 'Military service') {
					if(!$mentioned_military) {
						$bio .= '.' if(!$end_of_sentence);
						$bio .= " $pronoun served in the military";
						if(my $place = place({ person => $person, record => $event })) {
							$bio .= $place;
						}
						if(my $date = year(record => $event)) {
							$bio .= " $date";
						}
						$mentioned_military = 1;
					}

					if(my $notes = notes(record => $event)) {
						$notes = lcfirst($notes);
						$notes =~ s/\.$//;
						$bio .= " ($notes)";
					}
					$end_of_sentence = 0;
				} elsif($type eq 'Arrival') {
					if($events[$index] && ($events[$index]->type() eq 'Arrival') && $event->date()) {
						if($events[$index]->date()) {
							$previous = $event;
							next;
						}
					}
					if($previous) {
						my $date1 = year({ record => $previous });
						my $date2 = year({ record => $event });
						my $year1;
						my $year2;
						if($date1 =~ /(.*)\s?(\d{4})$/) {
							$date1 = $1;
							$year1 = $2;
							$date1 =~ s/,\s//;
						}
						if($date2 =~ /(.*)\s?(\d{4})$/) {
							$date2 = $1;
							$year2 = $2;
							$date2 =~ s/,\s//;
						}
						$bio .= '.  ' if(!$end_of_sentence);
						if(defined($year1) && defined($year2) && ($year1 == $year2)) {
							$bio .= "During $year1 " . lcfirst($pronoun) . ' arrived' .
								place({ person => $person, record => $previous, nopreposition => 1 }) .
								" $date1 and" .
								place({ person => $person, record => $event, nopreposition => 1 }) .
								" $date2.";
						} else {
							$bio .= ucfirst(year({ person => $person, record => $previous })) .
								' ' . lcfirst($person->pronoun()) .
								' arrived' .
								place({ person => $person, record => $previous }) .
								' and ' .
								year({ person => $person, record => $event }) .
								' ' . lcfirst($person->pronoun()) .
								' arrived' .
								place({ person => $person, record => $event }) . '.';
						}
						$previous = undef;
					} else {
						$bio .= ucfirst(year({ person => $person, record => $event })) .
							' ' . lcfirst($person->pronoun()) .
							' arrived' .
							place({ person => $person, record => $event }) . '.';
					}
					$end_of_sentence = 1;
				} elsif(($type !~ /^Census U[KS] (\d{4})$/) &&
					($type ne 'Race')) {
					red_warning({ person => $person, warning => "Unhandled event type: $type" });
				}
			}
		}
		$bio .= '.' if(!$end_of_sentence);
		$end_of_sentence = 1;
	}

	if(my $profile_object = $person->tag_record('_MILT')) {
		# $person->resolve_xref($profile_object->value());
		if(my $value = $profile_object->get_value()) {
			$bio .= '.' if(!$end_of_sentence);
			$bio .= "  $pronoun served in the military ($value).";
			$end_of_sentence = 1;
		}
	}

	if(defined($ENV{'LANG'})) {
		if($ENV{'LANG'} =~ /^en_US/) {
			$bio = Lingua::EN::ABC::b2a($bio);
		} elsif($ENV{'LANG'} =~ /^en_GB/) {
			$bio = Lingua::EN::ABC::a2b($bio);
		}
	}

	print $html $bio;
	if($opts{'l'} || !$was_alive) {
		print $csv $bio;
	}
	print $csv '!';

	if($opts{'l'} || !$was_alive) {
		print $html '</p>';
		if($mother || $father) {
			print $html "<h2>Parents</h2><ol>";
			if($father && (my $f = person_line_html({ person => $father, year => $year }))) {
				print $html "<li>$f</li>";
				print $csv person_line_csv({ person => $father, year => $year });
			}
			print $csv '!';
			if($mother && (my $m = person_line_html({ person => $mother, year => $year }))) {
				print $html "<li>$m</li>";
				print $csv person_line_csv({ person => $mother, year => $year });
			}
			print $html '</ol>';
		} else {
			print $csv '!';
		}
		print $csv '!';
		print $html '<h2>Children</h2><ol>' if(@children);

		my $c = '';
		foreach my $child(@children) {
			my $line = person_line_html({ person => $child, year => $year });
			print $html "<li>$line</li>";
			if($c) {
				$c .= '----' . person_line_csv({ person => $child, year => $year });
			} else {
				$c = person_line_csv({ person => $child, year => $year });
			}
			if($opts{'w'} && ($birth_dt || $death_dt)) {
				my $dob = get_value({ person => $child, value => 'birth date' });
				if($dob && ($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/)) {
					my $d;
					eval {
						$d = $date_parser->parse(date => $dob);
					};
					if($d) {
						$d = @{$d}[0];
					}
					if($d) {
						$d = $dfn->parse_datetime($d->{'canonical'});
						if($birth_dt && ($d <= $birth_dt)) {
							if($opts{'f'}) {
								die $child->name(), ': Born before parent was born';
							}
							red_warning({ person => $child, warning => 'born before parent was born' });
						}
						if(($sex eq 'F') && $death_dt && ($d > $death_dt)) {
							if($opts{'f'}) {
								die $child->name(), ': Born after mother died';
							}
							red_warning({ person => $child, warning => 'born after mother died' });
						} elsif(($sex eq 'M') && $death_dt && ($d > ($death_dt + $ninemonths))) {
							# Allow the child to be
							# born up to 9 months
							# after the death of the
							# father
							if($opts{'f'}) {
								die $child->name(), ': Born more than 9 months after father died';
							}
							red_warning({ person => $child, warning => 'born more than 9 months after father died' });
						}
					}
				}
			}
		}
		print $html '</ol>' if(@children);
		print $csv $c;
	} else {
		print $csv '!!';
	}

	print $csv '!';

	if($opts{'l'} || !$was_alive) {
		my $ufinder = URI::Find::Schemeless->new(sub {
			my($uri, $orig_uri) = @_;

			my $u = URI->new($orig_uri);
			if($u && (ref($u) ne 'URI::_generic')) {
				if(!head($orig_uri)) {
					if($opts{'f'}) {
						die $person->as_string, ": $orig_uri: not found";
					}
					red_warning({ person => $person, warning => "$orig_uri: not found" });
				}
				$uri =~ s/:$//;
				return "<a HREF=\"$uri\">" .
					$u->host() .
					'</a>';
			}
			return $orig_uri;
		});

		if($opts{'c'} && $citationcount) {
			print $html '<h2>Citations</h2><ol>';
			foreach my $citation(1..$citationcount) {
				if(!$citations{$citation}) {
					if($opts{'f'}) {
						die $person->as_string(), "[$citation]: empty citation";
					}
					if($opts{'w'}) {
						red_warning({
							person => $person,
							warning => "[$citation]: empty citation"
						});
					}
					next;
				}
				my $title = $citations{$citation}->title();
				if(!defined($title)) {
					if($opts{'f'}) {
						die $person->as_string, "[$citation]: no citation title";
					}
					red_warning({
						person => $person,
						warning => "[$citation]: no citation title"
					});
					next;
				}
				my $c;
				if(my $file = $citations{$citation}->file()) {
					$c = "<a href=\"$file\">" . HTML::Entities::encode($title) . '</a>';
				} else {
					$c = HTML::Entities::encode($title);
					if($title =~ /Census/) {
						my $census = $censusmaps{$title};
						die "Add $title to censusmaps" unless($census);
						# TODO: Add pointer to image
						$censuses{$census}->{$person->as_string(include_years => 1)} = $person;
					}
				}
				if(defined(my $publication = $citations{$citation}->publication())) {
					$c .= ' ' . HTML::Entities::encode($publication);
					if(defined(my $continuation = $citations{$citation}->cont())) {
						$c .= ' ' . HTML::Entities::encode($continuation);
					}
				}
				if(defined(my $page = $citations{$citation}->page())) {
					$c .= " $page";
				}
				my @notes = $citations{$citation}->note();
				foreach my $note(@notes) {
					if(ref($note) eq 'Gedcom::Record') {
						$note = $note->note();
					}

					if($note && ($note !~ /^This information comes from/)) {
						$ufinder->find(\$note);
						$c .= " ($note)";
					}
				}
				if($citationnotes{$citation}) {
					$citationnotes{$citation} =~ s/\.$//;
					$c .= " ($citationnotes{$citation})";
				}

				print $html "<li>$c</li>";
				print $csv '----' if($citation > 1);
				print $csv $c;
			}
			print $html '</ol>';
		}

		print $csv '!';

		my $printed_notes;
		# if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 1 }))) {
			# print $html "<h2>Notes</h2>$notes";
			# $printed_notes = 1;
			# print $csv notes({ person => $person, record => $death });
		# }

		if($person->get_value('note')) {
			print $html "<h2>Notes</h2>" unless($printed_notes);

			if(my $notes = notes({ person => $person, paragraph => 1, record => $person })) {
				print $html $notes;
				print $csv '----' if($printed_notes);
				print $csv notes({ person => $person, record => $person });
			}
			# print $html map { "<p>$_</p>" } @notes;
		}

		print $csv '!';

		# FIXME: Should be a table mapping from records to profiles
		my $profile_image;

		# print 'f:', $person->form() if($person->form());

		if($person->obje()) {
			# TODO - find primary and do something different with that
			#	The obje should be in order with primary first, but FMP
			#	doesn't do that
			#	Gedcom doesn't seem to be able to handle extra _ tags,
			#	or if it can I can't work out how to make use of it
			warn $person->{"_prof"}, "\n" if($person->{'_prof'});
			warn $person->{"prof"}, "\n" if($person->{'prof'});
			warn $person->{"_PROF"}, "\n" if($person->{'_PROF'});
			warn $person->{"PROF"}, "\n" if($person->{'PROF'});
			warn $person->{"_prim"}, "\n" if($person->{'_prim'});
			warn $person->{"prim"}, "\n" if($person->{'prim'});
			warn $person->{"_PRIM"}, "\n" if($person->{'_PRIM'});
			# warn $person->tag_records("PRIM"), "\n" if($person->tag_records('PRIM'));
			# warn $person->tag_records("_PRIM"), "\n" if($person->tag_records('_PRIM'));
			# warn $person->get_value("_prof"), "\n" if($person->get_value('_prof'));
			# warn $person->get_value("prof"), "\n" if($person->get_value('prof'));
			# warn $person->get_value("_PROF"), "\n" if($person->get_value('_PROF'));
			# warn $person->get_value("PROF"), "\n" if($person->get_value('PROF'));
			# warn $person->get_value("_prim"), "\n" if($person->get_value('_prim'));
			# warn $person->get_value("prim"), "\n" if($person->get_value('prim'));
			# warn $person->get_value("_PRIM"), "\n" if($person->get_value('_PRIM'));
			my $profile_object = $person->tag_record('_PROF');
			if($profile_object) {
				$profile_object = $person->resolve_xref($profile_object->value());
			}
			my $printed_media_header = 0;
			foreach my $o($person->obje()) {
				my $obje = $ged->resolve_xref($o);
				next if(!defined($obje));
				if(my $file = $obje->file()) {
					if(ref($file) eq 'Gedcom::Record') {
						# warn $file->tag(), "\n" if($file->tag());
						$file = $file->{'file'};
						next if($file eq '*');
					}
					if(!$printed_media_header) {
						print $html '<h2>Media</h2>';
						$printed_media_header = 1;
					}

					warn $obje->{"_prim"}, "\n" if($obje->{'_prim'});
					warn $obje->{"prim"}, "\n" if($obje->{'prim'});
					warn $obje->{"_PRIM"}, "\n" if($obje->{'_PRIM'});
					warn $obje->{"PRIM"}, "\n" if($obje->{'PRIM'});
					warn $obje->{"_prof"}, "\n" if($obje->{'_prof'});
					warn $obje->{"prof"}, "\n" if($obje->{'prof'});
					warn $obje->{"_PROF"}, "\n" if($obje->{'_PROF'});
					warn $obje->{"PROF"}, "\n" if($obje->{'PROF'});
					warn $obje->{"_DATE"}, "\n" if($obje->{'_DATE'});
					warn $obje->{"_date"}, "\n" if($obje->{'_date'});
					# warn $obje->tag(), "\n" if($obje->tag());
					my $title = $obje->title();
					my $form = $obje->form();
					if((!$form) && $obje->items()) {
						# Family Tree Maker does this
						my @items = $obje->items();
						$file = $items[0]->{'value'};
						# TODO: Find the title
					}
					$file =~ s/\{0\}//g;
					$file =~ s/\r//g;
					if($opts{'d'} && ($file =~ /^https?:\/\//) && ($file !~ /\.jpe?g$/)) {
						$file =~ s/%2f/\//gi;

						my $localfile = 'static-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
						# FIXME: It should check if the remote image is newer than the local image
						if(!-r $localfile) {
							my $browser = LWP::UserAgent->new();
							$browser->env_proxy(1);
							my $resp = $browser->get($file);
							if($resp->is_success && ($resp->content_type() eq 'image/jpeg')) {
								my $key = $person->as_string() . ";$localfile";
								if($images{$key}) {
									# Flag a person having two images of the same
									# name
									if($opts{'f'}) {
										die $person->as_string(), ': ', $localfile, ' duplicate filename';
									}
									red_warning({ person => $person, warning => "duplicate filename: " . $obje->title() });
								}
								my $tmp;
								if($jpegtran) {
									open($tmp, '|-', "$jpegtran -progressive -outfile '$localfile'");
								} elsif($jpegoptim) {
									open($tmp, '|-', "$jpegoptim -q --all-progressive --stdin > '$localfile'");
								} else {
									open($tmp, '>', $localfile);
								}
								print $tmp $resp->decoded_content();
								close $tmp;
								$form = 'JPG';
								$images{$key} = 1;
								link $localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
							}
						}
					} elsif(($file =~ /^([A-Z]:[\/\\].+\.jpe?g+)/) || ($file =~ /^(\/.+\.jpe?g)/)) {
						my $srcfile = $1;
						my $localfile = 'static-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
						if(!-r $localfile) {
							if($jpegtran) {
								system("$jpegtran -progressive -outfile '$localfile' '$srcfile'");
							} elsif($jpegoptim) {
								copy($srcfile, $localfile);
								system("$jpegoptim -q --all-progressive '$localfile'");
							} else {
								copy($srcfile, $localfile);
							}
							link $localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
						}
						$form = 'JPG';
						my $key = $person->as_string() . ";$localfile";
						$images{$key} = 1;
					}
					if($form && ($form eq 'JPG')) {
						if($title) {
							print $html "<h3>$title</h3>";
						} else {
							print $html '<br>';
						}
						if($opts{'d'}) {
							# Get and stash a local copy
							my $localfile = 'img/' . make_filename_from_object(object => $obje) . '.jpg';
							if((-r "static-site/$localfile") ||
							   is_success(getstore($file, "static-site/$localfile"))) {
								my $info = Image::Info::image_info("static-site/$localfile");
								my ($w, $h) = Image::Info::dim($info);
								if(!defined($w)) {
									die "static-site/$localfile";
								}
								$h *= 175 / $w;
								$h = int($h);
								# print $html "<a href=\"$file\" target=\"_blank\">",
								if($title) {
									print $html "<a href=\"$localfile\" target=\"_blank\">",
										'<img src="', $localfile, "\" alt=\"$title\" width=\"175\" height=\"$h\">",
										'</a>';
									print $csv "/$localfile---$title---$h----";
								} else {
									print $html "<a href=\"$localfile\" target=\"_blank\">",
										'<img src="', $localfile, "\" width=\"175\" height=\"$h\">",
										'</a>';
									print $csv "/$localfile--- ---$h----";
								}
								if(defined($profile_object) && ($obje eq $profile_object)) {
									$profile_image = "static-site/$localfile";
								}
								unless(-r "dynamic-site/$localfile") {
									link "static-site/$localfile", "dynamic-site/$localfile";
								}
							} else {
								red_warning({ person => $person, warning => "static-site/$localfile: $!" });

								print $html "<a href=\"$file\" target=\"_blank\">",
									"<img src=\"$file\" alt=\"$title\" width=\"175\">",
									'</a>';
								print $csv "$file---$title---0----";
								if(defined($profile_object) && ($obje eq $profile_object)) {
									$profile_image = $file;
								}
							}
						} else {
							# Use the remote copy
							print $html "<a href=\"$file\" target=\"_blank\">",
								"<img src=\"$file\" alt=\"$title\" width=\"175\">",
								'</a>';
							print $csv "$file---$title---0----";
							if(defined($profile_object) && ($obje eq $profile_object)) {
								$profile_image = $file;
							}
						}
					} else {
						print $html "<a href=\"$file\" target=\"_blank\">",
							$title ? HTML::Entities::encode($title) : 'Media',
							'</a>';
						print $csv "$file---",
							$title ? HTML::Entities::encode($title) : 'Media',
							'---0----';
					}
					# if($obje->date()) {
						# die $obje->date();
					# }
					print $html '<br>';
				}
			}
		}
		print $csv '!';

		if(defined($dot)) {
			my $png = 'static-site/img/' . make_filename_from_object(object => $person) . '.png';
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/bin/cat')) {
				# print $fout 'digraph family { graph [rankdir=LR];';
				print $fout 'digraph family {',
					' subgraph parents { rank="min"; ';
				if($father) {
					print_graphviz({ person => $father, fout => $fout, format => 'static' });
				}
				if($mother) {
					print_graphviz({ person => $mother, fout => $fout, format => 'static' });
				}
				print $fout '} subgraph main { rank="same"; ';
				print_graphviz({ person => $person, fout => $fout, profile_image => $profile_image, format => 'static' });
				foreach my $spouse(@spouses) {
					print_graphviz({ person => $spouse, fout => $fout, format => 'static' });
				}
				print $fout '} subgraph children { rank="max"; ';
				# TODO: sort by date of birth
				foreach my $child(@children) {
					print_graphviz({ person => $child, fout => $fout, format => 'static' });
				}
				print $fout '} ';

				if($mother) {
					print $fout $mother->{'xref'}, ' -> ', $person->{'xref'}, ";\n";
				}
				if($father) {
					print $fout $father->{'xref'}, ' -> ', $person->{'xref'}, ";\n";
				}
				if(scalar(@spouses) == 2) {
					# Married twice, put the person in the middle,
					# it looks better
					# print $fout $person->{'xref'}, ' -> ', $spouses[0]->{'xref'}, " [dir=none];\n";
					print $fout $spouses[0]->{'xref'}, ' -> ',
						$person->{'xref'}, ' -> ',
						$spouses[1]->{'xref'}, " [dir=none];\n";
				} else {
					foreach my $spouse(@spouses) {
						print $fout $person->{'xref'}, ' -> ', $spouse->{'xref'}, " [dir=none];\n";
						# print $fout $person->{'xref'}, ' -> ', $spouse->{'xref'}, " [dir=none];\n";
					}
				}
				foreach my $child(@children) {
					print $fout $person->{'xref'}, ' -> ', $child->{'xref'}, ";\n";
				}

				print $fout '}';
				close $fout;

				print $html '<h2>Family Tree</h2>';
				my $filename = make_filename_from_object(object => $person);
				my $dim = Image::Info::html_dim(Image::Info::image_info($png));
				print $html "<img src=\"img/$filename.png\" $dim", ' usemap="#family" alt="Family Tree">';
				$tmp->seek(0, SEEK_SET);
				foreach my $line(<$tmp>) {
					chomp $line;
					print $html $line;
				}
			}
			$png = "dynamic-site/img/" . make_filename_from_object(object => $person) . '.png';
			$tmp = File::Temp->new();
			$filename = $tmp->filename();
			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/bin/cat')) {
				# print $fout 'digraph family { graph [rankdir=LR];';
				print $fout 'digraph family {',
					' subgraph parents { rank="min"; ';
				if($father) {
					print_graphviz({ person => $father, fout => $fout, format => 'dynamic' });
				}
				if($mother) {
					print_graphviz({ person => $mother, fout => $fout, format => 'dynamic' });
				}
				print $fout '} subgraph main { rank="same"; ';
				my $d_profile = $profile_image;
				if(defined($d_profile)) {
					$d_profile =~ s/static/dynamic/;
				}
				print_graphviz({ person => $person, fout => $fout, profile_image => $d_profile, format => 'dynamic' });
				foreach my $spouse(@spouses) {
					print_graphviz({ person => $spouse, fout => $fout, format => 'dynamic' });
				}
				print $fout '} subgraph children { rank="max"; ';
				# TODO: sort by date of birth
				foreach my $child(@children) {
					print_graphviz({ person => $child, fout => $fout, format => 'dynamic' });
				}
				print $fout '} ';

				if($mother) {
					print $fout $mother->{'xref'}, ' -> ', $person->{'xref'}, ";\n";
				}
				if($father) {
					print $fout $father->{'xref'}, ' -> ', $person->{'xref'}, ";\n";
				}
				if(scalar(@spouses) == 2) {
					# Married twice, put the person in the middle,
					# it looks better
					# print $fout $person->{'xref'}, ' -> ', $spouses[0]->{'xref'}, " [dir=none];\n";
					print $fout $spouses[0]->{'xref'}, ' -> ',
						$person->{'xref'}, ' -> ',
						$spouses[1]->{'xref'}, " [dir=none];\n";
				} else {
					foreach my $spouse(@spouses) {
						print $fout $person->{'xref'}, ' -> ', $spouse->{'xref'}, " [dir=none];\n";
						# print $fout $person->{'xref'}, ' -> ', $spouse->{'xref'}, " [dir=none];\n";
					}
				}
				foreach my $child(@children) {
					print $fout $person->{'xref'}, ' -> ', $child->{'xref'}, ";\n";
				}

				print $fout '}';
				close $fout;

				my $filename = make_filename_from_object(object => $person);
				my $dim = Image::Info::html_dim(Image::Info::image_info($png));
				print $csv "/img/$filename.png---$dim---";
				$tmp->seek(0, SEEK_SET);
				foreach my $line(<$tmp>) {
					chomp $line;
					print $csv $line;
				}
			}
		} elsif(defined($dot)) {
			if($opts{'f'}) {
				die "$dot: $!";
			} else {
				red_warning(warning => "$dot: $!");
			}
		}
	}
	print $csv '!';

	if($person->{'warnings'}) {
		my $ufinder = URI::Find::Schemeless->new(sub {
			my($uri, $orig_uri) = @_;

			my $u = URI->new($orig_uri);
			if($u && (ref($u) ne 'URI::_generic')) {
				$uri =~ s/:$//;
				return "<a href=\"$uri\">" .
					$u->host() .
					'</a>';
			}
			return $orig_uri;
		});
		print $html "<h2>Known Issues</h2>",
			map { $ufinder->find(\$_); '<p>' . HTML::Entities::encode($_) . '</p>' } @{$person->{'warnings'}};
		print $csv
			map { $ufinder->find(\$_); '<p>' . HTML::Entities::encode($_) . '</p>' } @{$person->{'warnings'}};
	}
	print $csv '!';

	my @place_events = keys %place_records;
	if($opts{'m'} && ($opts{'l'}|| !$was_alive) && scalar(@place_events)) {
		my $map;
		my $current_place;
		my $annotation;
		# Sort put all events at a place on the same pointer
		foreach my $event(sort @place_events) {
			my $record = $place_records{$event};
			my $place = place({ record => $record });
			if($place =~ /,.+,/) {
				$place =~ s/^\s(at|in)\s//;
				if(defined($current_place) && ($place ne $current_place)) {
					if(!defined($map)) {
						my %args;
						if($opts{'M'}) {
							$args{'api_key'} = $opts{'M'};
						}
						$map = HTML::GoogleMaps::V3->new(%args);
						$map->center($current_place);
						Time::HiRes::usleep(100000);
					}
					if($annotation) {
						$map->add_marker(point => $current_place, html => "$current_place<br>$annotation");

						$annotation = undef;
					} else {
						$map->add_marker(point => $current_place, html => $current_place);
					}
					$current_place = $place;
					Time::HiRes::usleep(100000);
				}
				if(!defined($current_place)) {
					$current_place = $place;
				}
				my $text = $event;
				$text =~ s/\/.+//;	# Remove count e.g. when more than one residence
				if($record->date()) {
					$text .= ' ' . year({ person => $person, record => $record });
				}
				if(my $note = $record->note()) {
					$note =~ s/\n/<br>/gs;
					$text .= "<br>$note";
				}
				$annotation .= "<p>$text</p>";
			}
		}
		if($current_place) {
			if(!defined($map)) {
				my %args;
				if($opts{'M'}) {
					$args{'api_key'} = $opts{'M'};
				}
				$map = HTML::GoogleMaps::V3->new(%args);
				$map->center($current_place);
				Time::HiRes::usleep(100000);
			}
			if($annotation) {
				$map->add_marker(point => $current_place, html => "$current_place<br>$annotation");
			} else {
				$map->add_marker(point => $current_place, html => $current_place);
			}
			Time::HiRes::usleep(100000);
		}
		if(defined($map)) {
			# Can't put $head into the head since it's far too
			# late now!
			my ($head, $map_div) = $map->onload_render();
			$head =~ s/http:/https:/;
			print $html "$head<h2>Map</h2>$map_div\n";
			print $csv MIME::Base64::encode_base64url($head), '!', MIME::Base64::encode_base64url($map_div), '!';
		} else {
			print $csv '!!';
		}
	} else {
		print $csv '!!';
	}
	if($birth_dt) {
		print $csv $birth_dt->strftime('%Y/%m/%d');
	}
	print $csv '!';
	if($death_dt) {
		print $csv $death_dt->strftime('%Y/%m/%d');
	}

	my $dt;
	if($ENV{'LANG'}) {
		$dt = DateTime->now(locale => $ENV{'LANG'});
	} else {
		$dt = DateTime->now();
	}
	print $html '<p align="right"><i>',
		'Generated by <a href="https://github.com/nigelhorne/ged2site">ged2site</a>. ',
		'Last updated on ',
		$dt->strftime('%x'),
		# $dt->day(), ' ', $dt->month_name(), ' ', $dt->year(),
		'</i></p>';

	print $html '</body></html>';
	close $html;

	$printed{$person->{'xref'}} = 1;
}

sub Gedcom::Individual::as_string
{
	my $self = shift;
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $name;

	if($args{'use_aka'}) {
		my $n2 = $self->tag_record('NAME', 2);
		if(defined($n2) && (ref($n2) eq 'Gedcom::Record') && defined($n2->type()) && ($n2->type() eq 'AlsoKnownAs')) {
			$name = $n2->value();
		} else {
			return;
		}
	} else {
		$name = $self->name();
	}

	$name =~ s/\///g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'};
	my $middle_name = $name_components{'middle_name'};
	my $surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	if($name_components{'non_matching'}) {
		if($name =~ /(\w{2,})\s(\w{2,})\s(\w+)\s(\w{2,})/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			my $rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
			$surname .= $rest;
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $has_maiden_name;
	if($args{'nee'}) {
		my $sex = get_value({ person => $self, value => 'sex' });
		if(defined($sex) && ($sex eq 'F')) {
			if(my $husband = $self->husband()) {
				$surname = $husband->surname();
				$has_maiden_name = 1;
			} elsif(my $spouse = $self->spouse()) {
				if($opts{'f'}) {
					die 'married, but no husband relationship';
				}
				if($opts{'w'}) {
					red_warning({ person => $self, warning => 'married, but no husband relationship' });
				}
				$surname = $spouse->surname();
				$has_maiden_name = 1;
			}
		}
	}

	my $rc;

	if($args{'title'}) {
		$rc = $name_components{'title_1'};
		if($rc) {
			$rc .= ' ';
		}
	}

	if($first_name) {
		$rc .= $first_name;
	} else {
		$rc .= $self->given_names();
	}

	if($args{'middle_names'}) {
		if($middle_name) {
			$rc .= " $middle_name";
		} elsif($name =~ /\s([A-Z])\s.+/) {
			# Just an initial has been given
			$rc .= " $1";
		}
	}

	if($surname) {
		if($rc) {
			$rc .= ' ';
		}
		$rc .= normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	}

	if($has_maiden_name && $self->surname()) {
		$rc .= ' (n&eacute;e ' . normalize_name($self->surname()) . ')';
	}

	if(!defined($rc)) {
		if($opts{'f'}) {
			die "Can't determine name of this person";
		}
		if($opts{'w'}) {
			red_warning({ warning => "Can't determine name of this person" });
			$args{'include_years'} = 1;
			$rc = 'Unknown person ';
		}
	}

	if($args{'include_years'}) {
		my $dob = get_value({ person => $self, value => 'birth date' });

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			if($dob =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				$yob = "c$2";
			} else {
				$yob = $1;
			}
		} else {
			$dob = get_value({ person => $self, value => 'baptism date' });
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = get_value({ person => $self, value => 'death date' });

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			$yod = $1;
		} else {
			$dod = get_value({ person => $self, value => 'burial date' });
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		$rc .= ' ' if($yob || $yod);

		if($yob) {
			$rc .= "$yob ";
		}

		$rc .= '-' if($yob || $yod);

		if($yod) {
			return "$rc $yod";
		}
	}

	return $rc;
}

sub normalize_name
{
	# my $name = shift;

	# my $rc;
	# foreach my $word(split(/-| |'/, lc($name))) {
		# $rc .= '-' if($rc && ($name =~ /-/));
		# $rc .= "'" if($rc && ($name =~ /'/));
		# $rc .= ' ' if($rc && ($name =~ / /));
		# $rc .= ucfirst($word);
	# }

	# return $rc;

	return Lingua::EN::NameCase::nc(shift);
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	my $sex = get_value({ person => $self, value => 'sex' });

	if(defined($sex)) {
		if($sex eq 'F') {
			return 'She';
		}
		if($sex eq 'M') {
			return 'He';
		}
	}
	return 'They';
}

sub Gedcom::Individual::possessive
{
	my $self = shift;

	my $rc = {
		'He' => 'His',
		'She' => 'Her',
		'They' => 'Their',
	};

	return $rc->{$self->pronoun()};
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship
{
	my $self = shift;
	my $other = shift;

	unless(@myancestors) {
		@myancestors = $self->ancestors();
	}
	return unless @myancestors;

	my $sex = get_value({ person => $other, value => 'sex' }) || $other->sex();
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		if($opts{'f'}) {
			die "\n", $other->as_string(), ": unknown sex\n";
		}
		if($opts{'w'}) {
			red_warning({ person => $other, warning => 'unknown sex' });
		}
		return;
	}

	foreach my $person1(@myancestors) {
		if($person1 eq $other) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title = ($sex eq 'M') ? 'father' : 'mother';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} elsif($steps == 3) {
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				if($opts{'f'}) {
					die $other->as_string(), ": BUG - not a direct ancestor, steps = $steps";
				} else {
					warn colored($other->as_string() . ": BUG - not a direct ancestor, steps = $steps", 'red');
				}
			}
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	foreach my $person1(@myancestors) {
		foreach my $person2(@ancestors2) {
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# TODO - apparently fixed in Github, awaiting new version on CPAN
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }
			if($person1 eq $person2) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				return if($steps1 > 7);
				my $steps2 = stepsabove($other, $person2, 0);
				return if($steps2 > 7);

				# It would be nice to do this as an algorithm, but this will do
				# e.g. 2, 1 is uncle
				my %male_relationships = (
					1 << 8 | 1 => 'brother',
					1 << 8 | 2 => 'nephew',
					2 << 8 | 1 => 'uncle',
					3 << 8 | 1 => 'great-uncle',
					4 << 8 | 1 => 'great-great-uncle',
					2 << 8 | 2 => 'cousin',
					2 << 8 | 3 => 'first cousin once-removed',
					3 << 8 | 2 => 'first cousin once-removed',
					2 << 8 | 4 => 'first cousin twice-removed',
					3 << 8 | 3 => 'second cousin',
					3 << 8 | 4 => 'second cousin once-removed',
					4 << 8 | 2 => 'first cousin twice-removed',
					5 << 8 | 2 => 'first cousin three-times-removed',
					5 << 8 | 3 => 'second cousin twice-removed',
					6 << 8 | 3 => 'second cousin three-times-removed',
					6 << 8 | 4 => 'third cousin twice-removed',
					6 << 8 | 5 => 'fourth cousin once-removed',
					7 << 8 | 3 => 'second cousin four-times-removed',
					7 << 8 | 5 => 'fourth cousin twice-removed',
				);
				my %female_relationships = (
					1 << 8 | 1 => 'sister',
					1 << 8 | 2 => 'niece',
					2 << 8 | 1 => 'aunt',
					2 << 8 | 2 => 'cousin',
					2 << 8 | 3 => 'first cousin once-removed',
					2 << 8 | 4 => 'first cousin twice-removed',
					3 << 8 | 1 => 'great-aunt',
					3 << 8 | 2 => 'first cousin once-removed',
					3 << 8 | 3 => 'second cousin',
					3 << 8 | 5 => 'second cousin twice-removed',
					3 << 8 | 4 => 'second cousin once-removed',
					4 << 8 | 1 => 'great-great-aunt',
					4 << 8 | 2 => 'first cousin twice-removed',
					5 << 8 | 2 => 'first cousin three-times-removed',
					5 << 8 | 3 => 'second cousin twice-removed',
					6 << 8 | 3 => 'second cousin three-times-removed',
					6 << 8 | 4 => 'third cousin twice-removed',
					6 << 8 | 5 => 'fourth cousin once-removed',
					7 << 8 | 3 => 'second cousin four-times-removed',
					7 << 8 | 5 => 'fourth cousin twice-removed',
				);

				my $rc = ($sex eq 'M') ?
					$male_relationships{($steps1 << 8) | $steps2} :
					$female_relationships{($steps1 << 8) | $steps2};
				# print "$steps1, $steps2\n" unless($rc);
				if(defined($rc) && ($rc =~ /cousin/)) {
					my $myfather = $self->father();
					my $mymother = $self->mother();
					if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
						$rc .= ' on the father\'s side';
					} elsif($mymother && (stepsabove($mymother, $person2, 0) > 0)) {
						$rc .= ' on the mother\'s side';
					}
				}

				return $rc;
			}
		}
	}
}

sub stepsabove
{
	my $person = shift;
	my $target = shift;
	my $count = shift;

	return -1 if($count == -1);

	if($person eq $target) {
		return $count;
	}
	my @father = $person->father();
	my $father = $father[0];
	my @mother = $person->mother();
	my $mother = $mother[0];

	if($father) {
		my $rc = stepsabove($father, $target, $count + 1);
		return $rc if($rc != -1);
	}
	if($mother) {
		return stepsabove($mother, $target, $count + 1);
	}
	return -1;
}

sub year
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $string = $params{'string'} || $params{'date'};

	if(!defined($string)) {
		$string = $params{'record'};
		return unless($string);

		$string = $string->date();
		return unless($string);
	}

	if($string =~ /^\d{3,4}$/) {
		return "in $string";
	}
	if($string =~ /^(Abt|ca?)\.?\s*(.+)/i) {
		return "<i>c.</i> $2";
	}
	if(($string =~ /^\d/) && ($string !~ /[a-z]$/i)) {
		my $person = $params{'person'};
		my $d;
		eval {
			$d = $date_parser->parse(date => $string);
		};
		if($d) {
			$d = @{$d}[0];
		}
		if($d) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			my $must_postdate = $params{'must_postdate'};
			if($must_postdate) {
				if($opts{'f'}) {
					die $person->as_string(), ": Something is wrong with the date $string which should be after ", $must_postdate->strftime('%x') if($d < $must_postdate);
				}
				if($opts{'w'}) {
					red_warning({ person => $person, warning => "something is wrong with the date $string which should be after " . $must_postdate->strftime('%x') }) if($d < $must_postdate);
				}
			}
			my $must_predate = $params{'must_predate'};
			if($must_predate) {
				if($opts{'f'}) {
					die $person->as_string(), ": Something is wrong with the date $string which should be before ", $must_predate->strftime('%x') if($d > $must_predate);
				}
				if($opts{'w'}) {
					red_warning({ person => $person, warning => "something is wrong with the date $string which should be before " . $must_predate->strftime('%x') }) if($d > $must_predate);
				}
			}
			if($ENV{'LANG'}) {
				$d->set_locale($ENV{'LANG'});
			}
			return 'on ' . $d->strftime('%x');
		}
		if($@) {
			# RT 107354
			chomp $@;
			if($opts{'f'}) {
				if($person) {
					die $person->as_string() . ": $@";
				} else {
					die $@;
				}
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => $@ });
			}
		}
		return "on $string";
	}
	if($string =~ /^bef.? (\d{3,4})/i) {
		return "before $1";
	}
	if($string =~ /^by.? (\d{3,4})/i) {
		return "by $1";
	}
	if($string =~ /^By (\d{3,4})/i) {
		my $person = $params{'person'};
		if($opts{'f'}) {
			if($person) {
				die $person->as_string() . " says 'By' instead of 'Bef'";
			} else {
				die "Got 'By' instead of 'Bef'";
			}
		}
		if($opts{'w'}) {
			if($person) {
				red_warning({ person => $person, warning => "says 'By' instead of 'Bef'" });
			} else {
				warn colored("Got 'By' instead of 'Bef'", 'red');
			}
		}
		return "before $1";
	}

	$string = ucfirst(lc($string));
	return "in $string";
}

sub place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	my $address = $params{'address'};

	if(!defined($place)) {
		$place = $params{'record'};
		return unless($place);

		$address = $place->address();
		$place = $place->place();
		return unless($place);
	}

	my $there = $params{'there'};

	if($there && ($place eq $there)) {
		if($address) {
			if($place =~ /^(.+?),.+,/) {
				return " at $address, $1";
			}
		} else {
			return ' there';
		}
	}

	if($params{'person'}) {
		validate_place({ person => $params{'person'}, place => $place });
	}

	if($place =~ /^\d/) {
		if(my $places_printed = $params{'places_printed'}) {
			$places_printed->{" at$place"} = 1;
			if($place =~ /(.+),(.+?),(.+?),(.+?),(.+?)$/) {
				if($places_printed->{" in$3,$4,$5"}) {
					$places_printed->{"at $1,$2,$3"} = 1;
					return " at $1,$2,$3";
				}
			}
			if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
				$places_printed->{" in$2,$3,$4"} = 1;
			}
		}
		return " at $place";
	}

	if($place eq 'USA') {
		return ' in the USA';
	}

	if($address) {
		$place = " at $address, $place";
	} elsif($params{'nopreposition'}) {
		$place = " $place";
	} else {
		$place = " in $place";
	}

	# Only print the town if the location has already been printed
	if(my $places_printed = $params{'places_printed'}) {
		if($places_printed->{$place} && $place =~ /^(.+?),/) {
			return $1;
		}
		if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
			my $str = "$2,$3,$4";
			if($params{'person'}) {
				validate_place({ person => $params{'person'}, place => $place });
			}
			if($places_printed->{" in$str"}) {
				if(($4 eq ' USA') || ($4 eq ' Canada')) {
					return "$1,$3";
				}
				return $address ? "$1,$2" : "$1 in$2";
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2";
			}
			$str = "$3,$4";
			if($places_printed->{" in$str"}) {
				return "$1,$2,$3";
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2,$3";
			}
			$places_printed->{" in$str"} = 1;
			$places_printed->{" in$2,$3,$4"} = 1;
		} elsif($place =~ /(.+),(.+),(.+)$/) {
			if($places_printed->{" in$2,$3"}) {
				# We did place, county, country before, so just
				# return place, county
				return "$1,$2";
			}
			$places_printed->{" in$2,$3"} = 1;
		}
		$places_printed->{$place} = 1;
	}
	return HTML::Entities::encode($place);
}

sub notes
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record = $params{'record'};
	my $person = $params{'person'};
	my $paragraph = $params{'paragraph'};

	my $ufinder = URI::Find::Schemeless->new(sub {
		my($uri, $orig_uri) = @_;

		if($orig_uri =~ /(.+):$/) {
			$orig_uri = $1;
		}
		my $u = URI->new($orig_uri);
		if($u && (ref($u) ne 'URI::_generic')) {
			if(!head($orig_uri)) {
				if($opts{'f'}) {
					die $person->as_string, ": $orig_uri: in notes is not found";
				}
				red_warning({ person => $person, warning => "$orig_uri: in notes is not found" });
			}
			$uri =~ s/:$//;
			return "<a HREF=\"$uri\">" .
				$u->host() .
				'</a>';
		}
		return $orig_uri;
	});

	# my @deathnotes = get_value({ person => $person, value => 'death note' });
	# my @deathnotes = $person, value => 'death note' });
	my $rc = $record->get_value();
	$rc .= '.' if($rc);

	my @notes = $record->get_record('note');
	foreach my $note(@notes) {
		if($note) {
			if(ref($note) eq 'Gedcom::Record') {
				if($note->cont()) {
					my $n = $note->value();
					$n =~ s/\r//g;
					$n =~ s/\.$//;
					foreach my $c($note->cont()) {
						if((!ref($c)) && length($c)) {
							$c =~ s/\s\s+/ /g;
							$c =~ s/\.$//;
							if($n =~ /[;:]$/) {
								$n .= " $c";
							} else {
								$n .= ". $c";
							}
						}
					}
					$note = $n;
				} elsif($note->conc()) {
					my $n = $note->value();
					$n =~ s/\r//g;
					$n =~ s/\.$//;
					foreach my $c($note->conc()) {
						if((!ref($c)) && length($c)) {
							$c =~ s/\s\s+/ /g;
							$n .= $c;
						}
					}
					$note = $n;
				} else {
					$note = $note->value();
				}
			}
			$note =~ s/\r//g;
			$note =~ tr/\n/ /;
			$note =~ s/\.$//;
			if($paragraph) {
				$rc .= '<p>' . HTML::Entities::encode($note) . '.</p>';
			} else {
				if($rc) {
					$rc .= ' ';
				}
				$rc .= HTML::Entities::encode($note) . '.';
			}
		}
	}
	if(defined($rc)) {
		$rc =~ s/\n/<br>/g;
		$rc =~ s/\s\s+/ /g;
		$rc =~ s/ $//;
		$ufinder->find(\$rc);

		if(defined($ENV{'LANG'})) {
			if($ENV{'LANG'} =~ /^en_US/) {
				return Lingua::EN::ABC::b2a($rc);
			} elsif($ENV{'LANG'} =~ /^en_GB/) {
				return Lingua::EN::ABC::a2b($rc);
			}
		}
	}
	return($rc);
}

sub validate_place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	if(!$place) {
		my $i = 0;
		print STDERR "\n";
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'place is not optional';
	}

	$place =~ s/^\s+//;
	if($places{$place}) {
		return $places{$place};
	}

	# US and Canada are more logical, using city,county,state,country, than other countries
	if($opts{'w'} && (($place !~ /,.*,.*,.*/) || ($place =~ /USA|Canada/i))) {
		if($place =~ /(.*),\s*Independent Cities\s*(.*)/i) {
			$place = "$1$2";
		}
		$place =~ s/^(in|at)\s//;
		my $town = $place;
		if($place =~ /,\s*(.+,.+,.+,.+)$/) {
			# Use only the town part
			$town = $1;
		}
		if(!$geocoder->geocode($town)) {
			my $found = 0;
			# if(($place =~ /, Canada$/) &&
			  # (my $ap = Lingua::EN::AddressParse->new(country => 'CA', auto_clean => 1, force_case => 1, force_post_code => 0))) {
				# $place =~ s//e/g;
				# $place =~ s//e/g;
				# my $error = $ap->parse($place);
				# # print $ap->report();
				# my %nc = $ap->components();
				# my $g = Geo::Coder::Canada->new();
				# if($nc{'suburb'}) {
					# $g->addresst($nc{street_name});
					# $g->city($nc{suburb});
					# $g->prov($nc{subcountry});
				# } elsif($place =~ /,?(.+?),(.+?),(.+?),(.+?)$/) {
					# $g->city($2);
					# $g->prov($3);
				# }
				# if($g->geocode()) {
					# $found = 1;
				# } else {
					# # die $g->error->description;
				# }
			# }
			if(!$found) {
				# Don't die because there are many
				# false positives as locations
				# may no longer exist
				my $person = $params{'person'};
				if($person) {
					warn colored($person->as_string({ include_years => 1 }) . ": unknown location $place", 'red');
				} else {
					warn colored("Unknown location $place", 'red');
				}
				$places{$place} = 0;
				$places{$town} = 0;
				return 0;
			}
		}
		$places{$town} = 1;
	}
	$places{$place} = 1;
	return 1;
}

sub person_line_html
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	if($opts{'l'} || !was_alive(%params)) {
		my $dob = get_value({ person => $person, value => 'birth date' });
		if($dob) {
			return '<a href="' . make_filename_from_person(person => $person) . '">' .
				$person->given_names() .
				'</a> was born ' .
				year({ person => $person, date => $dob });
		} elsif(get_value({ person => $person, value => 'baptism date' })) {
			return '<a href="' . make_filename_from_person(person => $person) . '">' .
				$person->given_names() .
				'</a> was born c. ' .
				get_value({ person => $person, value => 'baptism date' });
		}
		return '';
	}
	return '<a href="' . make_filename_from_person(person => $person) . '">' .
		$person->given_names() .
		'</a>';
}

sub person_line_csv
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	if($opts{'l'} || !was_alive(%params)) {
		my $dob = get_value({ person => $person, value => 'birth date' });
		if($dob) {
			return '<a href="?page=people&entry=' . $person->{'xref'} . '">' .
				$person->given_names() .
				'</a> was born ' .
				year({ person => $person, date => $dob });
		} elsif(get_value({ person => $person, value => 'baptism date' })) {
			return '<a href="?page=people&entry=' . $person->{'xref'} . '">' .
				$person->given_names() .
				'</a> was born c. ' .
				get_value({ person => $person, value => 'baptism date' });
		}
		return '';
	}
	return '<a href="?page=people&entry=' . $person->{'xref'} . '">' .
		$person->given_names() .
		'</a>';
}

sub places_are_the_same
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record1 = $params{'first'};
	my $record2 = $params{'second'};

	die 'first is not optional' unless $record1;
	die 'second is not optional' unless $record2;

	my $place1 = $record1->place();
	return 0 unless(defined($place1));
	my $place2 = $record2->place();
	return 0 unless(defined($place2));

	if(my $person = $params{'person'}) {
		validate_place({ person => $person, place => $place1 });
		validate_place({ person => $person, place => $place2 });
	}

	if(my $address = $record1->address()) {
		$place1 = "$address, $place1";
	}
	if(my $address = $record2->address()) {
		$place2 = "$address, $place2";
	}
	return $place1 eq $place2;
}

sub sibling_baptism_string
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $siblings = $params{'siblings'};
	my $date = $params{'date'};
	my $birthdate = $params{'birthdate'};
	my $rc = '';

	my @onsameday;
	foreach my $sibling(@{$siblings}) {
		my $dateofsiblingbaptism = get_value({ person => $sibling, value => 'baptism date' });
		if($dateofsiblingbaptism && ($dateofsiblingbaptism eq $date)) {
			push @onsameday, $sibling;
		}
	}
	my $count = 0;
	foreach my $sibling(@onsameday) {
		if($count == 0) {
			$rc = ', the same day as ';
		} elsif($count < (scalar(@onsameday) - 1)) {
			$rc .= ', ';
		} elsif($count == (scalar(@onsameday) - 1)) {
			$rc .= ' and ';
		}
		$rc .= lcfirst($person->possessive()) . ' ';
		my $dateofsiblingbirth = get_value({ person => $sibling, value => 'birth date' });
		if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
			$rc .= 'twin ';
		}
		$rc .= ($sibling->sex() eq 'M' ? 'brother ' : 'sister ') .
			$sibling->given_names();
		$count++;
	}

	return $rc;
}

sub red_warning
{
	if($opts{'w'}) {
		my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

		die "What do you want to say?" unless($params{'warning'});

		if($params{'person'}) {
			my @call_details = caller(0);
			warn colored(['red'], $params{'person'}->as_string(), ': ', $params{'warning'}, ' at line ', $call_details[2]);
			push @{$params{'person'}->{'warnings'}}, $params{'warning'};
		} else {
			warn colored(lcfirst($params{'warning'}), 'red');
		}
		# my $i = 0;
		# while((my @call_details = (caller($i++)))) {
			# print STDERR "\t", colored($call_details[1] . ':' . $call_details[2] . ' calling function ' . $call_details[3], 'red'), "\n";
		# }
	}
}

# Cache gedcom values
sub get_value
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $value = $params{'value'};

	my $xref = $person->{'xref'};
	tie (my %values, 'Tie::Static');

	if(defined($values{$xref}{$value})) {
		return $values{$xref}{$value};
	}

	my $rc = $person->get_value($value);
	$values{$xref}{$value} = $rc;
	return $rc;
}

sub get_source
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $gedcom = $params{'gedcom'};
	my $person = $params{'person'};
	my $source = $params{'source'};

	my $xref = $person->{'xref'};
	tie (my %sources, 'Tie::Static');

	if(defined($sources{$xref}{$source})) {
		return $sources{$xref}{$source};
	}

	my $rc = $gedcom->get_source($source);
	$sources{$xref}{$source} = $rc;
	return $rc;
}

# Inspired by Tree::Family.  That module doesn't quite do what I want, so
# I've mercilessly re-used the ideas of what to do from it.
sub print_graphviz
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $colour = $params{'colour'};
	my $profile_image = $params{'profile_image'};

	if(!defined($colour)) {
		my $gender = get_value({ person => $person, value => 'sex' }) || $person->sex();
		if(defined($gender)) {
			$gender = $gender;
		} else {
			if($opts{'f'}) {
				die "\n", $person->as_string(), ": unknown sex\n";
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => 'unknown sex' });
			}
			$gender = 'M';	# Avoid "Use of uninitialized value" in Tree::Family
		}
		$colour = ($gender eq 'M' ? '#093AB5' : '#C666B8');
	}

	print $fout $person->{'xref'}, ' [shape=box,fontsize="10",',
		"color=\"$colour\",";

	if($params{'format'} eq 'dynamic') {
		print $fout 'href="?page=people&entry=', $person->{'xref'}, '",';
	} else {
		print $fout 'href="', make_filename_from_person(person => $person), '",';
	}

	my $label = $person->as_string();
	my $dob = get_value({ person => $person, value => 'birth date' });
	my $dod = get_value({ person => $person, value => 'death date' });

	# If you get 'Warning: No loadimage plugin for "jpeg:cairo"', do this
	# instead:
	# if(0) {
	if($profile_image && (defined($dod) || $opts{'l'})) {
		if(defined($dob)) {
			$dob .= "<TR><TD>b. $dob</TD></TR>";
		} else {
			$dob = '';
		}
		if(defined($dod)) {
			$dod .= "<TR><TD>d. $dod</TD></TR>";
		} else {
			$dod = '';
		}
		# Create a thumbnail
		my $image = Image::Magick->new();
		$image->read($profile_image);
		my ($thumb, $x, $y) = Image::Magick::Thumbnail::create($image, 100);
		my @thumbname = File::Basename::fileparse($profile_image);
		# use PNG to try to avoid
		#	'Warning: No loadimage plugin for "jpeg:cairo"'
		$thumbname[0] =~ s/\.jpg$/.png/;
		$thumb->Write("thumbs/$thumbname[0]");

		# FIXME: TABLE isn't supported by Graphviz
		print $fout "label=<<TABLE border=\"0\" cellborder=\"0\"><TR><TD><IMG SRC=\"thumbs/$thumbname[0]\" scale=\"true\"/></TD></TR><TR><TD>$label</TD></TR>$dob$dod</TABLE>>";
		print $fout ",labelloc=b";

		# print $fout ",image=\"$profile_image\",labelloc=b";
	} elsif(defined($dod) || $opts{'l'}) {
		if(defined($dob)) {
			$label .= "\\nb. $dob";
		}
		if(defined($dod)) {
			$label .= "\\nd. $dod";
		}
		print $fout "label=\"$label\"";
	} else {
		print $fout "label=\"$label\"";
	}
	print $fout "];\n";
}

sub was_alive
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	if($person->get_record('death') || get_value({ person => $person, value => 'death date' })) {
		return 0;
	}
	if($person->get_record('burial')) {
		return 0;
	}
	my $dob = get_value({ person => $person, value => 'birth date' });

	if(!defined($dob)) {
		return 0;	# Err on the side of caution
				# TODO: Look at children's lifespan for a clue
	}

	my $year = $params{'year'} || (localtime)[5];
	$year += 1900 if($year < 1900);

	if(($dob =~ /^\d{3,4}$/) && ($dob < ($year - 100))) {
		return 0;
	}
	if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
		my $d;
		eval {
			$d = $date_parser->parse(date => $dob);
		};
		if($d) {
			$d = @{$d}[0];
		}
		if($d) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($d->strftime('%Y') < ($year - 120)) {
				return 0;
			}
		}
	}
	return 1;
}

sub make_filename_from_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	die if(!defined($person));

	my $rc = $person->as_string(include_years => 1);
	$rc =~ tr/ /-/s;
	$rc =~ s/--+/-/g;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	return "$rc.html";
}

sub make_filename_from_object
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $object = $params{'object'};

	my $rc = $object->title();
	if(!$rc) {
		return $object->{'xref'};
	}
	$rc =~ tr/ /-/s;
	$rc =~ tr/'/-/s;
	$rc =~ s/--+/-/g;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	return $rc;
}
