#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015-2025, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# TODO: Geo::Coder::GeocodeFarm, once github issue 1 has been fixed
# TODO: Investigate BGS and Lingua::EN::Sentence
# TODO: Finish XML, perhaps use XML::Hash for display?
# TODO: Can I use a kdTree to determine events or residences close by each other?
# TODO: add male and female average lifespan to the facts
# TODO: finish -x option to create a blog of differences over time of
#	changes to the tree (how do I check it's the same family tree, though?)
# TODO: look at census records to note the different places that a person's children
#	were born and note if the residences of the person don't include those places
# TODO: Create occupations database
# TODO: flag if census locations are XYX and Y is more than (say) 50 miles from X
# TODO: timeline of each person - like or using timetoast.com
# TODO: investigate Locale::Geocode
# FIXME: with a US state you use 'en' not Ã 
# TODO: Investigate List::ToHumanString
# TODO: Investigate Carp::Assert::More
# TODO: Can I make use of the Chart module?
# TODO: consider Data::Dumper::Names instead of Data::Dumper
# TODO: investigate User::Identity
# TODO: handle https://www.compart.com/en/unicode/U+25CF in notes as <li>
# TODO: collapsable lists: https://www.w3schools.com/howto/howto_js_collapsible.asp
# TODO: is there anything that could be better modeled in a 3D way?
# TODO: data analysis of notes to find extra information
# TODO: prune old entries from changes.psv (should be configurable how long ago)
# TODO:	notes_locations already contain lat/long information, so use that in add_marker()

# -d:	Download copies of objects rather than link to them, useful if the
#	objects are on pay sites such as FMP

# For the Simile Timeline format see
#	http://www.simile-widgets.org/wiki/Timeline_EventSources
# For visjs see
#	http://visjs.org/docs/timeline/

# dnf install langpacks-fr glibc-all-langpacks -y

use 5.020;
use utf8;
use strict;
use warnings;
# use open qw(:std :utf8);	# Do not use, it breaks printing
	# HTTP::Response->decoded_content() to a file
# no feature qw(indirect);
# use feature qw(signatures);
# no warnings qw(experimental::signatures);

no lib '.';

use	constant	ASSUME_NOT_LIVING => 120;

sub datecmp($$);

my @needfull;	# Tracks required modules to be installed

# Install Pre-requisites
BEGIN {
	my @modules = (
		'Array::Iterator', 'Config::Auto', 'Data::Text',
		'Date::Cmp', 'Date::Manip', 'Parse::RecDescent', 'Roman',
		'File::Basename', 'File::Copy', 'File::Print::Many', 'File::Temp',
		'FindBin', 'Gedcom', 'Genealogy::Gedcom::Date', 'Genealogy::Obituary::Parser',
		'Date::Parse', 'Geo::Coder::List', 'Geo::Coder::Free',
		'IPC::System::Simple', 'Geo::Coder::Ovi', 'String::Compare',
		'Genealogy::Gedcom::Date',
		# 'Geo::Coder::DataScienceToolkit',
		# 'Geo::Coder::Free::OpenAddresses',
		'Geo::Coder::Abbreviations', 'Geo::Coder::RandMcnally', 'Geo::Coder::US::Census',
		'Geo::Coder::OSM', 'Geo::Coder::XYZ', 'Geo::Coder::CA',
		'Lingua::EN::ABC', 'Lingua::String',
		'Geo::Parser::Text', 'GIS::Distance',
		'HTML::Entities', 'Image::Info', 'JSON::MaybeXS',
		'List::Util',
		'LWP::Simple::WithCache', 'MIME::Base64',
		'LWP::UserAgent::Cached', 'Mozilla::CA', 'Math::Round',
		'DateTime', 'DateTime::Duration',
		'DateTime::Format::Genealogy', 'DateTime::Format::Natural',
		# 'Geo-Coder-PlaceFinder-0.1.tar.gz'
		'Class::Simple::Readonly::Cached', 'Class::Simple::Cached', 'Encode::Wide',
		'Scalar::Util',
		'Sort::Key::DateTime', 'String::Random', 'Text::Names', 'Text::Names::GB',
		'Term::ANSIColor',
		'URI', 'URI::Find::Schemeless',
		'Locale::AU', 'Locale::CA', 'Locale::US',
		'XML::Dumper', 'XML::Twig', 'CHI', 'Class::Simple',
		# 'Geo::StreetAddress::US',
		'Getopt::Std', 'Lingua::EN::NameCase', 'Lingua::EN::NameParse',
		'Lingua::Conjunction', 'Lingua::EN::Inflect', 'Locale::Object::Country',
		'Params::Get', 'Readonly::Values::Months',
		'Unicode::Diacritic::Strip', 'URI::Find::Schemeless',
	);

	# I can't get Marpa::R2 versions 10 and 12 to build on Solaris.
	# It's used by Genealogy::Gedcom::Date, so force version 8
	eval 'use Marpa::R2';
	if($@) {
		if($^O eq 'solaris') {
			push @needfull, 'JKEGL/Marpa-R2-8.000000.tar.gz'
		} else {
			push @needfull, 'Marpa::R2';
		}
	}

	# Attempt to load each module and track missing ones
	foreach my $module(@modules) {
		eval "use $module";
		if($@) {
			# Install module dependencies
			if($module =~ /(.+)\s/) {
				# Specific version not satisfied
				push @needfull, $1;
			} else {
				push @needfull, $module;
			}
		}
	}
	# Fix for this module not being found
	# https://cpan.metacpan.org/authors/id/G/GR/GRAY/Geo-Coder-PlaceFinder-0.05.tar.gz
	eval 'use Geo::Coder::PlaceFinder';
	if($@) {
		push @needfull, 'Net::OAuth', 'JSON::MaybeXS', 'F/FR/FRIFFIN/Geo-Coder-PlaceFinder-0.1.tar.gz'
	}

	if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^fr/)) {
		eval 'use Lingua::FR::Numbers::Ordinate';
		if($@) {
			# Apparently it's "unauthorized", but there's no other module with the same name
			push @needfull, 'N/NH/NHORNE/Lingua-FR-Numbers-Ordinate-0.03.tar.gz';
		}
	} else {
		if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^fa/)) {
			eval 'use Lingua::FA::Number';
			if($@) {
				push @needfull, 'Lingua::FA::Number', 'HTML::Entities';
			}
		}
		eval 'use Lingua::EN::Numbers::Ordinate';
		if($@) {
			push @needfull, 'Lingua::EN::Numbers::Ordinate';
		}
	}

	# Attempt to load each module and track missing ones
	if(scalar(@needfull)) {
		my $list = join(' ', @needfull);
		if($ENV{'BOOTSTRAP'}) {
			print "Installing $list\n";
			$ENV{'PERL_MM_USE_DEFAULT'} = 1;
			# system("cpan -i $list");
			system('perl -MCPAN -e \'CPAN::Shell->install("' . join('", "', @needfull) . '")\'');
		} else {
			die "You need the following modules: $list";
		}
	}

	# $Devel::FIXME::REPAIR_INC = 1;

	# FIXME
	# $SIG{__WARN__} = sub {
		# my $warning = shift;
		# if(($warning !~ /Subroutine Geo::Coder::OpenCage::ua redefined at/) &&
		   # ($warning !~ /Subroutine ua redefined at/) &&
		   # ($warning !~ /Subroutine HTML::GoogleMaps::V3::_text_to_point redefined at/) &&
		   # ($warning !~ /Subroutine Gedcom::Individual::relationship redefined at/)) {
			# if(($warning =~ /^Use of uninitialized value/) ||
			   # ($warning =~ /Wide/) ||
			   # ($warning =~ /masks earlier declaration in same scope/) ||
			   # ($warning =~ /: attempt to add consecutive punctuation/) ||
			   # ($warning =~ /^Odd number of elements in hash assignment/) ||
			   # ($warning =~ /isn't numeric in numeric eq /i)) {
				# die $warning;
			# }
			# utf8::decode($warning);
			# warn $warning;
		# }
	# };
}

# Retry loading missing modules after installation
foreach my $module (@needfull) {
	my ($name, $version) = $module =~ /(.+?)\s(.+)?$/;
	$name ||= $module;

	# Extract module name, replacing hyphens with `::` and removing extensions
	$name =~ s{.+/}{};	# Remove path if present
	$name =~ s{-}{::}g;r	# Convert hyphens to `::`
	$name =~ s{\.tar\.gz$}{}; # Remove file extension
	$name =~ s{::(\d+)$}{ $1}; # Adjust version formatting if embedded in module name

	if($version) {
		eval "require $name $version" or die $@;
	} else {
		eval "require $name" or die $@;
	}
	$name->import();

	# Uncomment to check version if needed
	die "$name: need $version, got ", $name->VERSION if $version && $name->VERSION < $version;
}

use autodie qw(:all);
# use warnings::unused;

# BEGIN {
	# *CORE::GLOBAL::die = \&main::die;
# }

# use Lingua::EN::AddressParse;
# use Memoize;
use POSIX;

sub get_location($);

my %opts;
getopts('cdfFG:g:h:J:lL:mwWvx:', \%opts);

die "Usage: $0 [ -c ] [ -d ] [ -F ] [ -f ] [ -g google-search-verification ] [ -h home-person-name ] [ -l ] [ -L max_records ] [ -m [-G Google-Maps-GeoLocation-key ] [ -J Google-Maps-JavaScript-key ] ] [ -w [ -W ] ] [ -x current_people.xml ] filename [ filename2 ]\n" unless($ARGV[0]);

print "Starting\n" if($opts{'v'});

use	constant	MAX_INDEX => 0;	# Debugging, set this to the number of records to print.
					# Set to 0 to run on the entire database

my $gedcal;
if(-x '/usr/bin/gedcom') {
	$gedcal = '/usr/bin/gedcom';
} elsif(-x '/usr/local/bin/gedcom') {
	$gedcal = '/usr/local/bin/gedcom';
} elsif(-x '../gedcom/gedcom') {
	$gedcal = '../gedcom/gedcom';
}

my $language = get_language();

print "Language = $language\n" if($opts{'v'});

my @modules = ();
@needfull = ();
my $grave_modules;

$opts{'w'} = 1 if($opts{'f'});

if($opts{'d'} || $opts{'m'} || $opts{'w'}) {
	push @modules, 'File::Spec', 'XML::Hash';

	if(!$ENV{'CACHE_DIR'}) {
		push @modules, 'File::HomeDir';
	}

	push @modules, 'Geo::Coder::Free::Local', 'Geo::Coder::Postcodes';
	if($opts{'w'}) {
		push @modules,
			'Genealogy::ChroniclingAmerica', 'Locale::Country';
	}
}
if($opts{'m'} || $opts{'d'}) {
	push @modules, 'HTTP::Cache::Transparent';
	if($opts{'d'}) {
		push @modules, 'Weather::Meteo', 'DateTime::Format::Text';
	}
}
if($opts{'m'} || $opts{'w'}) {
	push @modules, 'LWP::UserAgent::Throttled';
}
if($gedcal || !$opts{'w'}) {
	push @modules, 'String::ProgressBar';
}
if($opts{'F'}) {
	# Debian lacks ImageMagick-7
	# yum install gd-devel ImageMagick-devel
	my $magick;
	if($^O eq 'linux') {
		# Debian lacks ImageMagick-7
		$magick = 'Image::Magick 6.9.13-6';
	} else {
		$magick = 'Image::Magick';
	}
	push @modules, $magick, 'Image::Magick::Thumbnail';
}
if(defined($language) && ($language ne 'English')) {
	push @modules, 'Locale::Country::Multilingual', 'Locale::Places';
}
if($ENV{'GEO_CODER_OPENCAGE_API_KEY'}) {
	push @modules, 'Geo::Coder::OpenCage';
}
if($ENV{'GMAP_GEOCODING_KEY'} && $ENV{'GMAP_WEBSITE_KEY'}) {
	push @modules, 'Geo::Coder::GooglePlaces';
	if($ENV{'GMAP_CLIENT'}) {
		push @modules, 'Geo::Coder::Google';
	}
}
if($ENV{BMAP_KEY}) {
	push @modules, 'Geo::Coder::Bing';
}

if($ENV{'GEONAMES_USER'}) {
	push @modules, 'Geo::GeoNames';
}
if($ENV{'GEOAPIFY_KEY'}) {
	push @modules, 'Geo::Coder::GeoApify';
}
if($opts{'m'} || $opts{'w'}) {
	if($ENV{'REDIS_SERVER'}) {
		push @modules, 'CHI::Driver::Redis';
	}
	if($opts{'w'}) {
		push @modules, 'Genealogy::Obituary::Lookup', 'Genealogy::Wills';
	}
}
if($opts{'v'}) {
	push @modules, 'Log::Any::Adapter';
}

my $config;

eval { $config = Config::Auto::parse() };

my $javascript_key;	# e.g. Google Maps API key set to application
			# restriction = 'websites'.  Add your site there.
my $maps_module;
if($opts{'J'}) {
	$javascript_key = $opts{'J'};
	$maps_module = 'HTML::GoogleMaps::V3';
	# push @modules, 'Sub::Override';
} elsif($config && $config->{'google_maps_javascript_key'}) {
	$javascript_key = $config->{'google_maps_javascript_key'};
	$maps_module = 'HTML::GoogleMaps::V3';
} else {
	$maps_module = 'HTML::OSM';
}

push @modules, $maps_module;

if($opts{'w'} && $opts{'c'}) {
	# If you have a locally written module to look up entries,
	# list them in gedcom.config,
	# otherwise use Genealogy::FindaGrave
	if($config && $config->{'grave_modules'}) {
		$grave_modules = $config->{'grave_modules'};

		if(ref($grave_modules)) {
			foreach my $module(@{$grave_modules}) {
				autoload $module;
			}
		} else {
			autoload $grave_modules;
		}
	} else {
		push @modules, 'Genealogy::FindaGrave';

		$grave_modules = 'Genealogy::FindaGrave';
	}

	# if(!$ged->validate() && $opts{'f'}) {
		# die "$ARGV[0] is not a valid gedcom file";
	# }
}

# my $libdir1 = File::Spec->catfile($FindBin::Bin, File::Spec->updir(), 'lib');
# if(-d $libdir1) {
	# unshift @INC, ($libdir1);
# }
# my $libdir2 = File::Spec->catfile(File::HomeDir->my_home(), 'lib');
# if(($libdir2 ne $libdir1) && (-d $libdir2)) {
	# unshift @INC, ($libdir2);
# }

foreach my $module(@modules) {
	my $version;
	my $module_name;
	if($module =~ /(.+)\s(.+)$/) {
		$module_name = $1;
		$version = $2;
		eval "require $1";
	} else {
		eval "require $module";
	}
	if($@) {
		if($version) {
			my $s = `cpan -D $module_name | grep / | grep -v Reading`;

			chomp($s);
			$s =~ s/^\s+//;
			$s =~ s/(.+)\/.+/$1/;
			$module_name =~ s/::/-/g;

			# FIXME - could end in .tgz or even .zip
			push @needfull, "$s/$module_name-$version.tar.gz";
		} else {
			push @needfull, $module;
		}
	} else {
		$module->import();
	}
}
if(scalar(@needfull)) {
	my $list = join(' ', @needfull);
	if($ENV{'BOOTSTRAP'}) {
		print "Installing $list\n";
		# system("cpan -i $list");
		$ENV{'PERL_MM_USE_DEFAULT'} = 1;
		system('perl -MCPAN -e \'CPAN::Shell->install("' . join('", "', @needfull) . '")\'');
	} else {
		die "For those options, you also need the following modules: $list";
	}
}

foreach my $module(@modules) {
	my $version;
	if($module =~ /(.+)\s(.+)$/) {
		$module = $1;
		$version = $2;
	}
	eval "require $module";
	if($@) {
		die $@;
	}
	$module->import();
	# if($version) {
		# $module->VERSION($version);
	# }
	# if($version && ($module::VERSION < $version)) {
		# die "$module: need $version got ", $module::VERSION;
	# }
}

if($maps_module eq 'HTML::GoogleMaps::V3') {
	# Nice idea, but it doesn't do what I think it should do
	# Sub::Override->new("${maps_module}::_text_to_point" => sub { ged2site_text_to_point(@_) });
	# So do this instead
	*HTML::GoogleMaps::V3::_text_to_point = sub { ged2site_text_to_point(@_) };
}

umask(0077);	# Don't let PII become publicly readable

my $me;
my @myancestors;
my @mydescendants;
my %printed;
my %places;
my $surnames;
my %censuses;
my %twins;
my %all_military;
my %all_occupations;
my %orphans;
my %images;
my %all_locations;	# Maps years to an array of hashes
my %all_events;	# Maps events to people
my %all_dates;	# Maps dates to the hashref from Genealogy::Gedcom::Date
my %name_date;	# Maps first names to quarter century
my %surname_date;	# Maps surnames to quarter century
my %changes;	# If the -x option is given, tracks changes between the previous run and this run
my $facts;
my %intermarriages;	# People who've married a relative
my %all_residences;
my $geonames;
# my $pi = atan2(1,1) * 4;

if($opts{'W'} && !$opts{'w'}) {
	warn '-W only makes sense with the -w option';
} elsif($opts{'w'} && !defined($ENV{'CLICOLOR'})) {
	$opts{'W'} = 1;
}

binmode(STDOUT, ':utf8');
binmode(STDERR, ':utf8');
umask(0077);	# Don't let PII become publicly readable

# Help OSM to match
my %location_mappings = (
	'Coventry, Warwickshire, England' => 'Coventry, England',
	'Minster, Sheppey, Kent' => 'Minster, Swale, Kent',
	'Bromley, Kent, Endland' => 'Bromley, London, England',
	'Croydon, Surrey, Endland' => 'Croydon, London, England',
	'Thornton Heath, Surrey, Endland' => 'Thornton Heath, London, England',
	'Edinburgh, Midlothian, Scotland' => 'Edinburgh, Scotland',
);

my $nameparser = Lingua::EN::NameParse->new(extended_titles => 1);
my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);
$ged = Class::Simple::Cached->new(object => $ged, cache => CHI->new(driver => 'RawMemory', datastore => {}));

my $script_name = basename($0);
my $logger;
if($opts{'v'}) {
	Log::Any::Adapter->set('Stdout', log_level => 'trace');
	$logger = Log::Any->get_logger(category => $script_name);
}

my $places;
my $lcm;
if(defined($language) && ($language ne 'English')) {
	$places = Class::Simple::Readonly::Cached->new(object => Locale::Places->new(), cache => { });
	$lcm = Class::Simple::Readonly::Cached->new(object => Locale::Country::Multilingual->new(),
		cache => CHI->new(driver => 'RawMemory', datastore => {}));
}

# Read in the $text table for translation
my $i18n;
if(my $data = Data::Section::Simple::get_data_section($language)) {
	my @lines = split /\n/, $data;
	foreach(@lines) {
		my ($english, $gender, $foreign) = split /:/;
		if($gender) {
			$i18n->{$english}->{$gender} = $foreign;
		} else {
			$i18n->{$english} = $foreign;
		}
	}
}

my $date_parser = Genealogy::Gedcom::Date->new();
my $dfn;
if(defined($language) && ($language eq 'French')) {
	# $dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy', lang => 'fr');	 # not supported
	$dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy');
	Date_Init('DateFormat=FR');	# Date::Manip
	$lcm->set_lang('fr');
} elsif((defined($ENV{'LC_TIME'}) && ($ENV{'LC_TIME'} =~ /^en_US/)) ||
	((defined($ENV{'LC_ALL'}) && ($ENV{'LC_ALL'} =~ /^en_US/)))) {
	$dfn = DateTime::Format::Natural->new();
	Date_Init('DateFormat=US');	# Date::Manip
	if(defined($lcm)) {
		$lcm->set_lang('en');
	}
} else {
	$dfn = DateTime::Format::Natural->new(format => 'dd/mm/yy');
	if(defined($language)) {
		Date_Init("Language=$language");	# Date::Manip
	} else {
		Date_Init('DateFormat=International');
	}
	if($lcm) {
		$lcm->set_lang(get_language_code() // 'en');
	}
}

my $dfg = DateTime::Format::Genealogy->new();
my $oneday = DateTime::Duration->new(days => 1);
my $tenmonths = DateTime::Duration->new(months => 10);
my $sixteenyears = DateTime::Duration->new(years => 16);
my $fortyyears = DateTime::Duration->new(years => 40);
# my $fetcher;
my $year_1000 = DateTime->new(year => 1000, month => 1, day => 1);

my %gp_args = (apiver => 3);
my $google_maps_geolocation_key;
if($opts{'G'}) {
	$google_maps_geolocation_key = $opts{'G'};
} elsif($ENV{'GMAP_GEOCODING_KEY'} || $ENV{'GMAP_KEY'}) {	# Compatibility with various CPAN modules
	$google_maps_geolocation_key = $ENV{'GMAP_GEOCODING_KEY'} || $ENV{'GMAP_KEY'};
} elsif($config && $config->{'google_maps_google_maps_geolocation_key'}) {
	$google_maps_geolocation_key = $config->{'google_maps_google_maps_geolocation_key'};
}
$gp_args{'key'} = $google_maps_geolocation_key;
$gp_args{'api_key'} = $google_maps_geolocation_key;
my $l = $ENV{'LANG'};
if(defined($l) && ($l =~ /^([a-z]{2})/i)) {
	$gp_args{'language'} = lc($1);
}

my $geocoder;
my $textgeocoder;
my $freegeocoder;
my $browser;
my $cachedir;
my %all_bios;
my %all_thumbnails;

if(my $e = $ENV{'CACHE_DIR'}) {
	$cachedir = File::Spec->catfile($e, 'lwp-cache');
} else {
	# $cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'lwp');
	$cachedir = File::Spec->catfile(File::HomeDir->my_home(), '.cache', 'lwp-cache')
}
if(!-d $cachedir) {
	mkdir $cachedir, 02700 || die "$cachedir: $!";
}
my $cached_browser = LWP::UserAgent::Cached->new(
	cache_dir => $cachedir,
	agent => basename($0),
	keep_alive => 1,
	timeout => 60,
	cachename_spec => {
		_body => '',
		_headers => []
	}
);
$cached_browser->env_proxy(1);
$cached_browser->conn_cache->total_capacity(undef);
$cached_browser->ssl_opts(verify_hostname => 1, SSL_ca_file => Mozilla::CA::SSL_ca_file());

Lingua::Conjunction->separator_phrase(',');
Lingua::Conjunction->penultimate(0);

if($opts{'m'} || $opts{'w'}) {
	my $l = $ENV{'LANG'};
	if(defined($l) && ($l =~ /^([a-z]{2})/i)) {
		$gp_args{'language'} = lc($1);
	}

	# my $geocoder = Geo::Coder::List->new(cache => CHI->new(driver => 'Memcached', servers => [ '192.168.1.15:11211', '127.0.0.1:11211' ]));
	my $cachedir;
	if(my $e = $ENV{'CACHE_DIR'}) {
		$cachedir = File::Spec->catfile($e, basename($0));
	} else {
		# $cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', basename($0));
		$cachedir = File::Spec->catfile(File::HomeDir->my_home(), '.cache', basename($0));
	}
	if(!-d $cachedir) {
		mkdir $cachedir, 0700 || die "$cachedir: $!";
	}

	my $gopts;
	if(my $redis = $ENV{'REDIS_SERVER'}) {
		$gopts->{'cache'} = CHI->new(
			driver => 'Redis',
			namespace => 'gedcom',
			server => $redis,
			l1_cache => { driver => 'RawMemory', global => 1, max_size => 1024*1024 },
			debug => $opts{'v'}
		);
	} else {
		# FIXME: The location of the geo-coding cache should be configurable
		$gopts->{'cache'} = CHI->new(
			driver => 'File',
			root_dir => $cachedir,
			l1_cache => { driver => 'RawMemory', global => 1, max_size => 1024*1024 }
		);
		# $gopts->{'cache'} = CHI->new(
			# driver => 'Memcached',
			# namespace => 'gedcom',
			# servers => [ '192.168.1.16:11211', '192.168.1.15:11211', '127.0.0.1:11211', '192.168.1.2:11211' ],
			# debug => $opts{'v'},
			# compress_threshold => 10_000
		# );
	}
	$geocoder = Geo::Coder::List->new($gopts);

	$geocoder->push(Geo::Coder::Free::Local->new());

	my %topts;
	if(my $oa = $ENV{'OPENADDR_HOME'}) {
		$topts{'openaddr'} = $oa;
	}
	if($logger) {
		$topts{'logger'} = $logger;
	}
	$topts{'cache'} = CHI->new(
		driver => 'File',
		root_dir => $cachedir,
		l1_cache => { driver => 'RawMemory', global => 1, max_size => 1024*1024 }
	);
	$topts{'cache_duration'} = '1 month';
	$freegeocoder = Geo::Coder::Free->new(%topts);
	if($ENV{'OPENADDR_HOME'}) {
		# $geocoder->push({ regex => qr/,[\w\s]+,[\w\s]+$/, geocoder => $freegeocoder });
		# $geocoder->push({ regex => qr/,\s*(USA|US|United States|Canada|Australia)+$/, geocoder => Geo::Coder::Free::OpenAddresses->new(openaddr => $oa) })
			# ->push({ regex => qr/^[\w\s\-]+?,[\w\s]+,[\w\s]+?$/, geocoder => Geo::Coder::Free->new() });
		# US, Canada and Australia are full
		# Counties and towns in the UK are full
		$geocoder->push({ regex => qr/,\s*(USA|US|United States|Canada|Australia)\s*$/, geocoder => $freegeocoder })
			->push({ regex => qr/^([\w\s]+,)?\s*[\w\s]+,\s*[\w\s]+\s*$/, geocoder => $freegeocoder });
	} else {
		$geocoder->push({ regex => qr/^[\w\s\-]+?,[\w\s]+,[\w\s]+?$/, geocoder => $freegeocoder })
			# E.g. 'Nebraska, USA'
			->push({ regex => qr/^[\w\s]+,\s*(UK|England|Canada|USA|US|United States)$/i, geocoder => $freegeocoder });
	}
	$geocoder->push({ regex => qr/^[\w\s]+,\s*[\w\s]+,\s*(UK|England|Wales|Scotland)$/i, geocoder => $freegeocoder });

	if($google_maps_geolocation_key) {
		# DST isn't that good for the UK
		# $geocoder->push({ regex => qr/(UK|United Kingdom|England|USA|US|United States|Wales)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
		$geocoder->push({ regex => qr/^\d.+?,.+?,\s*(USA|US|United States)$/i, geocoder => Geo::Coder::US::Census->new() })
			->push({ limit => 100, regex => qr/(Canada|USA|US|United States)$/i, geocoder => Geo::Coder::CA->new() })
			->push(Geo::Coder::OSM->new())
			->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::RandMcnally->new() })
			->push({ regex => qr/^[\w\s-]+,\s*[\w\s]+,\s*(UK|United Kingdom|England|Wales)$/i, geocoder => Geo::Coder::Postcodes->new() })
			->push(Geo::Coder::Ovi->new())
			# ->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })	# Off-line
			# ->push({ limit => 200, geocoder => Geo::Coder::XYZ->new()});
			->push({ limit => 100, geocoder => Geo::Coder::GooglePlaces->new(%gp_args) });
			if(my $client = $ENV{'GMAP_CLIENT'}) {
				$gp_args{'client'} = $client;
				$geocoder->push(Geo::Coder::Google->new(%gp_args));
			}
	} else {
		# DST isn't that good for the UK
		# $geocoder->push({ regex => qr/(UK|United Kingdom|England|USA|US|United States|Wales)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
		# $geocoder->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
		$geocoder->push({ regex => qr/^\d.+?,.+?,\s*(USA|US|United States)$/i, geocoder => Geo::Coder::US::Census->new() })
			->push({ limit => 100, regex => qr/(Canada|USA|US|United States)$/i, geocoder => Geo::Coder::CA->new() })
			->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::RandMcnally->new() })
			->push({ regex => qr/^[\w\s-]+,\s*[\w\s]+,\s*(UK|United Kingdom|England|Wales)$/i, geocoder => Geo::Coder::Postcodes->new() })
			->push(Geo::Coder::OSM->new())
			# ->push({ limit => 200, geocoder => Geo::Coder::XYZ->new()})
			->push(Geo::Coder::Ovi->new());
			# ->push(Geo::Coder::Google->new())
			# ->push(Geo::Coder::GooglePlaces->new());
	}

	if(my $key = $ENV{'GEOAPIFY_KEY'}) {
		$geocoder->push(Geo::Coder::GeoApify->new({ apiKey => $key }));
	}

	if(my $username = $ENV{'GEONAMES_USER'}) {	# Rather slow
		$geocoder->push(Geo::GeoNames->new(username => $username));
	}
	if(my $key = $ENV{'GEO_CODER_OPENCAGE_API_KEY'}) {
		$geocoder->push({ limit => 200, geocoder => Geo::Coder::OpenCage->new(api_key => $key) });
	}
	if(my $key = $ENV{BMAP_KEY}) {
		$geocoder->push(Geo::Coder::Bing->new(key => $key));
	}

	my $ua = LWP::UserAgent::Throttled->new(agent => basename($0), keep_alive => 1, timeout => 60);
	$ua->conn_cache->total_capacity(undef);
	$ua->env_proxy(1);
	$ua->default_header(accept_encoding => 'gzip,deflate');
	$ua->ua($cached_browser);

	# TODO: throttle other geocoders
	$ua->throttle({
		'nominatim.openstreetmap.org' => 1,
		'geocode.xyz' => 2,
		'geocoder.ca' => 1,
		'opencagedata.com' => 1,
		'api.postcodes.io' => 1,
		'where.desktop.mos.svc.ovi.com' => 1,
		'geocoding.geo.census.gov' => 1,
		'a2ageo.rmservers.com' => 1,
		'dev.virtualearth.net' => 1,	# Bing
		'api.geonames.org' => 1,
		'yboss.yahooapis.com' => 1,	# Geo::Coder::PlaceFinder
		'www.familysearch.org' => 1,
		'lookup.dbpedia.org' => 1,
	});

	# G::C::GooglePlaces
	$ua->throttle({ 'maps.googleapis.com' => 0.1 }) unless($google_maps_geolocation_key);
	$ua->ssl_opts(verify_hostname => 0);	# prevent "Can't connect to geocode.xyz:443 (certificate verify failed)"
	$geocoder->ua($ua);

	# Geo::Coder::PlaceFinder doesn't support the ua() method
	if((my $ckey = $ENV{'YAHOO_CONSUMER'}) && (my $skey = $ENV{'YAHOO_SECRET'})) {
		$geocoder->push(Geo::Coder::PlaceFinder->new(consumer_key => $ckey, secret_key => $skey, ua => $ua));
	}

	# $textgeocoder = Geo::Parser::Text->new('https://geocoder.ca');
	$textgeocoder = Geo::Parser::Text->new('https://geocode.xyz');
}

# FIXME: Do this properly
# TODO: Fr: Le recensement
my %censusmaps = (
	'1841 England Census' => '1841 UK Census',
	'1841 England, Wales & Scotland Census - Findmypast' => '1841 UK Census',
	'1851 England Census' => '1851 UK Census',
	'1851 Wales Census' => '1851 UK Census',
	'1851 Census' => '1851 UK Census',
	'1851 England, Wales & Scotland Census - Findmypast' => '1851 UK Census',
	'1851 United Kingdom Census Sample' => '1851 UK Census',
	'1861 England Census' => '1861 UK Census',
	'1861 England, Wales & Scotland Census - Findmypast' => '1861 UK Census',
	'1871 England Census' => '1871 UK Census',
	'1871 England, Wales & Scotland Census - Findmypast' => '1871 UK Census',
	'1871 Wales Census' => '1871 UK Census',
	'1881 England Census' => '1881 UK Census',
	'1881 England, Wales & Scotland Census - Findmypast' => '1881 UK Census',
	'1881 Isle of Man Census' => '1881 Isle of Man Census',
	'1881 Wales Census' => '1881 UK Census',
	'1891 England Census' => '1891 UK Census',
	'1891 England, Wales & Scotland Census - Findmypast' => '1891 UK Census',
	'1891 Wales Census' => '1891 UK Census',
	'1901 England Census' => '1901 UK Census',
	'1901 Wales Census' => '1901 UK Census',
	'1901 England, Wales & Scotland Census - Findmypast' => '1901 UK Census',
	'1911 England Census' => '1911 UK Census',
	'1911 England Census Summary Books' => '1911 UK Census',
	'1911 Census for England & Wales - Findmypast' => '1911 UK Census',
	'1911 Wales Census' => '1911 UK Census',
	'1921 Census Of England & Wales - Findmypast' => '1921 UK Census',

	'1851 Census of Canada East, Canada West, New Brunswick, and Nova Scotia' => '1851 Canadian Census',
	'Canada Census 1851 - Findmypast' => '1851 Canadian Census',
	'1861 Census of Canada' => '1861 Canadian Census',
	'Canada Census 1861 - Findmypast' => '1861 Canadian Census',
	'1871 Census of Canada' => '1871 Canadian Census',
	'Canada Census 1871 - Findmypast' => '1871 Canadian Census',
	'Kent County, New Brunswick Census, 1871: Eight Subdistricts' => '1871 Canadian Census',
	'1881 Census of Canada' => '1881 Canadian Census',
	'1881 Canada Census' => '1881 Canadian Census',
	'Canada Census 1881 - Findmypast' => '1881 Canadian Census',
	'1891 Census of Canada' => '1891 Canadian Census',
	'Canada Census 1891 - Findmypast' => '1891 Canadian Census',
	'1901 Census of Canada' => '1901 Canadian Census',
	'Canada Census 1901 - Findmypast' => '1901 Canadian Census',
	'1906 Canada Census of Manitoba, Saskatchewan, and Alberta' => '1906 Canadian Census',
	'Canada Census 1911 - Findmypast' => '1911 Canadian Census',
	'1911 Census of Canada' => '1911 Canadian Census',
	'1916 Canada Census of Manitoba, Saskatchewan, and Alberta' => '1916 Canadian Census',
	'1921 Census of Canada' => '1921 Canadian Census',

	'1790 United States Federal Census' => '1790 US Census',
	'1800 United States Federal Census' => '1800 US Census',
	'1820 United States Federal Census' => '1820 US Census',
	'1830 United States Federal Census' => '1830 US Census',
	'1840 United States Federal Census' => '1840 US Census',
	'1850 United States Federal Census' => '1850 US Census',
	'US Census 1850 - Findmypast' => '1850 US Census',
	'Us Census 1850 - Findmypast' => '1850 US Census',	# Strange...
	'New York, State Census, 1855' => '1855 US State Censuses',
	'1860 United States Federal Census' => '1860 US Census',
	'US Census 1860 - Findmypast' => '1860 US Census',
	'Nebraska, State Census Collection, 1860-1885' => '1860 US State Censuses',
	'New York, State Census, 1865' => '1865 US State Censuses',
	'US Census 1870 - Findmypast' => '1870 US Census',
	'1870 United States Federal Census' => '1870 US Census',
	'New York, State Census, 1875' => '1875 US State Censuses',
	'1880 United States Federal Census' => '1880 US Census',
	'US Census 1880 - Findmypast' => '1880 US Census',
	'Us Census 1880 - Findmypast' => '1880 US Census',
	'US Census 1900 - Findmypast' => '1900 US Census',
	'1900 United States Federal Census' => '1900 US Census',
	'New York, State Census, 1905' => '1905 US State Censuses',
	'1910 United States Federal Census' => '1910 US Census',
	'US Census 1910 - Findmypast' => '1910 US Census',
	'1920 United States Federal Census' => '1920 US Census',
	'US Census 1920 - Findmypast' => '1920 US Census',
	'New York, State Census, 1925' => '1925 US State Censuses',
	'South Dakota, State Census, 1925' => '1925 US State Censuses',
	'US Census 1930 - Findmypast' => '1930 US Census',
	'1930 United States Federal Census' => '1930 US Census',
	'South Dakota, State Census, 1935' => '1935 US State Censuses',
	'US Census 1940 - Findmypast' => '1940 US Census',
	'1940 United States Federal Census' => '1940 US Census',
	'1950 United States Federal Census' => '1950 US Census',

	'Ireland, Census, 1901' => '1901 Ireland Census',
	'Web: Ireland, Census, 1901' => '1901 Ireland Census',
);

# sub realdie
# {
	# CORE::die (@_);
# }

# sub die {
	# my @arg = shift;
#
	# print STDERR "@arg\n" if($arg[0]);
#
	# my $i = 0;
	# while((my @call_details = (caller($i++)))) {
		# print STDERR $call_details[1], ':', $call_details[2], ' in function ', $call_details[3], "\n";
	# }
#
	# realdie @arg;
# }

# $ged->validate();

my $home = $opts{'h'};
if((!defined($home)) && defined($config)) {
	$home = $config->{'home'};
	if(ref($home) eq 'ARRAY') {
		$home = join(' ', @{$home});
	}
}

if($home) {
	$me = $ged->get_individual($home);
	if((!defined($me)) || !ref($me)) {
		die "$0: Can't find '$home' in $ARGV[0]";
	}
}

my $dot;
my $jpegtran;
my $jpegoptim;
if($opts{'F'}) {
	if(-x '/usr/bin/dot') {
		$dot = '/usr/bin/dot';
	} elsif(-x '/usr/local/bin/dot') {
		$dot = '/usr/local/bin/dot';
	} elsif(-x '/sw/bin/dot') {
		$dot = '/sw/bin/dot';
	} elsif(-x '/opt/homebrew/bin/dot') {
		$dot = '/opt/homebrew/bin/dot';
	}

	if(!defined($dot)) {
		complain(warning => 'Graphviz not found, no family trees');
	} else {
		print "Using $dot\n" if($opts{'v'});
	}
}

for my $dir('dynamic-site/data', 'dynamic-site/img', 'static-site') {
	if(-d $dir) {
		File::Path::rmtree($dir);
	}
}

my @dirlist = ('static-site', 'dynamic-site/data', 'dynamic-site/data/people');
if($dot || $opts{'d'}) {
	push @dirlist, 'static-site/img';
	push @dirlist, 'dynamic-site/img';
	push @dirlist, 'thumbs';

	if(-x '/usr/bin/jpegtran') {
		$jpegtran = '/usr/bin/jpegtran';
	} elsif(-x '/usr/local/bin/jpegtran') {
		$jpegtran = '/usr/local/bin/jpegtran';
	} elsif(-x '/opt/local/bin/jpegtran') {
		$jpegtran = '/opt/local/bin/jpegtran';
	} elsif(-x '/sw/bin/jpegtran') {
		$jpegtran = '/sw/bin/jpegtran';
	}
	if(-x '/usr/bin/jpegoptim') {
		$jpegoptim = '/usr/bin/jpegoptim';
	} elsif(-x '/usr/local/bin/jpegoptim') {
		$jpegoptim = '/usr/local/bin/jpegoptim';
	} elsif(-x '/sw/bin/jpegoptim') {
		$jpegoptim = '/sw/bin/jpegoptim';
	}
}

if($gedcal) {
	push @dirlist, 'static-site/calendar';
}

foreach my $dir(@dirlist) {
	mkdir $dir if(!-d $dir);
}

if($opts{'d'} || $opts{'m'}) {
	$browser = LWP::UserAgent->new(agent => basename($0), keep_alive => 1, timeout => 60);
	$browser->env_proxy(1);
	$browser->conn_cache->total_capacity(undef);

	my $cachedir = $ENV{'CACHE_DIR'};
	if($cachedir) {
		mkdir $cachedir, 02700 if(!-d $cachedir);
		$cachedir = File::Spec->catfile($cachedir, 'http-cache-transparent');
	} else {
		# $cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'http-cache-transparent');
		$cachedir = File::Spec->catfile(File::HomeDir->my_home(), '.cache', 'http-cache-transparent');
	}

	if(!-d $cachedir) {
		mkdir $cachedir, 02700 || die "$cachedir: $!";
	}
	HTTP::Cache::Transparent::init({
		BasePath => $cachedir,
		Verbose => $opts{'v'} ? 1 : 0,
		NoUpdate => 60 * 60 * 24,
		MaxAge => 30 * 24
	});
}

# my @everyone = $ged->individuals();
my @everyone = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } $ged->individuals();
# my @everyone = $ged->get_individual('Jocasta Claire Traill Innes');
# my @everyone = $ged->get_individual('May Spratt');
my $total = scalar(@everyone);
if($total == 0) {
	die "$0: gedcom file is empty";
}
my $index = 0;

my $pr;
my $au = Locale::AU->new();
my $ca_en = Locale::CA->new(lang => 'en');
my $ca_fr = Locale::CA->new(lang => 'fr');
my $us = Locale::US->new();
my $dtl = DateTime::Locale->load($ENV{'LC_TIME'} // $ENV{'LC_ALL'} // $ENV{'LANG'});
my $abbr = Geo::Coder::Abbreviations->new();
my $obituaries;
my $wills;

if($opts{'w'}) {
	my $opts = {
		cache => CHI->new(driver => 'Memory', global => 1)
	};
	if($logger) {
		$opts->{'logger'} = $logger;
	}
	$obituaries = Genealogy::Obituary::Lookup->new($opts);
	$wills = Genealogy::Wills->new($opts);
} else {
	$pr = String::ProgressBar->new(max => $total, length => 60);
}

my $meteo;

if($opts{'d'}) {
	$meteo = Weather::Meteo->new(ua => $cached_browser);
}

my $key = delete $opts{'g'};	# Ensure it's not stored in the XML file

my $current_people = delete $opts{'x'};
if($current_people) {
	# Creating a changelog only works if the many of the options are the same
	my $xml = XML::Twig->new();
	$xml->parsefile($current_people);
	my %prev_opts;
	foreach my $key($xml->root()->first_child('opts')->first_child('hashref')->children()) {
		if($key->name() eq 'item') {
			$prev_opts{$key->{'att'}->{'key'}} = $key->first_child()->pcdata();
		}
	}
	my $ok = 1;
	for my $opt('c', 'd', 'h') {
		if(defined($opts{$opt}) ne defined($prev_opts{$opt})) {
			$ok = 0;
			last;
		}
		if(defined($opts{$opt}) && ($opts{$opt} ne $prev_opts{$opt})) {
			$ok = 0;
			last;
		}
	}
	if(!$ok) {
		die "Runtime options aren't the same as given in $current_people\n";
	}
	$current_people = $xml;
}

open(my $xml, '>', 'dynamic-site/data/people.xml');
print $xml "<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n<table>\n";
my $string = XML::Dumper->new()->pl2xml(\%opts);
$string =~ s/perldata/opts/g;
print $xml "\t$string\t<file>$ARGV[0]</file>";

########
# print $xml "\n</table>\n"; exit;
########
my $name;
if($me) {
	$name = 'of ' . $me->as_string(nee => 1);
} else {
	$name = 'on this site';
}
my $html_name = wide_to_html($name);

open(my $csv, '>', 'dynamic-site/data/people.csv');
print $csv "entry!title!home!alive!bio!father!mother!children!citations!notes!media!family_tree!map_head!map_body!dob!dod!profile_thumbnail!marriages!sex!birth_coords!death_coords!birth_country!death_country!warnings\n";

open(my $timeline_xml, '>', 'dynamic-site/timeline.xml');
print $timeline_xml "<?xml version=\"1.0\"?>\n",
	"<data date-time-format=\"iso8601\">\n";

open(my $visjs_html, '>', 'dynamic-site/visjs.html');
print $visjs_html <<'HEADER';
<!DOCTYPE HTML>
<html lang="en" dir="ltr">
<head>
	<meta charset="utf8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="description" content="Explore a dynamic, interactive family tree with vis.js. Visualise relationships and ancestors within the genealogy project using this unique network graph.">
	<title>Interactive Family Tree Visualisation</title>

	<link rel="stylesheet" href="/css/web.css" type="text/css" media="screen">
  <style type="text/css">
    body, html {
	font-family: sans-serif;
	font-size: 10px;
    }
  </style>

  <script async type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.19.1/vis.min.js"></script>
  <link async href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.19.1/vis.min.css" rel="stylesheet" type="text/css" />
  <style type="text/css">
	/* Limit the width of the biography box */
	/*div.vis-tooltip { font-size:10px; white-space: normal; width: 30em; word-wrap: break-word; }*/
	div.vis-tooltip {
		font-size: 10px;
		white-space: normal;
		width: 30em;
		max-width: 300px;
		word-wrap: break-word;
		padding: 5px;
	}
  </style>
</head>

HEADER

if($opts{'h'}) {
	print $visjs_html "<body><center><h1>Interactive Family Tree Visualisation - $opts{'h'} Genealogy Project</h1></center>";
} else {
	print $visjs_html "<body><center><h1>Blood Relatives' Timeline $html_name</h1></center>";
}

print $visjs_html <<'BODY';
	<center>
		[ <a href="cgi-bin/page.fcgi?page=home">Home</a> ] |
		[ <a href="cgi-bin/page.fcgi?page=censuses">Census Index</a> ] |
		[ <a href="cgi-bin/page.fcgi?page=surnames">Surname Index</a> ] |
		[ <a href="cgi-bin/page.fcgi?page=history">Family History</a> ] |
		[ <a href="cgi-bin/page.fcgi?page=todo">To Do</a> ] |
		[ <a href="cgi-bin/page.fcgi?page=calendar">Calendar</a> ]
	</center>
	<p><font size=+1>
		This tool allows you to visualise relationships, track lineage, and delve deeper into the connections between family members, within the family tree.
		Navigate through generations of the family tree, uncovering connections and discovering heritage in a completely interactive way.
		Click and move the mouse to move around the timeline.
		Only people with known birth dates are shown.
	</font></p>

	<div id="visualization">
	    <div class="menu">
		<input type="button" id="zoomIn" value="Zoom In"/>
		<input type="button" id="zoomOut" value="Zoom Out"/>
		<input type="button" id="moveLeft" value="Scroll Left"/>
		<input type="button" id="moveRight" value="Scroll Right"/>
	    </div>
	</div>

<script type="text/javascript">
  // DOM element where the Timeline will be attached
  var container = document.getElementById('visualization');

  // Create a DataSet (allows two way data-binding)
	var items = new vis.DataSet([
BODY

# TODO: Add a -p option to do something like this - it's useful in debugging
# foreach my $person($ged->get_individual('Dolly Cowell')) {
# foreach my $person($ged->get_individual('Ruth Marie Bixler')) {

foreach my $person(@everyone) {
	$index++;
	if(!$opts{'w'}) {
		$| = 1;
		$pr->update($index);
		$pr->write();
		$| = 0;
	}
	if(!defined($person->xref())) {
		complain({ person => $person, warning => 'has no xref' });
		next;
	}
	if(!$printed{$person->xref()}) {
		print $xml "\n\t<person person_id=\"$index\">";
		print_person({ person => $person });
		print $xml "\n\t</person>";
		print $csv "\n";

		dump_geocoder_log();
	}
	last if($opts{'L'} && ($index == $opts{'L'}));
	last if(MAX_INDEX && ($index >= MAX_INDEX));
}
print $xml "\n</table>\n";
close $xml;
close $csv;

print $timeline_xml "</data>\n";
close $timeline_xml;

print $visjs_html <<'FOOTER';
	]);

  // Configuration for the Timeline
  // var options = { zoomable: false, horizontalScroll: true, verticalScroll: true, autoResize: true, height: '500px', min: '1500', max: '2017' };
  var timelineHeight = Math.round($(window).height() * 0.85) + 'px';
var options = {
    zoomKey: 'ctrlKey',
    verticalScroll: true,
    min: '1500',
    max: '2017',
    height: timelineHeight
};

  // Create a Timeline
  var timeline = new vis.Timeline(container, items, options);

    /**
     * Move the timeline a given percentage to left or right
     * @param {Number} percentage   For example 0.1 (left) or -0.1 (right)
     */
    function move (percentage) {
	var range = timeline.getWindow();
	var interval = range.end - range.start;

	timeline.setWindow({
	    start: range.start.valueOf() - interval * percentage,
	    end:   range.end.valueOf()   - interval * percentage
	});
    }

    // attach events to the navigation buttons
    document.getElementById('zoomIn').onclick = function () { timeline.zoomIn( 0.2); };
    document.getElementById('zoomOut').onclick = function () { timeline.zoomOut( 0.2); };
    document.getElementById('moveLeft').onclick = function () { move( 0.2); };
	document.getElementById('moveRight').onclick = function () { move(-0.2); };
</script>
</body>
</html>
FOOTER

close $visjs_html;

if(!$opts{'w'}) {
	print "\n$index records processed\n";
}

undef %all_residences;

my $people_json;

# TODO: add the static site
if($me && (open($people_json, '>', 'dynamic-site/data/people.json'))) {
	print "Creating JSON tree\n";
	my $structure = individual_to_hash($me);
	print $people_json JSON::MaybeXS::to_json($structure, { pretty => 1 });
	link 'dynamic-site/data/people.json', 'static-site/people.json';
}

undef %all_bios;
undef %all_thumbnails;

if(scalar(%censuses)) {
	print "Creating census index\n";

	open(my $html, '>', 'static-site/censuses.html');
	print $html "<html><head><title>Censuses in the Family Tree $html_name</title>",
		"</head><body><center><h1>Censuses in the Family Tree $html_name</h1>";

	if($me) {
		print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ] | ';
	}
	print $html '[ <a href="surnames.html">Surnames Index</a> ]';
	if($opts{'w'}) {
		print $html ' | [ <a href="todo.html">Errors</a> ]';
	}
	if($gedcal) {
		print $html ' | [ <a href="calendar/index.html">Calendar</a> ]';
	}
	print $html ' | [ <a href="calendar/changes.html">Blog</a> ]',
		' | [ <a href="history.html">Family History</a> ]</center>',
		'<br><ul>';

	open($csv, '>', 'dynamic-site/data/censuses.psv');
	print $csv "entry|census|xref\n";

	$index = 1;
	foreach my $census(sort keys(%censuses)) {
		my $filename = $census;
		$filename =~ tr/ /_/;
		print $html "<li><a href=\"$filename.html\">$census</a></li>";

		open(my $chtml, '>', "static-site/$filename.html");
		print $chtml "<html><head><title>The Family Tree $html_name - $census</title>",
			'</head>',
			"<body><center><h1>The Family Tree $html_name - $census</h1>";
		if($me) {
			print $chtml '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
		}
		print $chtml ' | [ <a href="surnames.html">Surnames Index</a> ]';
		if($opts{'w'}) {
			print $chtml ' | [ <a href="todo.html">Errors</a> ]';
		}
		if($gedcal) {
			print $chtml ' | [ <a href="calendar/index.html">Calendar</a> ]';
		}
		if(-r 'static-site/censuses.html') {
			print $chtml ' | [ <a href="censuses.html">Census Index</a> ]';
		}
		print $chtml ' | [ <a href="history.html">Family History</a> ]</center><br>',
			'<ul>';

		foreach my $name(sort keys %{$censuses{$census}}) {
			print $chtml '<li>',
				'<a href="', make_filename_from_person(person => $censuses{$census}->{$name}), '">',
				$name,
				'</a></li>';
			print $csv "$index|\"$census\"|\"", $censuses{$census}->{$name}->xref(), "\"\n";
			$index++;
		}

		print $chtml '</ul></body></html>';
		close $chtml;
	}
	close $csv;

	print $html '</ul></body></html>';
	close $html;

	undef %censuses;
}

if(scalar(%all_locations)) {	# opts{'m'} will be enabled
	print "Creating locations and places databases\n";

	open($csv, '>', 'dynamic-site/data/places.csv');
	print $csv "entry!country!state!town!xref!name!year!date\n";

	# FIXME: in HTML::OSM mode, the body only shows the last location
	open(my $locations_xml, '>', 'dynamic-site/data/locations.xml');
	print $locations_xml '<?xml version="1.0" encoding="US-ASCII"?>', "\n",
		"<locations>\n\t<maps>\n";
	my ($head, $body);
	$index = 1;

	# Sort reverse numerically: https://www.oreilly.com/library/view/perl-cookbook/1565922433/ch04s15.html
	foreach my $year(sort { $b <=> $a } keys(%all_locations)) {
		my %markers;
		foreach my $l(@{$all_locations{$year}}) {
			my $place = place(record => $l->{'record'}, nopreposition => 1);
			$place =~ s/^\s*//;
			push @{$markers{$place}}, $l;
			my @areas = split/,\s*/,$place;
			my @country_state_town;
			if(scalar(@areas) >= 3) {
				@country_state_town = reverse @areas[-3..-1];
			} elsif(scalar(@areas) == 2) {
				@country_state_town = reverse ('', @areas[-2..-1]);
			} elsif(scalar(@areas) == 1) {
				@country_state_town = ($place, '', '');
			} else {
				die 'BUG: place is empty';
			}
			$place = join('!', @country_state_town);
			print $csv "$index!$place!",
				$l->{'person'}->xref(), '!',
				$l->{'person'}->as_string({ middle_names => 1, include_years => 1 }), '!',
				"$year!",
				$l->{'date'}, "\n";
			$index++;
		}

		# Create a map of where everyone lived in each year
		my %args = (geocoder => $geocoder);
		if($javascript_key) {
			$args{'api_key'} = $javascript_key;
		}
		my $map = $maps_module->new(%args);
		foreach my $place(keys %markers) {
			my @annotations = @{$markers{$place}};
			my $html;
			my $previous_date;
			foreach my $annotation(@annotations) {
				my $date = $annotation->{'date'};
				my $person = $annotation->{'person'};
				if($previous_date && ($date eq $previous_date)) {
					if($html) {
						$html .= ', ';
					}
				} else {
					if($html) {
						$html .= '<br>';
					}
					$html .= "$date: ";
					$previous_date = $date;
				}
				$html .= '<a href="?page=people&amp;entry=' . $person->xref() . '">' . $person->as_string() . '</a>';
			}
			add_marker(map => $map, place => HTML::Entities::decode($place), annotation => $html);
		}
		($head, $body) = $map->onload_render();
		$head =~ s/\n\n*/\n/g;
		$head =~ s/http:/https:/;
		print $locations_xml "\t\t<map>\n\t\t\t<entry>$year</entry>\n\t\t\t<head>",
			wide_to_xml($head),
			"\n\t\t\t</head>\n\t\t</map>\n";
	}
	close $csv;
	undef %all_locations;

	# $body =~ s/</&lt;/g;
	# $body =~ s/>/&gt;/g;
	$body = wide_to_html($body);
	$body =~ s/^\n+//;
	$body =~ s/&copy;/&#x0A9;/g;
	$body =~ s/\n+$//;
	print $locations_xml "\t</maps>\n\t<body>$body</body>\n</locations>\n";
	close $locations_xml;
}

# if(scalar(%all_residences)) {
	# $Data::Dumper::Maxdepth = 1;
	# my $tulip = $all_residences{'I372497774729'};
	# foreach my $r (@{$tulip}) {
		# print $r->place(), "\n";
	# }
	# die scalar keys %all_residences;

	# undef %all_residences;
# }

if(scalar(%all_military)) {
	print "Creating military records\n";
	open($csv, '>', 'dynamic-site/data/military.csv');
	print $csv "entry!person!date!place!notes\n";

	$index = 1;
	foreach my $xref(sort keys(%all_military)) {
		foreach my $entry(@{$all_military{$xref}}) {
			print $csv "$index!$xref!", $entry->{'date'} || '', '!', $entry->{'place'} || '', '!', $entry->{'notes'} || '', "\n";
			$index++;
		}
	}
	close $csv;

	undef %all_military;
}

if(scalar(%all_occupations)) {
	print "Creating occupations records\n";
	open($csv, '>', 'dynamic-site/data/occupations.csv');
	print $csv "entry!people\n";

	foreach my $occupation(sort keys(%all_occupations)) {
		print $csv "$occupation!",
			join(',', @{$all_occupations{$occupation}}),
			"\n";
	}
	close $csv;

	undef %all_occupations;
}

if(scalar(%orphans)) {
	print "Creating orphan records\n";
	open($csv, '>', 'dynamic-site/data/orphans.csv');
	print $csv "entry!xrefs\n";

	foreach my $year(sort keys(%orphans)) {
		print $csv "$year!",
			join(',', @{$orphans{$year}}),
			"\n";
	}
	close $csv;

	undef %orphans;
}

if(scalar(%changes) && (open(my $fout, '>', 'static-site/changes.html'))) {
	print "Adding to change blog\n";
	print $fout "<html><head><title>Family History Blog $html_name</title></head>",
		"<body><center><h1>Family History Blog $html_name</h1>";
	if($me) {
		print $fout '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ] | ';
	}
	print $fout '[ <a href="surnames.html">Surnames Index</a> ]';
	if(-r 'static-site/censuses.html') {
		print $fout ' | [ <a href="censuses.html">Census Index</a> ]';
	}
	if($opts{'w'}) {
		print $fout ' | [ <a href="todo.html">Errors</a> ]';
	}
	print $fout ' | [ <a href="calendar/index.html">Calendar</a> ]</center><br>',
		'<ul>';

	if(!-r 'changes.psv') {
		# First run - put in the heading row
		open(my $log, '>', 'changes.psv');
		print $log "date|xref|change\n";
		close $log;
	}
	# Keep a copy in the current directory so that it's not trashed
	# when the data directory is cleared
	# TODO: keep old records on the static site

	open(my $log, '>>', 'changes.psv');

	my $date = DateTime->now(time_zone => 'local')->ymd('');
	my $last_date = '';
	while(my $person = shift(@{$changes{'added_people'}})) {
		print $log "$date|\"",
			$person->xref(),
			"\"|\"New person\"\n";
		if($date ne $last_date) {	# FIXME - old records not kept on the static site
			# print $fout "<h1>$date</h1>";
			$last_date = $date;
			my $d = DateTime->now(time_zone => 'local')->strftime('%e %b %Y');
			print $fout "<h1>$d</h1>";
		}
		print $fout '<li><a href="',
			make_filename_from_person(person => $person), '">',
			wide_to_html($person->as_string(nee => 1)), '</a>: ',
			'New person',
			'</li>';
	}
	while(my $change = shift(@{$changes{'changes'}})) {
		my $person = $change->person();
		print $log "$date|\"",
			$person->xref(),
			'"|"',
			$change->change(),
			"\"\n";
		if($date ne $last_date) {	# FIXME - old records not kept on the static site
			# print $fout "<h1>$date</h1>";
			$last_date = $date;
			my $d = DateTime->now(time_zone => 'local')->strftime('%e %b %Y');
			print $fout "<h1>$d</h1>";
		}
		print $fout '<li><a href="',
			make_filename_from_person(person => $person), '">',
			wide_to_html($person->as_string(nee => 1)), '</a>: ',
			$change->change(),
			'</li>';
	}

	close($fout);
	close($log);
	link('changes.psv', 'dynamic-site/data/changes.psv');
	undef %changes;
}

print "Creating intermarriages database\n";

open($csv, '>', 'dynamic-site/data/intermarriages.csv');
print $csv "entry!spouse!relationship\n";

foreach my $entry(sort keys(%intermarriages)) {
	my $intermarriage = $intermarriages{$entry};
	print $csv "$entry!",
		$intermarriage->{'spouse_xref'}, '!',
		$intermarriage->{'relationship'}, "\n";
}
close $csv;

print "Creating twins database\n";

open($csv, '>', 'dynamic-site/data/twins.csv');
print $csv "entry!twin\n";

foreach my $twin(sort keys(%twins)) {
	print $csv "$twin!$twins{$twin}\n";
}
close $csv;

print "Creating surname database\n";
open(my $html, '>', 'static-site/surnames.html');
print $html "<html><head><title>Surnames in the Family Tree $html_name</title>",
	'<link rel="stylesheet" href="https://genealogy.nigelhorne.com/css/web.css" type="text/css" media="screen">',
	"</head><body><center><h1>Surnames in the Family Tree $html_name</h1>";
if($me) {
	print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ] | ';
}
if(-r 'static-site/censuses.html') {
	print $html '[ <a href="censuses.html">Census Index</a> ] | ';
}
if($opts{'w'}) {
	print $html '[ <a href="todo.html">Errors</a> ] | ';
}

print $html '[ <a href="calendar/index.html">Calendar</a> ]',
	' | [ <a href="calendar/changes.html">Blog</a> ]',
	' | [ <a href="history.html">Family History</a> ]</center>',
	'<br><ul>';

open($csv, '>', 'dynamic-site/data/surnames.csv');
print $csv "entry!surname!filename!person\n";
$index = 1;

foreach my $surname(sort keys %{$surnames}) {
	my $name = $surname;

	if($name eq '') {
		$name = 'UNKNOWN';
	}
	$name =~ s/^&scaron;/&Scaron;/;
	my $filename = $name;

	# https://github.com/nigelhorne/ged2site/issues/117
	$filename =~ s/&apos;/APOS/g;
	$filename =~ s/&ccaron;/CCARON/gi;
	$filename =~ s/&scaron;/SCARON/gi;
	$filename =~ s/&zcaron;/ZCARON/gi;

	print $html "<li><a href=\"$filename.html\">$name</a> (";
	# FIXME: "Implicit scalar context for hash in null operation"
	my $count = scalar(keys %{$surnames->{$surname}});
	if($count == 1) {
		print $html '1 person';
	} else {
		print $html "$count people";
	}
	print $html ')</li>';

	open(my $shtml, '>', "static-site/$filename.html");
	print $shtml "<html><head><title>The Family Tree $html_name - $surname</title>",
		'<link rel="stylesheet" href="https://genealogy.nigelhorne.com/css/web.css" type="text/css" media="screen">',
		'</head>',
		"<body><center><h1>The Family Tree $html_name - $surname</h1>";
	if($me) {
		print $shtml '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ] | ';
	}
	if($gedcal) {
		print $shtml '[ <a href="calendar/index.html">Calendar</a> ] | ';
	}
	print $shtml '[ <a href="surnames.html">Surnames Index</a> ]',
		' | [ <a href="history.html">Family History</a> ]';
	if($opts{'w'}) {
		print $shtml ' | [ <a href="todo.html">Errors</a> ]';
	}
	if(-r 'static-site/censuses.html') {
		print $shtml ' | [ <a href="censuses.html">Census Index</a> ]';
	}
	print $shtml '</center><br><ul>';

	foreach my $person(sort keys %{$surnames->{$surname}}) {
		# print "\t$person maps to ", $surnames->{$surname}->{$person}, "\n";
		print $shtml '<li>',
			'<a href="', make_filename_from_person(person => $surnames->{$surname}->{$person}), "\">",
			wide_to_html($person),
			'</a></li>';
		print $csv "$index!$name!$filename!", $surnames->{$surname}->{$person}->xref(), "\n";
		$index++;
	}

	print $shtml '</ul></body></html>';
	close $shtml;
}

close $csv;
print $html '</ul></body></html>';
close $html;

undef $surnames;

if((!defined($key)) && defined($config)) {
	$key = $config->{'google_verification'};
}
if($key) {
	open($html, '>', "static-site/$key.html");
	print $html "google-site-verification: $key.html";
	close $html;
	if(-r "dynamic-site/$key.html") {
		unlink "dynamic-site/$key.html";
	}
	if($^O eq 'MSWin32') {
		copy("static-site/$key.html", "dynamic-site/$key.html");
	} else {
		link "static-site/$key.html", "dynamic-site/$key.html";
	}
}

if(open($csv, '>', 'dynamic-site/data/name_date.csv')) {
	# Ready for HTML::TagCloud
	print $csv "entry!name!count!sex!people\n";
	$index = 1;

	foreach my $date(sort keys %name_date) {
		foreach my $firstname(sort keys %{$name_date{$date}}) {
			my $count = scalar(@{$name_date{$date}{$firstname}});
			my $sex = Text::Names::guessGender($firstname) || Text::Names::GB::guessGender($firstname) || '?';
			my $people = join('--', @{$name_date{$date}{$firstname}});
			print $csv "$date!$firstname!$count!$sex!$people\n";
		}
	}
	close $csv;
}

if(open($csv, '>', 'dynamic-site/data/surname_date.csv')) {
	# Ready for HTML::TagCloud
	print $csv "entry!name!count!people\n";
	$index = 1;

	foreach my $date(sort keys %surname_date) {
		foreach my $surname(sort keys %{$surname_date{$date}}) {
			my $count = scalar(@{$surname_date{$date}{$surname}});
			my $people = join('--', @{$surname_date{$date}{$surname}});
			print $csv "$date!$surname!$count!$people\n";
		}
	}
	close $csv;
}

# Output the warnings last, so that all are included
if($opts{'w'}) {
	open(my $html, '>', 'static-site/todo.html');
	print $html "<html><head><title>Errors in the Family Tree $html_name</title>",
		"</head><body><center><h1>Errors in the Family Tree $html_name</h1>";
	if($me) {
		print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ]';
	}
	print $html ' | [ <a href="surnames.html">Surnames Index</a> ]';
	if(-r 'static-site/censuses.html') {
		print $html ' | [ <a href="censuses.html">Census Index</a> ]';
	}
	print $html ' | [ <a href="calendar/index.html">Calendar</a> ]',
		' | [ <a href="history.html">Family History</a> ]</center><br>';

	open(my $csv, '>', 'dynamic-site/data/todo.csv');
	print $csv "entry!xref!title!summary!error\n";
	my $index = 1;

	foreach my $person(@everyone) {
		next if((!$opts{'l'}) && is_alive(person => $person));

		if($person->{'warnings'}) {
			print $html '<h2>',
				'<a href="', make_filename_from_person(person => $person), '">',
				HTML::Entities::encode($person->as_string({ middle_names => 1, include_years => 1 })),
				'</a></h2>',
				map { HTML::Entities::encode($_) . '<br>' } @{$person->{'warnings'}};
			my %seen_warnings;
			foreach my $warning(@{$person->{'warnings'}}) {
				next if($seen_warnings{$warning});
				my $summary;
				if($warning =~ /^\[\d+\]: no citation title/) {
					$summary = 'Citation Title Missing';
				} elsif($warning =~ /^(.+) date .+ has no citations/) {
					$summary = "$1 Date Without Citation";
				} elsif($warning =~ /^(.+) place .+ has no citations/) {
					$summary = "$1 Place Without Citation";
				} elsif($warning =~ /^Residence record for .+ contains no citation$/) {
					$summary = 'Residence Without Citation';
				} elsif($warning =~ /^Contains a residence .+ without a date/) {
					$summary = 'Residence Without a Date';
				} elsif($warning =~ /.+in notes is not found$/) {
					$summary = 'URL in notes not found';
				} elsif($warning =~ /^Unhandled event type:/) {
					$summary = 'Unhandled Event Type';
				} elsif($warning =~ /^Census information missing between /) {
					$summary = 'Missing Census';
				} elsif($warning eq '1939 UK register information missing') {
					$summary = 'Missing Census';
				} elsif($warning =~ /^Check the gender of the record/) {
					$summary = 'Possibly Wrong Gender';
				} elsif($warning =~ /^Two residence records for/) {
					$summary = 'Residence Records for the Same Date that Don\'t Match';
				} elsif(($warning =~ /^Year of baptism .+ is before the year of birth /) ||
					($warning =~ /^Date of baptism .+ before date of birth /)) {
					$summary = 'Baptism before birth';
				} elsif($warning =~ /^Year of residence .+ is after the year of death /) {
					$summary = 'Residence after death';
				} elsif($warning =~ /^Born less than 10 months before sibling /) {
					$summary = 'Born Under 10 Months Before Sibling';
				} elsif($warning =~ /^married when less than 16 years old/) {
					$summary = 'Under Age 16 When Married';
				} elsif($warning =~ /^unknown sex/) {
					$summary = 'Sex Not Specified';
				} elsif($warning =~ /^married, but no husband relationship/) {
					$summary = 'Husband Relationship Missing';
				} elsif($warning =~ /^Departure record without destination/) {
					$summary = 'Departure Without Destination';
				} elsif($warning =~ /^Census information not used to approximate a date of birth/) {
					$summary = 'Date of Birth not Calculated';
				} elsif($warning =~ /^Census information not used to determine a parent/) {
					$summary = 'Parent not Determined from Census';
				} elsif($warning =~ /^Baptism information not used to determine a parent/) {
					$summary = 'Parent not Determined from Baptism';
				} elsif($warning =~ /^Unknown state in/) {
					$summary = 'Unknown US State';
				} elsif($warning =~ /^Residence information in/) {
					$summary = 'Child\'s Location is Known but Parent\'s is not';
				} elsif($warning =~ /^Unknown birth location/) {
					$summary = 'Birth location not found';
				} elsif($warning =~ /^Unknown death location/) {
					$summary = 'Death location not found';
				} elsif($warning =~ /\sisn't found$/) {
					$summary = 'Location not found';
				} elsif($warning =~ /^Something is wrong with the date /) {
					$summary = 'Inconsistent Date';
				} elsif($warning =~ /^born before parent was born/) {
					$summary = 'Born before Parent was born';
				} elsif($warning =~ /^Date of residence .+ is after date of death/) {
					$summary = 'Date of Residence After Date of Death';
				} elsif(($warning =~ /^Location for the event /) ||
					($warning =~ /^Location for .+ is empty$/)) {
					$summary = 'Location is Empty';
				} elsif($warning =~ /^Parent .+ is listed in the residence for .+ but this child is not/) {
					$summary = 'Parent\'s Location is Known but Child\'s is not';
				} elsif($warning =~ /^The census for the year \d{4} has been cited,/) {
					$summary = 'Census exists but no residence added';
				} elsif($warning =~ /^Residence record for .+ contains no location/) {
					$summary = 'Residence Record Missing Location';
				} elsif($warning =~ /^Census for \d{4} after year of death/) {
					$summary = 'Census after death';
				} elsif($warning =~ /not living at same address as spouse/) {
					$summary = 'Spouses not at same address';
				} elsif($warning =~ /listed in the residence for .+, but spouse.+is not/i) {
					$summary = 'Spouse location is missing';
				} elsif($warning =~ /residence is very close probably should be recorded as the same address/i) {
					$summary = 'Possible address errors';
				} elsif($warning =~ /residence is same location probably should be recorded as the same address/i) {
					$summary = 'Possible address errors';
				} elsif($warning =~ /^http.+ not found$/) {
					$summary = 'Website in notes is not found';
				} elsif($warning =~ /^Duplicate residence on /) {
					$summary = 'Duplicate Residence';
				} elsif($warning =~ /^Changing 'United States' to 'USA' in /) {
					$summary = 'Changed &quot;United States&quot; to &quot;USA&quot;';
				} elsif($warning =~ /Location for .+ differs from /) {
					$summary = 'Inconsistent Location';
				} elsif($warning =~ /Date of residence \(.+\sdiffers from\s/i) {
					$summary = 'Date of Residence Differs From Parent\'s';
				} elsif($warning =~ /^Country not included in country,/) {
					$summary = 'Country missing or misspelt';
				} elsif($warning =~ /^Can't parse the name - assuming first name: /) {
					$summary = "Can't parse the name";
				} elsif($warning =~ /Not living with either parent in childhood when aged \d/) {
					$summary = 'Not living with either parent in childhood';
				} elsif($warning =~ /^Check out https?:\/\/chroniclingamerica.loc.gov/) {
					# FIXME: Lots of false positives
					next;
				} elsif(($warning =~ /^Check out https:\/\/mlarchives.rootsweb.com\/listindexes\/emails?listname=gen-obit/) ||
					($warning =~ /^Check out https:\/\/www.freelists.org\/post\/obitdailytimes\/Obituary-Daily-Times-v/) ||
					($warning =~ /^Check out https:\/\/wayback\.archive\-it\.org\/20669\/20231102044925\/https:\/\/mlarchives.rootsweb.com\/listindexes/)) {
					$summary = 'Check out Obituary Daily Times';
				} elsif($warning =~ /^Check out .*mrawson/) {
					$summary = 'Check out Kent Wills Transcription';
				} elsif($warning =~ /^Missing house number /) {
					$summary = 'Missing house number';
				} elsif($warning =~ /^Adding date of burial as/) {
					$summary = 'Guessed at date of burial';
				} elsif($warning =~ /\d changed to \d/) {
					$summary = 'Changed format of date';
				} elsif($warning =~ /should start with 'Bef'/) {
					$summary = "Date should start with 'Bef'";
				} elsif($warning =~ /should be 3 letters/) {
					$summary = 'Month should be 3 letters';
				} elsif($warning =~ /Invalid date format for date of/) {
					$summary = 'Invalid date format';
				} elsif($warning =~ /Leading comma in/) {
					$summary = 'Leading comma in placename';
				} elsif($warning =~ /Capitalizing month in date of death/) {
					$summary = 'Capitalizing month in date of death';
				} elsif($warning =~ /Consecutive commas found in/) {
					$summary = 'Consecutive commas found in place name';
				} elsif($warning =~ /assuming country of death is USA/) {
					$summary = 'Assuming country of death is USA';
				} elsif($warning =~ /Location for.+military service /) {
					$summary = 'Missing Location for Military Service';
				} elsif($warning =~ /^Removing leading 0 from/) {
					$summary = 'Removing Leading Zero';
				} elsif($warning =~ /^Unknown event type/) {
					$summary = 'Unhandled Event Type';
				} elsif($warning =~ /^Census ward number left in location /) {
					$summary = 'Census Ward Number Left in Location';
				} elsif($warning =~ /^Changing date .+ to .+/) {
					$summary = 'Date Format Changed'
				} elsif($warning =~ /Date of birth of child .+ is later than .+ own date of death/) {
					$summary = 'Child born before date of death';
				} elsif($warning =~ / assuming country of birth is /) {
					$summary = 'Guessed at country of birth';
				} elsif($warning =~ /^Child .+ which is before the date of birth of'/) {
					$summary = 'Child born before parent';
				} elsif($warning =~ /^Moved from .+ and back again/) {
					$summary = 'Moved from A to B and back again - check for correctness';
				} elsif($warning =~ /^Only \d.+ years old at time of birth of their child/) {
					$summary = 'Child born to very young parent';
				} elsif($warning =~ /but the addresses don't match or aren't detailed enough to be sure$/) {
					$summary = 'Unsure if living with parent in childhood or not';
				} elsif($warning =~ /^The places .+ seem similar/) {
					$summary = 'Similar sounding place names - check for typos';
				} elsif($warning =~ /^Ignoring Newspaper Death Notice /) {
					$summary = 'Ignoring Newspaper Death Notice';
				} elsif($warning =~ /^Possible burial link /) {
					$summary = 'Possible Burial Information';
				} elsif($warning =~ /^Assuming not alive based on/) {
					$summary = 'Death Record Missing for People Assumed Dead';
				} elsif($warning =~ /^Birthplace is set to .+ but birth place is empty/) {
					$summary = 'Birthplace is known, but the record is missing';
				} elsif($warning =~ /^Deathplace is set to .+ but death place is empty/) {
					$summary = 'Deathplace is known, but the record is missing';
				} elsif($warning =~ /^Only \d+ years old at time of birth of their child/) {
					$warning = 'Age at birth of a child too young';
				} else {
					$summary = $warning;
					$summary =~ s/\"//g;
				}
				my $name = wide_to_html($person->as_string(include_years => 1));
				print $csv "$index!",
					$person->xref(),
					"!$name!$summary!",
					wide_to_html($warning),
					"\n";
				$seen_warnings{$warning} = $index;
				$index++;
			}
		}
	}
	close $csv;
	close $html;
}

if($facts) {
	my @fams = $ged->families();
	$facts->{'number_of_families'} = scalar(@fams);
	$facts->{'number_of_individuals'} = $facts->{'count'};	# TODO: replace count with number of individuals
}

$ged = undef;
@everyone = undef;

if($gedcal) {
	print "Creating calendar\n";
	if(open(my $fout, '>', 'static-site/calendar/index.html')) {
		print $fout "<html><head><title>Genealogy Calendar $html_name</title></head>",
			"<body><center><h1>Genealogy Calendar $html_name</h1>";
		if($me) {
			print $fout '[ <a href="../', make_filename_from_person(person => $me), '">Home</a> ]';
		}
		print $fout ' | [ <a href="../surnames.html">Surnames Index</a> ]';
		if(-r 'static-site/censuses.html') {
			print $fout ' | [ <a href="../censuses.html">Census Index</a> ]';
		}
		if($opts{'w'}) {
			print $fout ' | [ <a href="../todo.html">Errors</a> ]';
		}
		print $fout ' | [ <a href="../history.html">Family History</a> ]</center><br><ul>';
		my $pr = String::ProgressBar->new(max => 12, length => 60);
		foreach my $month(1..12) {
			if(open(my $fin, '-|', "$gedcal -dHLm $month '$ARGV[0]'")) {
				$| = 1;
				$pr->update($month);
				$pr->write();
				$| = 0;
				print $fout "<li><a href=\"$month.html\">", @{$dtl->month_format_wide()}[$month - 1], '</a></li>';
				open(my $mout, '>', "static-site/calendar/$month.html");
				while(<$fin>) {
					print $mout $_;
				}
				close $fin;
			}
		}
		print "\n";
		print $fout '</ul></body></html>';
	}
}

if(open(my $fout, '>', 'static-site/history.html')) {
	print "Creating family history page\n";
	print $fout "<html><head><title>Family History $html_name</title></head>",
		"<body><center><h1>Family History $html_name</h1>";
	if($me) {
		print $fout '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ] | ';
	}
	print $fout '[ <a href="surnames.html">Surnames Index</a> ]';
	if(-r 'static-site/censuses.html') {
		print $fout ' | [ <a href="censuses.html">Census Index</a> ]';
	}
	if($opts{'w'}) {
		print $fout ' | [ <a href="todo.html">Errors</a> ]';
	}
	print $fout ' | [ <a href="calendar/index.html">Calendar</a> ]</center><br>';
	# my @sorted_events = Sort::Key::DateTime::dtkeysort { $all_events{$_}->{'date'} } keys %all_events;
	my @sorted_events = sort {
		datecmp($all_events{$a}->{'date'}, $all_events{$b}->{'date'})
	} keys %all_events;
	my $year;
	my $index = 1;
	open(my $csv, '>', 'dynamic-site/data/history.csv');
	print $csv "entry!year!month!day!xref!title!event\n";
	while(my $e = shift @sorted_events) {
		$e = $all_events{$e};
		my $date = $e->{'date'};
		if(ref($date)) {
			if(!(defined($year)) || ($date->year() != $year)) {
				if($year) {
					print $fout '</ul>';
				}
				$year = $date->year();
				print $fout "<h2>$year</h2><ul>";
			}
			my $person = $e->{'person'};
			my $string = wide_to_html($person->as_string());
			print $fout '<li>', @{$dtl->month_format_wide()}[$date->month() - 1], ' ',
				$date->day(), ': <a href="',
				make_filename_from_person(person => $person), '">',
				"$string</a>: ",
				$e->{'event'},
				'</li>';
			print $csv "$index!$year!",
				$date->month(), '!',
				$date->day(), '!',
				$person->xref(), '!',
				"$string!",
				$e->{'event'},
				"\n";
		} elsif($date =~ /^\d{3,4}$/) {
			# date is a simple scalar just with the year
			if(!(defined($year)) || ($date != $year)) {
				if($year) {
					print $fout '</ul>';
				}
				$year = $date;
				print $fout "<h2>$year</h2><ul>";
			}
			my $person = $e->{'person'};
			my $string = wide_to_html($person->as_string());
			print $fout '<li>',
				'<a href="',
				make_filename_from_person(person => $person), '">',
				"$string</a>: ",
				$e->{'event'},
				'</li>';
			print $csv "$index!$year!",
				'!',
				'!',
				$person->xref(), '!',
				"$string!",
				$e->{'event'},
				"\n";
		}
		$index++;
	}
	close $csv;
	print $fout '</ul></body></html>';
	close $fout;
}

# TODO: modify the facts template to show the average age at death
if($facts && open(my $json, '>', 'dynamic-site/data/facts.json')) {
	print "Creating facts page\n";

	if(my $fb = $facts->{'first_birth'}) {
		$facts->{'first_birth'}->{'date'} = $fb->{'date'}->strftime('%x');
	}
	if(my $oa = delete $facts->{'oldest_age'}->{'age'}) {
		$facts->{'oldest_age'}->{'years'} = $oa->years();
		$facts->{'oldest_age'}->{'months'} = $oa->months();
		$facts->{'oldest_age'}->{'days'} = $oa->days();
	}
	if(my $om = delete $facts->{'oldest_marriage'}->{'age'}) {
		$facts->{'oldest_marriage'}->{'years'} = $om->years();
		$facts->{'oldest_marriage'}->{'months'} = $om->months();
		$facts->{'oldest_marriage'}->{'days'} = $om->days();
	}
	if(my $ym = delete $facts->{'youngest_marriage'}->{'age'}) {
		$facts->{'youngest_marriage'}->{'years'} = $ym->years();
		$facts->{'youngest_marriage'}->{'months'} = $ym->months();
		$facts->{'youngest_marriage'}->{'days'} = $ym->days();
	}
	if(my $lm = delete $facts->{'longest_marriage'}->{'length'}) {
		$facts->{'longest_marriage'}->{'years'} = $lm->years();
		$facts->{'longest_marriage'}->{'months'} = $lm->months();
		$facts->{'longest_marriage'}->{'days'} = $lm->days();
	}
	if(my $fs = $facts->{'family_size'}) {
		# Average family size
		$fs->{'mean'} = nearest(0.001, $fs->{'size'} / $fs->{'count'});
	}
	print $json encode_json($facts);
	close $json;

	undef $facts;
}

sub print_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# Gather the information on this person
	my $person = $params{'person'};
	# return unless($person->xref() eq 'I_415355352');

	# $fetcher = Data::Fetch->new();	# Throw away old values from the cache

	my $dateofbirth;

	# https://github.com/nigelhorne/ged2site/compare/master...jhannah:ged2site:115-bday-of-living-is-private?expand=1
	if(!is_alive($person)) {
		$dateofbirth = dateofbirth($person);

		# ACOM starts approximate dates with "Abt." instead of "ABT".
		if(defined($dateofbirth) && length($dateofbirth)) {
			$dateofbirth =~ tr/\.\-/  /;
			$dateofbirth =~ s/\s{2,}/ /gs;
			# FIXME: ../../../gedcoms/gl120368.ged puts dates *inside*
			#	brackets
			$dateofbirth =~ s/\(.+$//;	# some people put information in brackets after the date
			if($dateofbirth =~ /^About[:\s](.+)/i) {
				$dateofbirth = "ABT $1";
			} elsif($dateofbirth =~ /^Bet\s[a-z]{3}.+([a-z]{3}\s+.*)/i) {	# Bet Jun-Jul 1860
				$dateofbirth = "ABT $1";
			} elsif($dateofbirth =~ /^(.+)\s*\?/i) {
				$dateofbirth = "ABT$1";
			}
			if(($dateofbirth !~ /^[\d\sA-Z\/]+$/i) && ($dateofbirth !~ /^Abt\./)) {
				if($dateofbirth =~ /(\d{4})\s*(.+)/) {
					my $d = $1;
					my $t = $2;
					# Allow 1914-1918
					if($t !~ /\d{3,4}$/) {
						$dateofbirth = "ABT$d";
						if(place({ person => $person, place => $t })) {
							complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the location record" });
						} else {
							complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the note field" });
						}
					}
				} elsif($dateofbirth !~ /\d{1,2}$/) {	# Dates can begin with a letter in the US
					complain({ person => $person, warning => "Invalid character in date of birth $dateofbirth" });
					$dateofbirth = undef;
				}
			}
		} else {
			undef $dateofbirth;
		}
	}

	print 'Processing ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

	my @siblings = $person->siblings();
	@siblings = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {}, quiet => 1 }) } @siblings;
	my $mother = $person->mother();
	my $father = $person->father();
	if($father) {
		$father = Class::Simple::Readonly::Cached->new({ object => $father, cache => {}, quiet => 1 });
	}
	if($mother) {
		$mother = Class::Simple::Readonly::Cached->new({ object => $mother, cache => {}, quiet => 1 });
	}
	my @spouses = $person->spouse();
	@spouses = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {}, quiet => 1 }) } @spouses;

	# TODO: Properly chart which spouse a child comes from
	if($opts{'w'}) {
		my $family;
		foreach my $f($person->fams()) {
			if($f->number_of_children()) {
				$family = $f;
				last;
			}
		}

		if((!$family) && (scalar(@siblings) == 0) && (!$mother) && !$father) {
			if(scalar(@spouses) == 0) {
				# This person isn't connected to anyone
				# TODO: catch "islands" of people connected to each other, but nobody else
				complain({ person => $person, warning => 'Not connected to the tree' });
			} elsif(scalar(@spouses) == 1) {
				my $spouse = $spouses[0];
				my $sf;
				foreach my $f($spouse->fams()) {
					if($f->number_of_children()) {
						$sf = $f;
						last;
					}
				}
				my @ss = $spouse->spouse();
				if((!$sf) && (!$spouse->mother()) && (!$spouse->father()) && (!$spouse->siblings()) && (scalar(@ss) == 1)) {
					complain({ person => $person, warning => 'Spouses connect to each other but no-one else' });
				}
			}
		}
		if((!$family) && (scalar(@siblings) == 1) && (scalar(@spouses) == 0) && (!$mother) && !$father) {
			my $sibling = $siblings[0];
			my $sf;
			foreach my $f($sibling->fams()) {
				if($f->number_of_children()) {
					$sf = $f;
					last;
				}
			}
			my @ss = $sibling->spouse();
			if((!$sf) && (!$sibling->mother()) && (!$sibling->father()) && (scalar(@ss) == 0)) {
				complain({ person => $person, warning => 'Siblings connect to each other but no-one else' });
			}
		}

		# FIXME: needs to only complain about more than two biological parents
		my @parents = $person->parents();
		if(scalar(@parents) > 2) {
			complain({ person => $person, warning => 'Has more than two parents' });
		}
	}

	my $year = (localtime)[5];
	$year += 1900 if($year < 1900);

	my $dateofdeath = dateofdeath($person);

	my $yod;	# Year of death
	if($dateofdeath) {
		$yod = get_year_from_date($dateofdeath);
		if(!defined($yod)) {
			complain({ person => $person, warning => "Invalid date of death $dateofdeath" });
		}
	}

	my $yob;	# Year of birth
	if($dateofbirth) {
		$yob = get_year_from_date($dateofbirth);
		if(!defined($yob)) {
			complain({ person => $person, warning => "Invalid date of birth $dateofbirth" });
		}
	}

	my $name = $person->name();
	$name =~ s/\///g;
	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	my $firstname = $name_components{'given_name_1'} // $name_components{'initials_1'};
	# my $surname = $name_components{'surname_2'} || $name_components{'surname_1'};
	my $surname = $person->surname(); # RT109786
	if($surname) {
		$surname = ucfirst(lc(wide_to_html($surname)));
	}

	if($opts{'w'}) {
		# Look to see if this person also appears elsewhere in the tree
		my $string_args = {
			include_years => 1,
			middle_names => 1,
			nee => 1
		};
		foreach my $possible(@{$params{'everyone'}}) {
			next if($possible->xref() eq $person->xref());
			next if(lc($possible->surname()) ne lc($surname));
			next if($surname eq '?');
			my $given = lc(given_names($person));
			next if($given ne lc(given_names($possible)));

			if($yob) {
				if(my $pdob = dateofbirth($possible)) {
					my $year = get_year_from_date($pdob);
					next if(abs($yob - $year) > 2);
					if((my $f1 = $person->father()) && (my $f2 = $possible->father())) {
						if((my $fdob = dateofbirth($f1)) && (my $pfdob = dateofbirth($f2))) {
							# Fathers born more than 10 years apart - not a dup
							next if(abs(get_year_from_date($fdob) - get_year_from_date($pfdob)) > 10);
						}
					}
					complain({ person => $person, warning => 'potential duplicate person found' });
					# DEBUG: warn while looking for false positives
					warn 'Potential match: ', $person->as_string($string_args), "/$yob/$year/", $possible->as_string($string_args);
				} elsif(my $pdod = dateofdeath($possible)) {
					my $year = get_year_from_date($pdod);
					next if(abs($yob - $year) > 2);	# Born more than two years after the possible match died
					die 'TODO: Potential match: ', $person->as_string($string_args), '/', $possible->as_string($string_args);
				}
			} elsif($yod) {
				if(my $pdob = dateofbirth($possible)) {
					my $year = get_year_from_date($pdob);
					next if(abs($yod - $year) > 2);	# Died more than two years before the possible match was born
					die 'TODO: Potential match: ', $person->as_string($string_args), '/', $possible->as_string($string_args);
				}
			} elsif(my $relationship = $person->relationship($possible)) {
				next if($relationship eq 'father');
				next if($relationship eq 'mother');
				next if($relationship eq 'son');
				next if($relationship eq 'daughter');
				die 'TODO: Potential match: ', $person->as_string($string_args), '/', $possible->as_string($string_args);
			} elsif($given ne '?') {
				complain({ person => $person, warning => 'Potential match: ' . $person->as_string($string_args) . '/' . $possible->as_string($string_args) });
				return;
			}
		}
	}


	if((!defined($firstname)) && ($name =~ /(.+)\s(.+)/)) {
		# $firstname = $1;
		$firstname = ucfirst(lc(wide_to_html(given_names($person)))); # RT109786
		if(!defined($surname)) {
			$surname = $2;
		}
		my $f = $firstname;
		my $s = $surname;
		# # utf8::decode($f);
		# # utf8::decode($s);
		# $f = wide_to_html($f);
		# $s = wide_to_html($s);
		complain({ person => $person, warning => "Can't parse the name - assuming first name: $f, last name: $s" });
	}

	if($firstname && ($firstname =~ /\d/)) {
		complain({ person => $person, warning => 'First name contains a digit' });
	}
	if($surname) {
		if($surname =~ /\d/) {
			complain({ person => $person, warning => 'Last name contains a digit' });
		} elsif($mother && $father && (uc($mother->surname()) ne uc($surname)) && (uc($father->surname()) ne uc($surname))) {
			complain({ person => $person, warning => 'Surname is different from both parents' });
		}
	}

	my $sex = $person->sex();
	my $pronoun = $person->pronoun();

	my $parse_tree = {
		'name' => $firstname,
		'sex' => $sex,
		'pronoun' => $pronoun,
		'possessive' => $sex eq 'M' ? 'his' : 'her',
		'object' => $sex eq 'M' ? 'him' : 'her',
		'is_alive' => is_alive($person),
		'person' => $person,
		'dateofbirth' => $dateofbirth,
		'dateofdeath' => $dateofdeath,
	};

	if($yob) {
		my $bucket = floor($yob / 25);
		# Ensure last name isn't used if the first name isn't known
		if($firstname && given_names($person)) {
			push @{$name_date{$bucket}{$firstname}}, $person->xref();
		}
		if($surname) {
			push @{$surname_date{$bucket}{$surname}}, $person->xref();
		}
	}

	my $is_alive = is_alive(person => $person);
	my $title;
	if($is_alive && !$opts{'l'}) {
		print $csv $person->xref(), '!', given_names($person), '!';
			# $person->as_string({ middle_names => 1, title => 1 }), '!';
		if(!defined($firstname)) {
			$firstname = sortoutcase(i18n('living person'));
		}
		$title = wide_to_html($firstname);
	} else {
		$title = wide_to_html($person->as_string({
			include_years => 1,
			nee => 1,
			middle_names => 1,
			title => 1,
		}));
		print $csv $person->xref(), "!$title!";
	}

	print "Starting output\n" if($opts{'v'});

	my $xtitle = wide_to_xml($title);

	open(my $person_xml, '>', File::Spec->catfile('dynamic-site', 'data', 'people', $person->xref() . '.xml'));
	print $person_xml "<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n<table>\n\t<person>\n",
		"\t\t<title>$xtitle</title>";

	my $both_xmls = File::Print::Many->new(fds => [$xml, $person_xml]);
	$both_xmls->print("\n\t\t<xref>", $person->xref(), '</xref>');
	if($firstname) {
		$both_xmls->print("\n\t\t<first_name>", wide_to_xml($firstname))
			->print('</first_name>');
	}
	if($surname) {
		$both_xmls->print("\n\t\t<surname>")->print(wide_to_xml($surname))->print('</surname>');
	}

	my $filename = File::Spec->catfile('static-site', 'index.html');
	if($me && ($person->xref() eq $me->xref())) {
		if(!-e $filename) {
			open(my $index_html, '>', $filename);
			print $index_html '<html>';
			my $name = wide_to_html($person->as_string(nee => 1));

			print $index_html "<head><title>The Family Tree $name</title>",
				'<meta http-equiv="Refresh" content="1;URL=', make_filename_from_person(person => $person), '">';
			if(my $lang = $ENV{'LANG'}) {
				$lang =~ s/\.UTF-8//;
				$lang =~ tr/_/-/;
				$lang = lc($lang);
				print $index_html "<meta http-equiv=\"Content-Language\" content=\"$lang\">";
			}
			print $index_html '</head>',
				"<body><h1>The Family Tree $name</h1><a href=\"", make_filename_from_person(person => $person), "\">$name</a></body>";
			$both_xmls->print("\n\t\t<home>1</home>");
			print $index_html '</html>';
			close $index_html;
			chmod 0444, $filename;
		}
		print $csv '1!';
	} else {
		if(!-e $filename) {
			open(my $index_html, '>', $filename);
			print $index_html '<html>',
				"<head><title>The Family Tree $name</title>",
				'<meta http-equiv="Refresh" content="1;URL=history.html">';
			if(my $lang = $ENV{'LANG'}) {
				$lang =~ s/\.UTF-8//;
				$lang =~ tr/_/-/;
				$lang = lc($lang);
				print $index_html "<meta http-equiv=\"Content-Language\" content=\"$lang\">";
			}
			print $index_html '</head>',
				"<body><h1>Family History</h1><a href=\"history.html\">Family History</a></body>";
			print $index_html '</html>';
			close $index_html;
			chmod 0444, $filename;
		}
		print $csv '0!';
	}

	$filename = File::Spec->catfile('static-site', make_filename_from_person(person => $person));
	if(-e $filename) {
		die "BUG: ensure filenames are unique ($filename)";
	}
	open(my $html, '>', $filename);
	print $html "<html><head><title>$title</title>";
	if($opts{'c'}) {
		# TODO: This will be added even on pages without citations, it would be nice to avoid that
		print $html '<link rel="stylesheet" href="https://genealogy.nigelhorne.com/css/web.css" type="text/css" media="screen">';
	}

	if($opts{'l'} || !is_alive(person => $person)) {
		# Produce the code for schema.org
		my $schema = {
			'@context' => 'https://schema.org',
			'@type' => 'Person',
			'gender' => $person->sex(),
			'name' => $name
		};

		if(my $dob = $dateofbirth) {
			if($dob =~ /^(\d{1,2})\s(\w{3})\s(\d{4})$/) {
				my $month = $months{lc($2)};
				if($month <= 9) {
					$month = "0$month";
				}
				my $day = $1;
				my $year = $3;
				if($day =~ /^\d$/) {
					$day = "0$day";
				}
				$dob = "$year-$month-$day";
				$schema->{'birthDate'} = $dob;
			} elsif($dob =~ /^(\d{4})\s(\w{3})\s(\d{1,2})$/) {
				my $month = $months{lc($2)};
				if($month <= 9) {
					$month = "0$month";
				}
				my $year = $1;
				my $day = $3;
				if($day =~ /^\d$/) {
					$day = "0$day";
				}
				$dob = "$year-$month-$day";
				$schema->{'birthDate'} = $dob;
			} elsif(($dob !~ /^abt/i) && ($dob !~ /^\d{4}$/)) {
				complain({ person => $person, warning => "Invalid date format for date of birth: '$dob' for schema.org" });
				# $schema->{'birthDate'} = $dob;
			}
			print $html '<script type="application/ld+json">',
				JSON::MaybeXS::to_json($schema),
				'</script>';
		}
	}

	print $html '</head>';

	if($opts{'m'}) {
		if($maps_module eq 'HTML::GoogleMaps::V3') {
			print $html "<body onload=\"html_googlemaps_initialize()\">";
		} else {
			print $html '<body>';
		}
	} elsif($google_maps_geolocation_key) {
		die "$0: -G makes no sense without -m";
	} else {
		print $html '<body>';
	}
	print $html "<center><h1>$title</h1>";
	if(defined($me)) {
		print $html '[ <a href="', make_filename_from_person(person => $me), '">Home</a> ] | ';
	}
	if($gedcal) {
		print $html '[ <a href="calendar/index.html">Calendar</a> ] | ';
	}
	print $html '[ <a href="surnames.html">Surnames Index</a> ] | ';
	if(-r 'static-site/censuses.html') {
		print $html '[ <a href="censuses.html">Census Index</a> ] | ';
	}
	if($opts{'w'}) {
		print $html '[ <a href="todo.html">Errors</a> ] | ';
	}
	print $html '[ <a href="history.html">Family History</a> ]</center><p>';

	my $phrase = Data::Text->new();
	my @phrases;

	if($is_alive && !$opts{'l'}) {
		print "Living person\n" if($opts{'v'});
		$both_xmls->print("\n\t\t<alive>1</alive>");
		print $csv '1!';
		my $str = '<i>This is the record of a living person, so not much data will be shown.</i></p><p>';
		print $html $str;
		print $csv $str;
	} else {
		$both_xmls->print("\n\t\t<bio>\n\t\t\t<en>\n\t\t\t\t");
		print $csv '0!';
		$surnames->{$surname}->{$title} = $person;
	}

	print "Gathering basic information\n" if($opts{'v'});

	my $birth = $person->get_record('birth');

	my $placeofbirth = get_value({ person => $person, value => 'birth place' });
	if((!$placeofbirth) && $birth) {
		$placeofbirth = $birth->place();
	}

	if($placeofbirth && ($placeofbirth =~ /[,\.]\s*$/) && ($placeofbirth ne 'U.S.A.')) {
		complain({ person => $person, warning => "Trailing punctuation in birth location, '$placeofbirth'" });
		$placeofbirth =~ s/\s*[,\.]\s*$//;
	}

	if($placeofbirth && ($placeofbirth =~ /^,/)) {
		complain({ person => $person, warning => "Leading comma in birth location: $placeofbirth" });
		$placeofbirth =~ s/^,\s*//g;
	}

	my $death = $person->get_record('death');
	my $placeofdeath = get_value({ person => $person, value => 'death place' });
	if((!$placeofdeath) && $death) {
		$placeofdeath = $death->place();
	}

	if($placeofdeath) {
		if(lc($placeofdeath) eq 'unknown') {
			$placeofdeath = undef;
			complain({ person => $person, warning => "Assuming place of death ', , ' means unknown place" });
		} elsif($placeofdeath =~ /\s\s/) {
			complain({ person => $person, warning => 'Removing successive spaces from place of death' });
			$placeofdeath =~ s/\s\s+/ /g;
		}
	}

	if($placeofdeath && ($placeofdeath =~ /[,\.]\s*$/) && ($placeofdeath ne 'U.S.A.')) {
		complain({ person => $person, warning => "Trailing punctuation in death location '$placeofdeath'" });
		$placeofdeath =~ s/\s*[,\.]\s*$//;
	}

	if($placeofdeath && ($placeofdeath =~ /,\s*$/)) {
		complain({ person => $person, warning => 'Trailing comma in death location' });
		$placeofdeath =~ s/\s*,\s*$//;
	}
	if($placeofdeath && ($placeofdeath =~ /^,/)) {
		complain({ person => $person, warning => 'Leading comma in death location' });
		1 while($placeofdeath =~ s/^,\s*//g);
	}

	if($is_alive && ($placeofdeath || $dateofdeath)) {
		die "BUG: $title is marked as alive yet we have death information";
	}

	if($opts{'w'}) {
		if($firstname && $surname) {
			my %chronicling_params = ( ua => $cached_browser );
			if($dateofbirth && ($dateofbirth =~ /(\d{4})$/)) {
				if($1 <= 1789) {
					$chronicling_params{'date_of_birth'} = 1789;
				} else {
					$chronicling_params{'date_of_birth'} = $1;
				}
			}
			if($dateofdeath && ($dateofdeath =~ /(\d{4})$/)) {
				if($1 >= 1963) {
					$chronicling_params{'date_of_death'} = 1963;
				} else {
					$chronicling_params{'date_of_death'} = $1;
				}
			}
			if($firstname) {
				$chronicling_params{'firstname'} = $firstname;
				if($surname) {
					$chronicling_params{'lastname'} = $surname;
				}
			}
			my $stateofbirth;
			if($placeofbirth && (($placeofbirth =~ /USA$/) || ($placeofbirth =~ /United States$/)) && ($placeofbirth =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
				$stateofbirth = uc($1);
				if($us->{code2state}{$stateofbirth}) {
					$stateofbirth = $us->{code2state}{$stateofbirth};
				} elsif($stateofbirth eq 'NORD DAKOTA') {
					$stateofbirth = 'NORTH DAKOTA';
				} elsif(!$us->{state2code}{$stateofbirth}) {
					complain({ person => $params{'person'}, warning => "Unknown state '$stateofbirth' in birth place $placeofbirth" });
				}
				$chronicling_params{'state'} = ucfirst(lc($stateofbirth));
				chronicling_america($person, \%chronicling_params);

			}
			if($placeofdeath) {
				if((($placeofdeath =~ /USA$/) || ($placeofdeath =~ /United States$/)) && ($placeofdeath =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
					my $stateofdeath = uc($1);
					if($us->{code2state}{$stateofdeath}) {
						$stateofdeath = $us->{code2state}{$stateofdeath};
					} elsif(!$us->{state2code}{$stateofdeath}) {
						complain({ person => $params{'person'}, warning => "Unknown state '$stateofdeath' in death place $placeofbirth" });
					}
					if((!defined($stateofbirth)) || (lc($stateofdeath) ne lc($stateofbirth))) {
						$chronicling_params{'state'} = ucfirst(lc($stateofdeath));

						# TODO: married and maiden names, could be two searches
						chronicling_america($person, \%chronicling_params);
					}
				}
				if(defined($yob) && defined($yod)) {
					obituaries({ person => $person, first => $firstname, last => $surname, yob => $yob, yod => $yod, age => $yod - $yob });

					my $sex = get_value({ person => $person, value => 'sex' });
					if(defined($sex) && ($sex eq 'F') && (my $husband = $person->husband())) {
						my $married_name = ucfirst(lc($husband->surname()));
						if($married_name eq $surname) {
							complain({ person => $person, warning => 'Maiden name same as married name' });
						}
						obituaries({ person => $person, first => $firstname, last => $married_name, yob => $yob, yod => $yod, age => $yod - $yob });
					}
				}

				# The wills database currently only contains Kent
				if($yod && ($placeofdeath =~ /Kent, England/)) {
					wills({ person => $person, first => $firstname, last => $surname, year => $yod });
				}
			}
		}
	}

	my %citations;
	my $citationcount = 0;
	my @birthcitations;
	my @deathcitations;
	if($opts{'c'}) {
		print "Gathering citations for basic information\n" if($opts{'v'});

		if($birth) {
			my @s = $birth->source();
			if($opts{'w'}) {
				foreach my $s(@s) {
					if((!defined(get_source({ gedcom => $ged, person => $person, source => $s }))) &&
					    !defined($s->items())) {
						complain({ person => $person, warning => 'Birth citation is missing a source' });
					}
				}
			}
			@s = cache_array(@s);
			@s = sort { (get_source({ gedcom => $ged, person => $person, source => $a }) && get_source({ gedcom => $ged, person => $person, source => $b })) ? get_source({ gedcom => $ged, person => $person, source => $a })->title() cmp get_source({ gedcom => $ged, person => $person, source => $b })->title() : 0 } @s;
			if(scalar(@s)) {
				my $previous;
				foreach my $src(@s) {
					# $src = $ged->get_source($src) unless ref($src);
					$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
					if(defined($src) && (my $title = $src->title())) {
						next if($previous && ($title eq $previous));
						$previous = $title;
						push @birthcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					} elsif($src->items()) {
						my @items = $src->items();
						if($items[0]->{'value'}) {
							push @birthcitations, ++$citationcount;
							$citations{$citationcount} = $items[0];
						}
					}
				}
			} elsif($opts{'w'} && ($opts{'l'} || !$is_alive)) {
				if($dateofbirth) {
					red_warning({ person => $person, warning => "Birth date ($dateofbirth) has no citations" });
				} elsif($placeofbirth) {
					complain({ person => $person, warning => "Birth place ($placeofbirth) has no citations" });
				} else {
					complain({ person => $person, warning => 'Birth record has no citations' });
				}
			}
		}
		if($death) {
			my @s = $death->source();
			if($opts{'w'}) {
				foreach my $s(@s) {
					if((!defined(get_source({ gedcom => $ged, person => $person, source => $s }))) &&
					   (!defined($s->items())) &&
					   (!defined($s->value()))) {
						complain({ person => $person, warning => 'Death citation is missing a source' });
					}
				}
			}
			@s = cache_array(@s);
			@s = sort { (get_source({ gedcom => $ged, person => $person, source => $a }) && get_source({ gedcom => $ged, person => $person, source => $b })) ? get_source({ gedcom => $ged, person => $person, source => $a })->title() cmp get_source({ gedcom => $ged, person => $person, source => $b })->title() : 0 } @s;
			if(scalar(@s)) {
				foreach my $src(@s) {
					$src = $ged->get_source($src) unless ref($src);
					my $seen;
					foreach my $bc(@birthcitations) {
						if($src eq $citations{$bc}) {
							push @deathcitations, $bc;
							$seen++;
							last;
						}
					}
					if(!$seen) {
						push @deathcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
				@deathcitations = cache_array(@deathcitations);
			} elsif($opts{'l'} || !is_alive(person => $person)) {
				if($dateofdeath) {
					# my $dateismissing = 0;
					# my @objects = $person->obje();
					# foreach my $o(@objects) {
						# my $obje;
						# if(ref($o) eq 'Gedcom::Record') {
							# $obje = $o;	# e.g. Ancestry
						# } else {
							# $obje = $ged->resolve_xref($o);	# e.g. FMP
						# }
						# foreach my $item($obje->items()) {
							# next if($item->tag() ne '_DATE');
							# if($item->value() eq $dateofdeath) {
								# $dateismissing = 0;
								# last;
							# }
						# }
					# }
					# if($dateismissing) {
						complain({ person => $person, warning => "Death date ($dateofdeath) has no citations" });
					# }
				} elsif($placeofdeath) {
					complain({ person => $person, warning => "Death place ($placeofdeath) has no citations" });
				} else {
					complain({ person => $person, warning => 'Death record exists with no date or place' });
				}
			}
		}
	}

	# $fetcher->prime(object => $person, message => 'sex')->prime(object => $person, message => 'pronoun');

	print "Gathering main dates\n" if($opts{'v'});

	my $baptism = $person->get_record('baptism');
	my $dateofbaptism = get_value({ person => $person, value => 'baptism date' });
	if((!$dateofbaptism) && $baptism) {
		$dateofbaptism = $baptism->date();
	}
	if(defined($dateofbaptism) && ($dateofbaptism =~ /^0/)) {
		complain({ person => $person, warning => "Removing leading 0 from baptism date '$dateofbaptism'" });
		$dateofbaptism =~ s/^0//;
	}
	if($dateofbaptism && $dateofbirth && ($dateofbirth !~ /^abt\s/i) && ($dateofbaptism !~ /^bet \d{3,4} and \d{3,4}$/) && (datecmp($dateofbaptism, $dateofbirth) <= 0)) {

		# Try hard to avoid FP "Date of baptism (17 Jun 1877) before date of birth (1877)"
		if((get_year_from_date($dateofbirth) != get_year_from_date($dateofbaptism)) || (($dateofbirth =~ /\D/) && ($dateofbaptism =~ /\D/))) {
			complain({ person => $person, warning => "Date of baptism ($dateofbaptism) before date of birth ($dateofbirth)" });
		}
	}
	my $placeofbaptism = get_value({ person => $person, value => 'baptism place' });
	if((!$placeofbaptism) && $baptism) {
		$placeofbaptism = $baptism->place();
	}

	my @events = $person->event();

	if(scalar(@events) == 2) {
		my $event = $events[1];
		if(!ref($event)) {
			if($event = $person->tag_record('EVEN', 2)) {
				$events[1] = $event;
			} else {
				red_warning({ person => $person, warning => "Event record is just description ($event), information has been lost" });
				pop @events;
			}
		}
	}

	my $marriage = get_marriage($person);

	if(defined($marriage) && (scalar(@spouses) == 0)) {
		complain({ person => $person, warning => 'Marriage record not used to determine spouse' });
	}

	my $placeofmarriage = get_value({ person => $person, value => 'marriage place' });
	if((!$placeofmarriage) && $marriage) {
		$placeofmarriage = $marriage->place();
	}
	if($placeofmarriage) {
		if($placeofmarriage =~ /.+,\s?(.+)$/) {
			my $c = $1;
			if($c eq 'Scot') {
				complain({ person => $person, warning => "$c: marriage country should be Scotland'" });
				$placeofmarriage .= 'land';
			}
		}
		$parse_tree->{'placeofmarriage'} = $placeofmarriage;
	}

	my $burial;
	my $dateofburial;
	my $placeofburial;
	my $cremation;
	my $dateofcremation;
	my $placeofcremation;
	if($burial = $person->get_record('burial')) {
		$dateofburial = get_value({ person => $person, value => 'burial date' });
		if(!$dateofburial) {
			$dateofburial = $burial->date();
		}
		$placeofburial = get_value({ person => $person, value => 'burial place' });
		if(!$placeofburial) {
			$placeofburial = $burial->place();
		}
	} elsif($cremation = $person->get_record('cremation')) {
		$dateofcremation = get_value({ person => $person, value => 'cremation date' });
		if(!$dateofcremation) {
			$dateofcremation = $cremation->date();
		}
		$placeofcremation = get_value({ person => $person, value => 'cremation place' });
		if(!$placeofcremation) {
			$placeofcremation = $cremation->place();
		}
	}

	if($is_alive && ($placeofburial || $dateofburial)) {
		die "BUG: $title is marked as alive yet we have burial information";
	}

	# Don't match date ranges
	my $birth_dt = date_to_datetime(date => $dateofbirth);
	if($dateofbirth && ($dateofbirth !~ /\d{4}.+\d{4}/) && $birth_dt) {
		if(defined($facts->{'first_birth'})) {
			if($birth_dt < $facts->{'first_birth'}->{'date'}) {
				$facts->{'first_birth'}->{'date'} = $birth_dt;
				$facts->{'first_birth'}->{'xref'} = $person->xref();
			}
		} else {
			$facts->{'first_birth'}->{'date'} = $birth_dt;
			$facts->{'first_birth'}->{'xref'} = $person->xref();
		}

		if($birth_dt && (my $spouse = $spouses[0])) {
			my $sdob = dateofbirth($spouse);
			if($sdob && (my $sbirth_dt = date_to_datetime(date => $sdob))) {
				if($sbirth_dt > ($birth_dt + $fortyyears)) {
					complain({
						person => $person,
						warning => 'Spouse born more than 40 years after date of birth'
					});
				} elsif($birth_dt > ($sbirth_dt + $fortyyears)) {
					complain({
						person => $person,
						warning => 'Born more than 40 years after date of birth of spouse'
					});
				}
			}
		}
	}

	# my $dateofmarriage = get_value({ person => $person, value => 'marriage date' });

	# if((!$dateofmarriage) && $marriage) {
		# $dateofmarriage = $marriage->date();
	# }
	# if($dateofmarriage && ($dateofmarriage =~ /\s$/)) {
		# complain({ person => $person, warning => 'Removing trailing spaces from date of marriage' });
		# $dateofmarriage =~ s/\s+$//;
	# }
	my $dateofmarriage = dateofmarriage(person => $person);
	my $marriage_dt;
	if($dateofmarriage) {
		$marriage_dt = $dfg->parse_datetime(date => $dateofmarriage, quiet => 1);
	}

	# Don't match date ranges
	my $death_dt = date_to_datetime(date => $dateofdeath);

	# Add people married at youngest and oldest ages to facts
	if($opts{'l'} || !$is_alive) {
		if($birth_dt && $marriage_dt) {
			if($marriage_dt > $birth_dt) {
				if($marriage_dt < ($birth_dt + $sixteenyears)) {
					complain({
						person => $person,
						warning => 'married when less than 16 years old'
					});
				}

				my $age_at_marriage = $marriage_dt - $birth_dt;
				if(my $ym = $facts->{'youngest_marriage'}) {
					# FIXME: Handle when there is more than one person with this age
					if(DateTime::Duration->compare($age_at_marriage, $ym->{'age'}, $birth_dt) < 0) {
						$ym->{'age'} = $age_at_marriage;
						$ym->{'xref'} = $person->xref();
					}
				} else {
					$facts->{'youngest_marriage'}->{'age'} = $age_at_marriage;
					$facts->{'youngest_marriage'}->{'xref'} = $person->xref();
				}
				if(defined($facts->{'oldest_marriage'})) {
					# FIXME: Handle when there are more than one person with this age
					if(DateTime::Duration->compare($age_at_marriage, $facts->{'oldest_marriage'}->{'age'}, $birth_dt) > 0) {
						$facts->{'oldest_marriage'}->{'age'} = $age_at_marriage;
						$facts->{'oldest_marriage'}->{'xref'} = $person->xref();
					}
				} else {
					$facts->{'oldest_marriage'}->{'age'} = $age_at_marriage;
					$facts->{'oldest_marriage'}->{'xref'} = $person->xref();
				}
			} else {
				complain({ person => $person, warning => 'Married before they were born' });
			}
		}

		# Longest married couple
		if($death_dt && $marriage_dt && (scalar(@spouses) == 1) && (my $spdateofdeath = dateofdeath($spouses[0])) && ($death_dt > $marriage_dt)) {
			if(my $sp_death_dt = date_to_datetime(date => $spdateofdeath)) {
				my $end_of_marriage = ($sp_death_dt < $death_dt) ? $sp_death_dt : $death_dt;
				my $marriage_length = $end_of_marriage - $marriage_dt;
				if(my $lm = $facts->{'longest_marriage'}) {
					# FIXME: Handle when there is more than one marriage with this length
					if(DateTime::Duration->compare($marriage_length, $lm->{'length'}, $marriage_dt) > 0) {
						$lm->{'length'} = $marriage_length;
						$lm->{'xref'} = $person->xref();
						$lm->{'spouse_xref'} = $spouses[0]->xref();
					}
				} else {
					$facts->{'longest_marriage'}->{'length'} = $marriage_length;
					$facts->{'longest_marriage'}->{'xref'} = $person->xref();
					$facts->{'longest_marriage'}->{'spouse_xref'} = $spouses[0]->xref();
				}
			}
		}

		if($birth_dt && $death_dt) {
			my $age_at_death = $death_dt - $birth_dt;
			if(defined($facts->{'oldest_age'})) {
				# FIXME: Handle when there is more than one person with this age
				if(DateTime::Duration->compare($age_at_death, $facts->{'oldest_age'}->{'age'}, $birth_dt) > 0) {
					$facts->{'oldest_age'}->{'age'} = $age_at_death;
					$facts->{'oldest_age'}->{'xref'} = $person->xref();
				}
			} else {
				$facts->{'oldest_age'}->{'age'} = $age_at_death;
				$facts->{'oldest_age'}->{'xref'} = $person->xref();
			}

			# Kepp a list of those who lived over 100
			if($age_at_death->years() >= 100) {
				push @{$facts->{'people_over_100'}->{'xrefs'}}, $person->xref();
				$facts->{'people_over_100'}->{'count'}++;
			}

			# Calculate the average age of adults death on both sides of the family
			if($me && ((my $age = $age_at_death->years()) >= 20)) {
				my $mr;
				if(my $mother = $me->mother()) {
					if($mr = $mother->relationship($person)) {
						$facts->{'mothers_side'}->{'age'} += $age;
						$facts->{'mothers_side'}->{'count'}++;
					}
				}
				if(my $father = $me->father()) {
					if(my $fr = $father->relationship($person)) {
						$facts->{'fathers_side'}->{'age'} += $age;
						$facts->{'fathers_side'}->{'count'}++;
						if($mr && ($mr ne $fr)) {
							# Keep a tally of the number of people appearing on both sides
							#
							# Ignore entries, for example, that could both be "grandson" which would
							# make this person the home person's newphew/niece
							# and would, of course, be on both sides of the tree
							# FIXME: allow things like both being third cousin four times removed,
							#	but that's a so very rare edge case
							push @{$facts->{'both_sides'}->{'xrefs'}}, $person->xref();
							$facts->{'both_sides'}->{'count'}++;
						}
					}
				}
			}
		} elsif($yob && $yod) {
			# Calculate the average age of adults death on both sides of the family
			if($me && ((my $age = ($yod - $yob)) >= 20)) {
				my $mr;
				if(my $mother = $me->mother()) {
					if($mr = $mother->relationship($person)) {
						$facts->{'mothers_side'}->{'age'} += $age;
						$facts->{'mothers_side'}->{'count'}++;
					}
				}
				if(my $father = $me->father()) {
					if(my $fr = $father->relationship($person)) {
						$facts->{'fathers_side'}->{'age'} += $age;
						$facts->{'fathers_side'}->{'count'}++;
						if($mr && ($mr ne $fr)) {
							# Keep a tally of the number of people appearing on both sides
							push @{$facts->{'both_sides'}->{'xrefs'}}, $person->xref();
							$facts->{'both_sides'}->{'count'}++;
						}
					}
				}
			}
		}

		# RT114091
		if($birth_dt && ($birth_dt >= $year_1000)) {
			$all_events{'B' . $person->xref()} = { person => $person, event => 'Birth', date => $birth_dt };
		} elsif($yob) {
			$all_events{'B' . $person->xref()} = { person => $person, event => 'Birth', date => $yob };
		}
		if($marriage_dt && ($marriage_dt >= $year_1000)) {
			$all_events{'M' . $person->xref()} = { person => $person, event => 'Marriage', date => $marriage_dt };
		} elsif($dateofmarriage) {
			$all_events{'M' . $person->xref()} = { person => $person, event => 'Marriage', date => $dateofmarriage };
		}
		if($death_dt && ($death_dt >= $year_1000)) {
			$all_events{'D' . $person->xref()} = { person => $person, event => 'Death', date => $death_dt };
		} elsif($yod) {
			$all_events{'D' . $person->xref()} = { person => $person, event => 'Death', date => $yod };
		}
	}

	# This is used to create the places to display with the '-m' option.
	# It's a hash of text (the text to be displayed) to objects
	my %place_records;

	if($placeofbirth) {
		if(!defined($birth->place())) {
			complain({ person => $person, warning => "Birthplace is set to $placeofbirth but birth place is empty" });
			$birth->set('place', $placeofbirth);
		}
		$place_records{'Birth'} = $birth;
	}
	if($placeofbaptism) {
		if($ENV{'LANG'} =~ /^en_US/) {
			$place_records{'Baptized'} = $baptism;
		} else {
			$place_records{'Baptised'} = $baptism;
		}
	}
	if($placeofmarriage) {
		$place_records{'Marriage'} = $marriage;
	}
	if($placeofdeath) {
		if(!defined($death->place())) {
			complain({ person => $person, warning => "Deathplace is set to $placeofdeath but death place is empty" });
			$death->set('place', $placeofdeath);
		}
		$place_records{'Death'} = $death;
	}
	if($placeofburial) {
		$place_records{'Burial'} = $burial;
	}

	my $marriagecitation;
	my @burialcitations;
	if($opts{'c'}) {
		if($marriage) {
			print "Check marriage source\n" if($opts{'v'});
			if(my $src = $marriage->source()) {
				$src = $ged->get_source($src) unless ref($src);
				# FIXME:  Only looks for matches in the first citations
				if(!defined($src)) {
					my $src = $marriage->source();
					complain({ person => $person, warning => "marriage citation can't find source $src" });
				} elsif($birthcitations[0] && ($citations{$birthcitations[0]} eq $src)) {
					$marriagecitation = $birthcitations[0];
				} elsif($birthcitations[1] && ($citations{$birthcitations[1]} eq $src)) {
					$marriagecitation = $birthcitations[1];
				} elsif($deathcitations[0] && ($citations{$deathcitations[0]} eq $src)) {
					$marriagecitation = $deathcitations[0];
				} else {
					$marriagecitation = ++$citationcount;
					$citations{$marriagecitation} = $src;
				}
			} elsif($opts{'w'} && ($opts{'l'} || !$is_alive)) {
				if($dateofmarriage) {
					red_warning({ person => $person, warning => "Marriage date ($dateofmarriage) has no citations" });
				} elsif($placeofmarriage) {
					red_warning({ person => $person, warning => "Marriage place ($placeofmarriage) has no citations" });
				} else {
					red_warning({ person => $person, warning => 'Marriage record has no citations' });
				}
			}
		}
		if($burial) {
			print "Check burial source\n" if($opts{'v'});
			if($opts{'w'} && defined($cremation)) {
				complain({ person => $person, warning => 'Person has both burial and cremation records' });
			}
			my @s = $burial->source();
			if(scalar(@s)) {
				foreach my $src(@s) {
					$src = $ged->get_source($src) unless ref($src);
					if(!defined($src)) {
						my $src = $burial->source();
						complain({ person => $person, warning => "burial citation can't find source $src" });
						next;
					}
					my $seen;
					foreach my $dc(@deathcitations) {
						if($src eq $citations{$dc}) {
							push @burialcitations, $dc;
							$seen++;
							last;
						}
					}
					if(!$seen) {
						if($marriagecitation && ($citations{$marriagecitation} eq $src)) {
							push @burialcitations, $marriagecitation;
						} else {
							push @burialcitations, ++$citationcount;
							$citations{$citationcount} = $src;
						}
					}
				}
			} elsif($opts{'w'} && ($opts{'l'} || !$is_alive)) {
				if($dateofburial) {
					complain({ person => $person, warning => "Burial date ($dateofburial) has no citations" });
				} elsif($dateofcremation) {
					complain({ person => $person, warning => "Cremation date ($dateofcremation) has no citations" });
				} elsif($placeofburial) {
					# utf8::decode($placeofburial);
					complain({ person => $person, warning => "Burial place ($placeofburial) has no citations" });
				} else {
					# utf8::decode($placeofcremation);
					complain({ person => $person, warning => "Cremation place ($placeofcremation) has no citations" });
				}
			}
		}
	}

	$facts->{'count'}++;
	$facts->{'sex'}->{$sex}++;

	if($opts{'w'} && $firstname) {
		# FIXME: This throws up a number of false positives
		my $guess;
		if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
			$guess = Text::Names::guessGender($firstname);
		} else {
			$guess = Text::Names::GB::guessGender($firstname);
		}
		if($sex && $guess && ($sex ne $guess)) {
			my $error = 1;
			if(my $middle_name = $name_components{'middle_name'}) {
				if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
					$guess = Text::Names::guessGender($middle_name);
				} else {
					$guess = Text::Names::GB::guessGender($middle_name);
				}
				if($guess && ($sex eq $guess)) {
					$error = 0;
				}
			}
			if($error) {
				complain({ person => $person, warning => 'Check the gender of the record' });
			}
		}
	}
	# my @children = map { $_->children() } $person->fams();
	my @children = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {}, quiet => 1 }) }
		map { $_->children() } $person->fams();
	my $numberofchildren = scalar(@children);

	# Most children
	if((!defined($facts->{'most_children'})) || ($facts->{'most_children'}->{'count'} < $numberofchildren)) {
		$facts->{'most_children'}->{'count'} = $numberofchildren;
		$facts->{'most_children'}->{'xref'} = $person->xref();
	}

	# Average family size
	if($numberofchildren) {
		$facts->{'family_size'}->{'size'} += $numberofchildren;
		$facts->{'family_size'}->{'count'}++;
	}

	if($opts{'w'} && $numberofchildren) {
		foreach my $child(@children) {
			if($child->xref() eq $person->xref()) {
				complain({ person => $person, warning => 'Person is own parent' });
				# Avoid loops in G::I::Relationship
				return;
			}
			if($dateofdeath && (my $cdob = dateofbirth($child))) {
				if(($cdob =~ /\d{3,4}$/) && (datecmp($cdob, $dateofdeath) > 0)) {
					complain({ person => $person,
						warning => 'Date of birth of child ' . $child->as_string() . " ($cdob) is later than " . ($sex eq 'M' ? 'his' : 'her') . " own date of death ($dateofdeath)"
					})
				}
			}
		}
		if($numberofchildren >= 2) {
			if((my $first = dateofbirth(person => $children[0])) &&
			   (my $second = dateofbirth(person => $children[1]))) {
				if($first = get_year_from_date($first) &&
				  ($second = get_year_from_date($second))) {
					my $gap = abs($first - $second);
					if($gap >= 40) {
						complain({
							person => $person,
							warning => "Large age gap ($gap years) between the two children"
						});
					}
				}
			}
		}
	}

	print "numberofchildren = $numberofchildren\n" if($opts{'v'});

	my $relationship;
	my $spouserelationship;
	my $spouse;
	my %places_printed;

	if($dateofbirth && $opts{'w'} && scalar(@siblings)) {
		print 'Found ', scalar(@siblings), " siblings(s)\n" if($opts{'v'});
		foreach my $sibling(@siblings) {
			if(($sibling->name() eq $person->name()) || Text::Names::samePerson($sibling->name(), $person->name())) {
				my $siblingbirth = dateofbirth($sibling);
				if($siblingbirth && (datecmp($siblingbirth, $dateofbirth) == 0)) {
					complain({ person => $sibling, warning => 'Possible duplicate person' });
				} elsif((!$dateofdeath) && !dateofdeath($sibling)) {
					complain({ person => $sibling, warning => 'Two siblings of the same name alive at the same time'});
				}
			}
		}
	}

	if($me && ($person->xref() ne $me->xref())) {
		print "find relationship\n" if($opts{'v'});
		$relationship = $me->relationship($person);
		if((!$relationship) && scalar(@spouses)) {
			print "find spousal relationship\n" if($opts{'v'});
			if($spouses[0]->xref() eq $me->xref()) {
				$relationship = i18n(($sex eq 'F') ? 'wife' : 'husband');
			} else {
				foreach my $s(@spouses) {
					$spouserelationship = $me->relationship($s);
					if($spouserelationship) {
						$spouse = $s;
						last;
					}
				}
			}
		}
		if((!$relationship) && (!$spouserelationship)) {
			complain({
				person => $person,
				warning => "Can't find relationship with the home person"
			});
		}
		print 'relationship = ', ($relationship ? $relationship : 'unknown'), "\n" if($opts{'v'});
		if(my $r = $relationship) {
			# Remove spaces from the relationship so that the Template Toolkit can
			# use it as a key
			$r =~ s/ /_/g;
			$facts->{'relations'}->{$r}++;
		}
	}

	if(($dateofbaptism || $placeofbaptism) && !($mother || $father)) {
		complain({ person => $person, warning => 'Baptism information not used to determine a parent' });
	}

	my @occupations;
	if($opts{'l'} || !$is_alive) {
		@occupations = get_all_occupations($person);
	}

	print 'Found ', scalar(@occupations), " occupation(s)\n" if($opts{'v'});

	my $same_occupation_as_father;

	if($occupations[0]) {
		my @foccupations;
		if($father) {
			@foccupations = get_all_occupations(person => $father);
		}
		if(scalar(@foccupations) && ($occupations[0] eq $foccupations[0])) {
			$same_occupation_as_father = $occupations[0];
			@occupations = ();
		} else {
			my $article;
			if($occupations[0] =~ /^[aeiou]/i) {
				$article = 'an';
			} else {
				$article = 'a';
			}

			$phrase->set(ucfirst(i18n({
				person => $person,
				format => "$article %s",
				args => lc(conjunction(@occupations))
			})));
		}
	}

	my @person_twins;
	if($birth_dt && ($opts{'l'} || !$is_alive)) {
		@person_twins = twins({ birth_dt => $birth_dt, siblings => \@siblings });

		if(scalar(@person_twins) == 1) {	# TODO triplets and higher order
			if((scalar(@phrases) > 0) && ($phrase->length == 0)) {
				if($phrase->length()) {
					push @phrases, $phrase;
				}
				my $s = i18n({ person => $person, format => 'twin of' });
				$phrase = Data::Text->new("$s " . given_names($person_twins[0]->{'sibling'}));
			} else {
				if($phrase->length()) {
					push @phrases, $phrase;
				}
				$phrase = Data::Text->new('The twin ' . i18n((($person->sex() eq 'M') ? 'brother' : 'sister')) .
					i18n(' of ') . given_names($person_twins[0]->{'sibling'}));
			}
			$twins{$person->xref()} = $person_twins[0]->{'sibling'}->xref();
		}
	}

	my $print_sibling_count = 0;
	my $fullbio;	# This is used to generate pop-ups in dynamic pages

	if(($father || $mother) &&
	   ((!$is_alive) || $opts{'l'} || (!defined($me)) || ($person->xref() eq $me->xref()))) {
		if($phrase->length()) {
			$phrase->append(' and the ');
		} elsif(scalar(@phrases) == 0) {
			$phrase->set('The ');
		} else {
			$phrase->set('the ');
		}

		if($birth_dt && ($opts{'l'} || !$is_alive)) {
			if(scalar(@siblings)) {
				# If possible, sort siblings by date of birth
				my $all_siblings_have_dob = 1;
				foreach my $sibling(@siblings) {
					if(my $dob = dateofbirth($sibling)) {
						if($dob =~ /\s$/) {
							complain({ person => $sibling, warning => 'Removing trailing spaces from date of birth' });
							$dob =~ s/\s+$//;
						}
						if($dob =~ /\d{3,4}$/) {
							if(!date_parser_cached(date => $dob)) {
								complain({
									person => $sibling,
									warning => "has an invalid date of birth: $dob"
								});
								$all_siblings_have_dob = 0;
								last;
							}
							if(($dob !~ /^\d/) || ($dob =~ /[a-z]$/i) ||
							   ($dob =~ /[\/\-]/)) {
								$all_siblings_have_dob = 0;
								last;
							}
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					} else {
						$all_siblings_have_dob = 0;
						last;
					}
				}
				if($all_siblings_have_dob) {
					# @siblings = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => dateofbirth($_))}[0]->{'canonical'}) } @siblings;
					@siblings = sort { datecmp(dateofbirth($a), dateofbirth($b)) } @siblings;
				}
				my $age_index = 1;	# count of siblings born before $person + 1 (i.e. where $person is in the date order)
				$print_sibling_count = 1;
				foreach my $sibling(@siblings) {
					if(my $dob = dateofbirth($sibling)) {
						if($dob =~ /\s$/) {
							complain({ person => $sibling, warning => 'Removing trailing spaces from date of birth' });
							$dob =~ s/\s+$//;
						}
						if(($dob =~ /\d{3,4}$/) &&
						   (my $d = date_parser_cached(date => $dob))) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if($opts{'w'} &&
							  ($dob =~ /^\d/) && ($dob !~ /[a-z]$/i) &&
							  ($d < $birth_dt) &&
							  ($d < ($birth_dt - $oneday)) &&
							  ($d > ($birth_dt - $tenmonths))) {
								complain({
									person => $sibling,
									warning => 'Born less than 10 months before sibling ' . $person->as_string()
								});
							}
							$age_index++ if($d && ($d < $birth_dt));
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					} else {
						$all_siblings_have_dob = 0;
						last;
					}
				}
				if($all_siblings_have_dob) {
					if($language eq 'French') {
						$phrase->append('e ');
					}
					if(scalar(@siblings) && ($age_index == (scalar(@siblings) + 1))) {
						if($language eq 'French') {
							$phrase->append(($sex eq 'M') ? 'dernier' : "derni\N{U+00E8}re");
						} else {
							$phrase->append(((scalar(@siblings) > 1) ? 'youngest' : 'younger'));
						}
					} elsif(scalar(@siblings) && ($age_index == 1)) {
						if(scalar(@siblings) > 1) {
							$phrase->append(i18n({ person => $person, format => 'eldest' }));
						} else {
							$phrase->append(i18n({ person => $person, format => 'older' }));
						}
					} elsif($language eq 'French') {
						$phrase->append(Lingua::FR::Numbers::Ordinate::ordinate($age_index));
					} else {
						$phrase->append(ordinate($age_index));
					}
					if($language eq 'French') {
						$phrase->append(' de ' . (scalar(@siblings) + 1) . ' enfants');
					} else {
						$phrase->append(i18n(' of ') . (scalar(@siblings) + 1) . ' children');
					}
				} else {
					if($language eq 'French') {
						$phrase->append("'enfant");
					} else {
						$phrase->append(i18n(($sex eq 'M') ? 'son' : 'daughter'));
					}
				}
			} else {
				$phrase->append(i18n(($sex eq 'M') ? 'son' : 'daughter'));
			}
			if($language eq 'French') {
				$phrase->replace({ 'Le a' => "L'a" });
			}
		} else {
			$phrase->append(i18n('child'));
		}

		if(($language eq 'French') && ($father->as_string() =~ /^[aehiou]/i)) {
			$phrase->append(" d'");
		} else {
			$phrase->append(i18n(' of '));
		}

		print $html wide_to_html({ string => $phrase, keep_hrefs => 1 });
		# $bio =~ s/&eacute;/&#233;/g;

		$fullbio = $phrase->as_string();

		if($opts{'l'} || !$is_alive) {
			if($father) {
				my $f = wide_to_html($father->as_string());
				$phrase->append('<a href="?page=people&entry=' . $father->xref() . '">' .
					"$f</a>");
				print $html '<a href="', make_filename_from_person(person => $father), '">',
					"$f</a>";
				# print $xml '&lt;a href="?page=people&amp;entry=', $father->xref(), '"&gt;',
					# $father->as_string(),
					# '$lt;/a$gt;';

				if(!$same_occupation_as_father) {
					my @occupations = get_all_occupations(person => $father);
					# TODO: print all occupations
					if(my $occupation = $occupations[0]) {
						$occupation = lc($occupation);
						if($language eq 'English') {
							if($ENV{'LANG'} =~ /^en_US/) {
								$occupation = Lingua::EN::ABC::b2a($occupation);
							} elsif($ENV{'LANG'} =~ /^en_CA/) {
								$occupation = Lingua::EN::ABC::b2c($occupation);
							} else {
								$occupation = Lingua::EN::ABC::a2b($occupation);
							}
						}
						if($language eq 'French') {
							print $html " (un $occupation)";
							$phrase->append(" (un $occupation)");
						} else {
							print $html ' (', HTML::Entities::encode(Lingua::EN::Inflect::A(lc($occupation))), ')';
							$phrase->append(' (' . Lingua::EN::Inflect::A(lc($occupation)) . ')');
						}
					}
				}
				$fullbio .= $father->as_string();
				if($mother) {
					my $and = i18n(' and ');
					print $html $and;
					$fullbio .= $and;
					$phrase->append($and);
				}
			}
			if($mother) {
				if(my $m = $mother->as_string(give_maidenname => 0)) {
					$m = wide_to_html($m);
					$phrase->append('<a href="?page=people&entry=' . $mother->xref() . "\">$m</a>");
					print $html '<a href="', make_filename_from_person(person => $mother), "\">$m</a>";
					# print $xml '&lt;a href="?page=people&amp;entry=', $mother->xref(), "\"&gt;$m&lt;/a&gt;";
				}

				my @occupations = get_all_occupations($mother);
				# TODO: print all occupations
				if($occupations[0]) {
					print $html ' (', Lingua::EN::Inflect::A(lc($occupations[0])), ')';
					$phrase->append(' (' . Lingua::EN::Inflect::A(lc($occupations[0])) . ')');
				}
				$fullbio .= ' ' . $mother->as_string();
				if($opts{'w'} && $birth_dt && (my $mdod = dateofdeath($mother))) {
					if(my $dt = date_to_datetime(date => $mdod)) {
						if($birth_dt > $dt) {
							complain({ person => $person, warning => 'Born after mother died' });
						}
					}
				}
			}
		} else {
			if($father) {
				print $html '<a href="', make_filename_from_person(person => $father), '">',
					given_names($father),
					'</a>';
				# print $xml '&lt;a href="?page=people&amp;entry=', $father->xref(), '"&gt;',
					# $father->given_names(),
					# '&lt;/a&gt;';
				$phrase->append('<a href="?page=people&entry=' . $father->xref() . '">' .
					given_names($father) .
					'</a>');
				if($mother) {
					print $html i18n(' and ');
					$phrase->append(i18n(' and '));
				}
			}
			if($mother) {
				print $html '<a href="', make_filename_from_person(person => $mother), '">',
					given_names($mother),
					'</a>';
				# print $xml '&lt;a href="?page=people&amp;entry=', $mother->xref(), '"&gt;',
					# $mother->given_names(),
					# '&lt;/a&gt;';
				$phrase->append('<a href="?page=people&entry=' . $mother->xref() . '">' .
					given_names($mother) .
					'</a>');
			}
		}
	}

	my $bio;	# This is used to generate the texts for the static page
	if($firstname) {
		if((!$is_alive) || $opts{'l'} || (!defined($me)) || ($person->xref() ne $me->xref())) {
			if($opts{'l'} || $is_alive) {
				if($relationship) {
					if($phrase->length()) {
						print $html ', ';
						$phrase->append(', ');
					}
					$bio = "<b>$firstname</b>";
					$phrase->append("<b>$firstname</b>");
					if(($dateofbirth || $marriage) && (!($is_alive || $opts{'l'}))) {
						$bio .= ',';
						$phrase->append(',');
					} elsif($is_alive) {
						$bio .= i18n(' is');
						$phrase->append(i18n('is '));
					} else {
						$bio .= i18n(' was');
						$phrase->append(i18n('was '));
					}
				}
			} else {
				if($phrase->length()) {
					print $html ', ';
					$phrase->append(', ');
				}
				if($surname) {
					$bio = "<b>$firstname $surname</b>";
					$phrase->append("<b>$firstname $surname</b>");
				} elsif($name_components{'surname_1'}) {
					$bio = "<b>$firstname " .
						$name_components{'surname_1'} .
						'</b>';
					$phrase->append("<b>$firstname " .
						$name_components{'surname_1'} .
						'</b>');
				} else {
					$bio = "<b>$firstname</b>";
					$phrase->append("<b>$firstname</b>");
				}
				if($relationship) {
					if($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism) {
						$bio .= ',';
						$phrase->append(',');
					} elsif($opts{'l'} || $is_alive) {
						$bio .= i18n(' is');
						$phrase->append(i18n(' is'));
					} else {
						$bio .= i18n(' was');
						$phrase->append(i18n(' was'));
					}
				}
			}
		}
	} else {
		$bio .= $pronoun;
		$phrase->append($pronoun);
	}

	if(defined($bio) && (length($bio) > 0)) {
		print $html $bio;
		# my $encoded = HTML::Entities::encode($bio);
		# $encoded =~ s/&euml;/&#235;/g;
		# print $xml HTML::Entities::encode($encoded);

		$fullbio .= $bio;
		undef $bio;
	}

	my $haveprintedspousename;
	if($relationship) {
		my $article;
		if($relationship =~ /^cousin/) {
			$article = ' a';
		} else {
			$article = ' the';
		}
		my $myname = $me->as_string(nee => 1);
		$bio = "$article $relationship of " .
			'<a href="' . make_filename_from_person(person => $me) . '">' .
			wide_to_html($myname) .
			'</a>';
		# print $xml " the $relationship of ",
			# '&lt;a href="?page=people&amp;home=1"&gt;',
			# $me->as_string(nee => 1),
			# '&lt;/a&gt;';
		$phrase->append("$article $relationship of " .
			'<a href="?page=people&home=1">' .
			"$myname</a>");
	} elsif($spouserelationship) {
		if((!$is_alive) || $opts{'l'}) {
			if($sex eq 'F') {
				print $html ', the wife of';
			} else {
				print $html ', the husband of';
			}
		} else {
			if($sex eq 'F') {
				print $html 'The wife of';
			} else {
				print $html 'The husband of';
			}
		}
		if($phrase->length()) {
			push @phrases, $phrase;
			$phrase = Data::Text->new();
		}
		if($sex eq 'F') {
			$phrase->set(i18n('the wife'));
		} else {
			$phrase->set(i18n('the husband'));
		}
		$phrase->append(i18n(' of '));
		my $s = $spouse->as_string({ middle_names => 1, title => 1 });
		if(!defined($s)) {
			complain({ person => $spouse, warning => 'Seems to have no name' });
			$s = 'your relation';
		}
		print $html ' <a href="', make_filename_from_person(person => $spouse), '">',
			wide_to_html($s),
			"</a> (the $spouserelationship of ",
			'<a href="', make_filename_from_person(person => $me), '">',
			wide_to_html($me->as_string(nee => 1)),
			'</a>)';
		$phrase->append(' <a href="?page=people&entry=' . $spouse->xref() . '">' .
			"$s</a> (the $spouserelationship of " .
			'<a href="?page=people&home=1">' .
			$me->as_string(nee => 1) .
			'</a>)');
		# print $xml ' &lt;a href="?page=people&amp;entry=', $spouse->xref(), '"&gt;',
			# wide_to_xml($s),
			# "$s&lt;/a&gt; the $spouserelationship of ",
			# '&lt;a href="?page=people&amp;home=1"&gt;',
			# wide_to_xml($me->as_string(nee => 1)),
			# '&lt;/a&gt;';
		if($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $dateofmarriage) {
			print $html ',';
			$both_xmls->print(',');
		}
		if($phrase->length()) {
			push @phrases, $phrase;
			$phrase = Data::Text->new();
		}
		$haveprintedspousename = 1;
	}

	if(($opts{'l'} || !$is_alive) && (my $aka = $person->as_string({ use_aka => 1 }))) {
		$phrase->append(" (also known as $aka)");
		print $html " (also known as $aka)";
		$both_xmls->print('<aka>')->print(wide_to_xml($aka))->print("</aka>\n\t\t\t\t");
		$parse_tree->{'aka'} = $aka;
	}

	my $start_of_paragraph = 0;
	my $end_of_sentence = 0;
	my $printed_and = 0;
	my $bio_dt = Data::Text->new();	# This is used to generate the dynamic text
	my @residences = get_all_residences($person);

	my @childrenunknownparent;
	if($opts{'l'} || !$is_alive) {
		my $all_children_are_alive = 1;

		if($yob && ($year >= $yob + 150)) {
			$all_children_are_alive = 0;
		} else {
			foreach my $child(@children) {
				if(!is_alive(person => $child)) {
					$all_children_are_alive = 0;
					last;
				}
			}
		}

		print "all_children_are_alive = $all_children_are_alive\n" if($opts{'v'});

		if($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism) {
			if($dateofbirth || $placeofbirth) {
				# print $html ',' if($print_sibling_count && (!$opts{'a'}) && !$opts{'p'});

				if($relationship) {
					$bio .= ',';
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				} elsif($phrase->length()) {
					$phrase->append(' ');
				}
				$phrase->append(i18n({ person => $person, format => 'was born' }));
				$bio .= i18n({ person => $person, format => ' was born' });
				if($placeofbirth) {
					my $p = place({ person => $person, place => $placeofbirth });
					$bio .= $p;
					$phrase->append($p);
					$places_printed{$p} = 1;
				} else {
					complain({ person => $person, warning => 'Date of birth is known, but not place' });
				}
				if($dateofbirth) {
					if($dateofbirth =~ /\s$/) {
						complain({ person => $person, warning => "Removing trailing spaces from date of birth '$dateofbirth'" });
						$dateofbirth =~ s/\s+$//;
					}
					my $y = between(year({
						person => $person,
						date => $dateofbirth,
						must_predate => $death_dt
					}));
					$bio .= " $y" if($y);
					$phrase->append(" $y") if($y);
				}
				$bio .= cite(@birthcitations);
				$phrase->append(cite(@birthcitations));
				if($dateofbaptism || $placeofbaptism) {
					if($phrase->length()) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
					if(scalar(@spouses) && ($numberofchildren > 0)) {
						$bio .= ', was';
					} else {
						$bio .= i18n(' and');
						$printed_and = 1;
						if($phrase->length()) {
							push @phrases, $phrase;
							$phrase = Data::Text->new('was');
						}
					}
				}
				$end_of_sentence = 0;
			}
			if($opts{'w'}) {
				if($mother && $yob && (my $mumdateofbirth = dateofbirth($mother))) {
					if($mumdateofbirth =~ /.*?(\d{3,4})/) {
						$mumdateofbirth = $1;
						if(($yob - $mumdateofbirth) <= 13) {
							complain({
								person => $person,
								warning => "Something is wrong with the date of birth which is less than 13 years after the mother was born ($mumdateofbirth)"
							});
						} elsif(($yob - $mumdateofbirth) >= 52) {
							complain({
								person => $person,
								warning => "Something is wrong with the date of birth which is more than 52 years after the mother was born ($mumdateofbirth)"
							});
						}
					}
				}
				if($father && $yob && (my $daddateofbirth = dateofbirth($father))) {
					if($daddateofbirth =~ /.*?(\d{3,4})/) {
						$daddateofbirth = $1;
						if(($yob - $daddateofbirth) <= 13) {
							complain({
								person => $person,
								warning => "Something is wrong with the date of birth which is less than 13 years after the father was born ($daddateofbirth)"
							});
						}
					}
				}
				# if($birth_dt || ($dateofbirth && ($dateofbirth =~ /^\d{3,4}$/))) {
					# TODO: Add more checking
					# TODO: remove this code once I've done a run
					# my $yob;
					# if($birth_dt) {
						# $yob = $birth_dt->year();
					# } elsif($dateofbirth =~ /^(\d{3,4})$/) {
						# $yob = $1;
					# } else {
						# die 'BUG: Impossible case';
					# }
				# }
				if(defined($yob)) {
					foreach my $dc(@deathcitations) {
						my $citation = $citations{$dc};
						if(my $title = $citation->title()) {
							if($title =~ /^(\d{3,4})\s/) {
								if($1 < $yob) {
									complain({
										person => $person,
										warning => "Year of citation of $title is before the birth year of $yob"
									});
								}
							}
						}
					}
				}
				# if($death_dt || ($dateofdeath && ($dateofdeath =~ /^\d{3,4}$/))) {
					# my $yod;
					# # TODO: Add more checking
					# if($death_dt) {
						# $yod = $death_dt->year();
					# } elsif($dateofdeath =~ /^(\d{3,4})$/) {
						# $yod = $1;
					# } else {
						# die "BUG: Impossible case";
					# }
				# }
				if(defined($yod)) {
					foreach my $bc(@birthcitations) {
						my $citation = $citations{$bc};
						if(my $title = $citation->title()) {
							if($title =~ /^(\d{3,4})\s/) {
								if($1 > $yod) {
									complain({
										person => $person,
										warning => "Year of citation of $title is after the death year of $yod"
									});
								}
							}
						}
					}
				}
			}
			if($dateofbaptism || $placeofbaptism) {
				$bio .= ' ';
				$phrase->append(' ') if($phrase->length());
				unless($dateofbirth || $placeofbirth) {
					if($language eq 'French') {
						if($placeofbaptism && $placeofbirth && ($placeofbaptism eq $placeofbirth)) {
							$bio .= " $pronoun y a \N{U+00E9}t\N{U+00E9} ";	# a Ã©tÃ©
							$phrase->append(" $pronoun y a \N{U+00E9}t\N{U+00E9} ");	# a Ã©tÃ©
						} else {
							$phrase->append(" $pronoun a \N{U+00E9}t\N{U+00E9} ");	# a Ã©tÃ©
						}
					} else {
						$bio .= i18n('was ');
						$phrase->append(i18n('was '));
					}
				}
				if($language eq 'French') {
					$bio .= "a baptis\N{U+00E9}";
					$phrase->append("a baptis\N{U+00E9}");
				} elsif($ENV{'LANG'} =~ /^en_US/) {
					$bio .= 'baptized';
					$phrase->append('baptized');
				} else {
					$bio .= 'baptised';
					$phrase->append('baptised');
				}
				if($placeofbaptism) {
					if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
						$bio .= ' there' unless($language eq 'French');
						$phrase->append(' there') unless($language eq 'French');
						if(my $address = $baptism->address()) {
							if($address =~ /(.+),\s*$placeofbirth$/) {
								$address = $1;
							}
							$bio .= i18n(' at') . " $address";
							$phrase->append(i18n(' at') . " $address");
						}
					} else {
						my $p = place({ person => $person, place => $placeofbaptism });
						$bio .= $p;
						$phrase->append($p);
						$places_printed{$p} = 1;
					}
				}
				if($dateofbaptism) {
					if($opts{'w'} && $yob && ($dateofbaptism =~ /(\d{3,4})$/)) {
						# must_predate doesn't work when only years are known
						if($1 < $yob) {
							complain({
								person => $person,
								warning => "Year of baptism $1 is before the year of birth $yob"
							});
						}
					}
					$bio .= ' ' . year({
						person => $person,
						date => $dateofbaptism,
						must_postdate => $birth_dt,
						must_predate => $death_dt
					}) . sibling_baptism_string({
						person => $person,
						siblings => \@siblings,
						date => $dateofbaptism,
						birthdate => $dateofbirth,
					});
					$phrase->append(' ' . year({
						person => $person,
						date => $dateofbaptism,
						must_postdate => $birth_dt,
						must_predate => $death_dt
					}) . sibling_baptism_string({
						person => $person,
						siblings => \@siblings,
						date => $dateofbaptism,
						birthdate => $dateofbirth,
					}));
					if(!$death_dt) {
						must_predate({
							person => $person,
							date => $dateofbaptism,
							predate => $dateofdeath
						});
					}
					if($mother && $opts{'w'}) {
						if($dateofbaptism =~ /.*?(\d{3,4})/) {
							my $yobaptism = $1;
							if(my $motherdob = dateofbirth($mother)) {
								my $d = $date_parser->parse(date => $motherdob);
								if($d && (ref($d) eq 'ARRAY')) {
									$d = $d->[0];
									if(defined($d) && !$d->{'flag'}) {
										$d = $dfn->parse_datetime($d->{'canonical'})->strftime('%Y');
										if($d > ($yobaptism - 13)) {
											complain({
												person => $person,
												warning => "Something is wrong with the date of baptism which is less than 13 years after the mother was born ($d)"
											});
										}
									}
								}
							}
						} else {
							complain({
								person => $person,
								warning => "invalid date of baptism $dateofbaptism"
							});
						}
					}
				}
			} elsif($birth_dt) {
				my @person_twins = twins({ birth_dt => $birth_dt, siblings => \@siblings });

				if(scalar(@person_twins) == 1) {	# TODO: triplets and higher order
					my $t = $person_twins[0];
					my $sibling = $t->{'sibling'};
					my $dob = $t->{'dob'};
					if($dob == $birth_dt) {
						$bio .= ' along with ';
						$phrase->append(' along with ');
						$parse_tree->{'twin'}->{'sibling'}->{'dateofbirth'} = 'same';
					} elsif($dob == ($birth_dt + $oneday)) {
						$bio .= i18n(', a day before ');
						if($phrase->length()) {
							push @phrases, $phrase;
							$phrase = Data::Text->new();
						}
						$phrase->append(i18n('a day before '));
						$parse_tree->{'twin'}->{'sibling'}->{'dateofbirth'} = 'before';
					} else {
						$bio .= ', a day after ';
						if($phrase->length()) {
							push @phrases, $phrase;
							$phrase = Data::Text->new();
						}
						$phrase->append(i18n('a day after '));
						$parse_tree->{'twin'}->{'sibling'}->{'dateofbirth'} = 'after';
					}
					my $ssex = $sibling->sex();
					$parse_tree->{'twin'}->{'sibling'}->{'sex'} = $ssex;
					if($language eq 'French') {
						$bio .= ($ssex eq 'M' ? "son jumeau fr\N{U+00E8}re" : "sa jumelle s\N{U+0153}er");
						$phrase->append(($ssex eq 'M' ? "son jumeau fr\N{U+00E8}re " : "sa jumelle s\N{U+0153}er "));
					} else {
						$bio .= ($sex eq 'M' ? 'his' : 'her') . ' twin ' .
							i18n(($ssex eq 'F') ? 'sister ' : 'brother ');
						$phrase->append(($sex eq 'M' ? 'his' : 'her') . ' twin ' .
							i18n(($ssex eq 'F') ? 'sister ' : 'brother '));
					}
					if(my $given = given_names($sibling)) {
						$bio .= $given;
						$phrase->append($given);
					}
					if($dateofbaptism || $placeofbaptism) {
						$bio .= ',';
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
					$twins{$person->xref()} = $sibling->xref();
				}
				if(scalar(@spouses) && ($numberofchildren > 0)) {
					$bio .= i18n(' and');
					$printed_and = 1;
					if($phrase->length()) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
				}
			}

			if(scalar(@spouses) && ($numberofchildren > 0) && !$all_children_are_alive) {
				# $bio .= ' and';
			} else {
				$bio .= '.';
				$end_of_sentence = 1;
				if($phrase->length()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				if(scalar(@phrases)) {
					$bio_dt->set(conjunction(map { $_->as_string() } @phrases))->append('.');
					@phrases = ();
				}
			}
		} elsif($dateofbaptism || $placeofbaptism) {
			die;	# I don't this code can be reached
			if($language eq 'French') {
				if($placeofbaptism && $placeofbirth && ($placeofbaptism eq $placeofbirth)) {
					$bio .= " $pronoun y a \N{U+00E9}t\N{U+00E9} ";	# a Ã©tÃ©
					$phrase->append(" $pronoun y a \N{U+00E9}t\N{U+00E9} ");	# a Ã©tÃ©
				} else {
					$bio .= " $pronoun a \N{U+00E9}t\N{U+00E9} ";	# a Ã©tÃ©
					$phrase->append(" $pronoun a \N{U+00E9}t\N{U+00E9} ");	# a Ã©tÃ©
				}
			} else {
				$bio .= " $pronoun was ";
				$phrase->append(" $pronoun was ");
			}

			if($language eq 'French') {
				$bio .= "baptis\N{U+00E9}";
				$phrase->append("baptis\N{U+00E9}");
				if($sex eq 'F') {
					$bio .= 'e';
					$phrase->append('e');
				}
			} elsif($ENV{'LANG'} =~ /^en_US/) {
				$bio .= 'baptized';
				$phrase->append('baptized');
			} else {
				$bio .= 'baptised';
				$phrase->append('baptised');
			}
			if($placeofbaptism) {
				if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
					if($language eq 'German') {
						$bio .= ' dort';
						$phrase->append(' dort');
					} else {
						$bio .= ' there';
						$phrase->append(' there');
					}
					if(my $address = $baptism->address()) {
						$bio .= " at $address";
						$phrase->append(" at $address");
					}
				} else {
					my $opts = {
						person => $person,
						place => $placeofbaptism,
						places_printed => \%places_printed
					};
					if(my $address = $baptism->address()) {
						$opts->{'address'} = $address;
					}
					my $p = place($opts);
					$bio .= $p;
					$phrase->append($p);
					$places_printed{$p} = 1;
				}
			}
			if($dateofbaptism) {
				$bio .= ' ' . year({
					person => $person,
					date => $dateofbaptism,
					must_postdate => $birth_dt,
					must_predate => $death_dt
				}) . sibling_baptism_string({
					person => $person,
					siblings => \@siblings,
					date => $dateofbaptism,
					birthdate => $dateofbirth,
				});
				$phrase->append(' ' . year({
					person => $person,
					date => $dateofbaptism,
					must_postdate => $birth_dt,
					must_predate => $death_dt
				}) . sibling_baptism_string({
					person => $person,
					siblings => \@siblings,
					date => $dateofbaptism,
					birthdate => $dateofbirth,
				}));
			}
			if(scalar(@spouses)) {
				if(!scalar(@residences)) {
					$bio .= ',';
				}
				if($phrase->length()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				$end_of_sentence = 0;
			} else {
				$bio .= '.';
				$end_of_sentence = 1;
				push @phrases, $phrase;
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				$phrase = Data::Text->new();
				@phrases = ();
			}
		}

		# Is/was this person an orphan?
		if($mother && $father && $yob) {
			if((my $mdod = dateofdeath($mother)) &&
			   (my $fdod = dateofdeath($father))) {
				my $myod;
				my $fyod;
				if(($fdod =~ /.*?(\d{3,4})/)) {
					$fyod = $1;
				}
				if(($mdod =~ /.*?(\d{3,4})/)) {
					$myod = $1;
				}
				if((!defined($fyod)) || (!defined($myod))) {
					die "BUG: !fyod || !myod";
				}
				if((($fyod - $yob) < 16) && (($myod - $yob) < 16)) {
					if($end_of_sentence) {
						$bio .= " $pronoun";
						$phrase->append(" $pronoun ");
					} elsif(scalar(@person_twins) || $dateofbaptism) {
						$bio .= i18n(' and');
						$printed_and = 1;
						if($phrase->length()) {
							push @phrases, $phrase;
							$phrase = Data::Text->new();
						}
					} else {
						$bio .= ', and';
						$printed_and = 1;
						if($phrase->length()) {
							push @phrases, $phrase;
							$phrase = Data::Text->new();
						}
					}
					$bio .= ' was orphaned ';
					$phrase->append('was orphaned ');
					my $orphaned_year = (($myod > $fyod) ? $myod : $fyod);
					if($myod == $fyod) {
						$bio .= "in $myod by the death of both parents in that year ";
						$phrase->append("in $myod by the death of both parents in that year ");
						$bio .= 'when both of ' .
							($person->pronoun() eq 'She') ? 'her' : 'his' .
							" parents died in $myod when " .
							lcfirst($person->pronoun()) .
							' was ' . $myod - $yob . ' years old';
						$phrase->append('when both of ' .
							($person->pronoun() eq 'She') ? 'her' : 'his' .
							" parents died in $myod when " .
							lcfirst($person->pronoun()) .
							' was ' . $myod - $yob . ' years old');
					} elsif($myod > $fyod) {
						$bio .= 'at the age of ' . ($myod - $yob) .
							i18n(' following the death of ') .
							(($person->pronoun() eq 'She') ? 'her' : 'his') .
							" father in $fyod and mother in $myod";
						$phrase->append('at the age of ' . ($myod - $yob) .
							i18n(' following the death of ') .
							(($person->pronoun() eq 'She') ? 'her' : 'his') .
							" father in $fyod and mother in $myod");
					} else {
						$bio .= 'at the age of ' . ($fyod - $yob) .
							i18n(' following the death of ') .
							(($person->pronoun() eq 'She') ? 'her' : 'his') .
							" mother in $myod and father in $fyod";
						$phrase->append('at the age of ' . ($fyod - $yob) .
							i18n(' following the death of ') .
							(($person->pronoun() eq 'She') ? 'her' : 'his') .
							" mother in $myod and father in $fyod");
					}
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.<p></p>');
					$phrase = Data::Text->new();
					@phrases = ();

					$bio .= '.</p><p>';
					$end_of_sentence = 1;
					$start_of_paragraph = 1;

					$both_xmls->print("<orphaned>$orphaned_year</orphaned>\n\t\t\t\t");
					push @{$orphans{$orphaned_year}}, $person->xref();
				}
			}
		}

		print "bio so far: $bio\n" if($opts{'v'} && defined($bio));

		my @education = $person->education();

		if(scalar(@education)) {
			if($end_of_sentence) {
				$bio .= " $pronoun";
			}

			if($phrase->length() > 0) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			} elsif(scalar(@phrases) == 0) {
				$phrase->set("$pronoun ");
			}

			if($language eq 'French') {
				$bio .= " a fait ses \N{U+00E9}tudes \N{U+00E0}";
				$phrase->append(" a fait ses \N{U+00E9}tudes \N{U+00E0}");
			} else {
				$bio .= ' went to';
				$phrase->append(' went to');
			}

			# FIXME: do all schools
			$bio .= place({ person => $person, record => $education[0], places_printed => \%places_printed, nopreposition => 1 });
			$phrase->append(place({ person => $person, record => $education[0], places_printed => \%places_printed, nopreposition => 1 }));
			push @phrases, $phrase;
			$phrase = Data::Text->new();

			if($numberofchildren) {
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				@phrases = ();
			}

			$printed_and = 0;
			$end_of_sentence = 1;
		}

		# TODO: children != 0 && spouses == 0
		if(scalar(@spouses) &&
		   ((!$spouserelationship) || $placeofmarriage || $dateofmarriage)) {
			$bio .= " $pronoun" if($end_of_sentence);
			$phrase->append(" $pronoun") if(scalar(@phrases) == 0);

			if(scalar(@spouses) == 1) {
				if(!$printed_and) {
					$bio .= i18n(' and') if(!$end_of_sentence);
					$printed_and = 1;
					$end_of_sentence = 0;
				}
				if(($phrase->length() > 3) && (scalar(@phrases) > 0)) {
					# Don't create a new phrase if it's just the pronoun
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				if($placeofmarriage || $dateofmarriage) {
					$phrase->append(' ') if(scalar(@phrases) == 0);
					if($placeofbaptism && $placeofmarriage && ($placeofmarriage eq $placeofbaptism) &&
					   !$end_of_sentence) {
						$bio .= i18n(' also');
						$phrase->append(i18n('also '));
					}
					my %args = (person => $person);
					if($spouserelationship) {
						$args{'format'} = 'married ';
					} elsif(is_alive(person => $person) && is_alive(person => $spouses[0])) {
						if($placeofmarriage || $dateofmarriage) {
							$args{'format'} = 'married ';
						} else {
							$args{'format'} = 'is married to ';
						}
					} else {
						$args{'format'} = 'married ';
					}
					$bio .= ' ' . i18n(\%args);
					$phrase->append(i18n(\%args));

					# Note if this person married a relative
					if(my $srelationship = $person->relationship($spouses[0])) {
						$phrase->append(($person->pronoun() eq 'She') ? 'her ' : 'his ')
							->append($srelationship)->append(' ');
						$bio .= (($person->pronoun() eq 'She') ? 'her ' : 'his ') .
							"$srelationship ";
						$intermarriages{$person->xref()} = {
							'spouse_xref' => $spouses[0]->xref(),
							'relationship' => ucfirst($srelationship)
						};
					}

					if($haveprintedspousename) {
						$nameparser->parse($spouses[0]->name());

						my %name_components = $nameparser->components();
						if(my $n = $name_components{'given_name_1'}) {
							$bio .= $n;
							$phrase->append($n);
						} else {
							complain({ person => $spouses[0], warning => 'seems to have no first name' });
						}
					} else {
						print $html wide_to_html({ string => $bio, keep_hrefs => 1 });
						# $bio =~ s/&/&amp;/g;
						# $bio =~ s/</&lt;/g;
						# $bio =~ s/>/&gt;/g;
						# $bio =~ s/&amp;amp;/&amp;/g;	# Because of the Encode entities
						# print $xml $bio;

						$fullbio .= $bio . $spouses[0]->as_string();
						undef $bio;

						if($opts{'l'} || !$is_alive) {
							print $html '<a href="', make_filename_from_person(person => $spouses[0]), '">',
								wide_to_html($spouses[0]->as_string()),
								'</a>';
							# print $xml '&lt;a href="?page=people&amp;entry=', $spouses[0]->xref(), '"&gt;',
								# $spouses[0]->as_string(),
								# '&lt;/a&gt;';
							$phrase->append('<a href="?page=people&entry=' . $spouses[0]->xref() . '">' .
								$spouses[0]->as_string() .
								'</a>');
						} else {
							print $html '<a href="', make_filename_from_person(person => $spouses[0]), '">',
								wide_to_html(given_names($spouses[0])),
								'</a>';
							# print $xml '&lt;a href="?page=people&amp;entry=', $spouses[0]->xref(), '"&gt;',
								# $spouses[0]->given_names(),
								# '&lt;/a&gt;';
							$phrase->append('<a href="?page=people&entry=' . $spouses[0]->xref() . '">' .
								given_names($spouses[0]) .
								'</a>');
						}
						$haveprintedspousename = 1;
					}
				}
				my $parentheses = 0;
				if($numberofchildren) {
					if($placeofmarriage || $dateofmarriage) {
						my @spouse_occupations = get_all_occupations($spouses[0]);
						if(my $soccupation = $spouse_occupations[0]) {
							$parentheses = 1;
							if($language eq 'English') {
								$bio .= ' (' . Lingua::EN::Inflect::A(lc($soccupation)) . ' ';
								$phrase->append(' (' . Lingua::EN::Inflect::A(lc($soccupation)) . ' ');
							} else {
								# FIXME - handle feminine versions for women
								$bio .= ' (un ' . lc($soccupation) . ' ';
								$phrase->append(' (un ' . lc($soccupation) . ' ');
							}
						}
					}
					my @childrenofthisspouse;
					my $numberofchildrenwiththisspouse = $numberofchildren;
					my $spouse = $spouses[0];
					my $sxref = $spouse->xref();
					foreach my $child(@children) {
						if($sex eq 'F') {
							# Check through all possible fathers, since there could be a biological and
							# and adoptive ones listed
							# FIXME: this assumes that the spouse is the biological father, which is not
							#	a good assumption to make
							my @candidates = $child->father();
							my $father;
							foreach (@candidates) {
								if($_->xref() eq $sxref) {
									$father = $_;
									last;
								}
							}
							if((!defined($father)) || ($father->xref() ne $sxref)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						} else {
							my $mother = $child->mother();
							if((!defined($mother)) || ($mother->xref() ne $sxref)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						}
						if($opts{'w'} && $yob && (my $cdob = dateofbirth($child))) {
							my $age = get_year_from_date($cdob) - $yob;
							if($age <= 14) {
								if($age < 0) {
									complain({ person => $person, warning => 'Child ' . $child->as_string() . " $cdob which is before date of birth of $yob" });
								} else {
									complain({ person => $person, warning => "Only $age years old at time of birth of their child " . $child->as_string() });
								}
							}
						}
					}
					if(scalar(@childrenunknownparent) < $numberofchildren) {
						if($placeofmarriage || $dateofmarriage) {
							if(!$parentheses) {
								$bio .= ' (';
								$phrase->append(' (');
								$parentheses = 1;
							}
							if($language eq 'French') {
								$bio .= 'avec qui ' . lcfirst($pronoun);
								$phrase->append('avec qui ' . lcfirst($pronoun));
							} elsif($language eq 'German') {
								$bio .= 'mit wem ' . lcfirst($pronoun);
								$phrase->append('mit wem ' . lcfirst($pronoun));
							} else {
								$bio .= 'with whom ' . lcfirst($pronoun);
								$phrase->append('with whom ' . lcfirst($pronoun));
							}
						}
						if((!$all_children_are_alive) || (!$opts{'l'}) || ($yob && ($year > $yob + ASSUME_NOT_LIVING))) {
							if($phrase->length()) {
								$bio .= ' ';
								$phrase->append(' ');
							}
							if(is_alive(person => $person)) {
								$bio .= 'has ';
								$phrase->append('has ');
							}
							$bio .= 'had ';
							$phrase->append('had ');
						} elsif((!$dateofdeath) && (!$dateofburial) && ($spouses[0]) && !$spouses[0]->death()) {
							$bio .= i18n(' has had ');
							$phrase->append(i18n(' has had '));
						} else {
							$bio .= $dateofdeath || $dateofburial ? ' had ' : ' has ';
							$phrase->append($dateofdeath || $dateofburial ? ' had ' : ' has ');
						}

						if($numberofchildrenwiththisspouse == 1) {
							if($all_children_are_alive) {
								if($language eq 'French') {
									$bio .= '1 surviving enfant';
									$phrase->append('1 surviving enfant');
								} else {
									$bio .= '1 surviving child';
									$phrase->append('1 surviving child');
								}
								if($opts{'l'}) {
									$bio .= ', ';
									$phrase->append(', ');
								}
							} elsif($language eq 'French') {
								$bio .= '1 enfant, ';
								$phrase->append('1 enfant, ');
							} else {
								$bio .= '1 child, ';
								$phrase->append('1 child, ');
							}
						} else {
							if($all_children_are_alive) {
								$bio .= "$numberofchildrenwiththisspouse surviving children";
								$phrase->append("$numberofchildrenwiththisspouse surviving children");
							} else {
								$bio .= "$numberofchildrenwiththisspouse children";
								$phrase->append("$numberofchildrenwiththisspouse children");
								if($placeofmarriage || $dateofmarriage) {
									$bio .= ($language eq 'French') ? ' :' : ':';
									$phrase->append(($language eq 'French') ? ' :' : ':');
								}
							}
							$bio .= ' ';
							$phrase->append(' ');
						}
						if((!$placeofmarriage) && !$dateofmarriage) {
							if(length(my $spouse_name = $spouse->as_string({ middle_names => 1, title => 1 }))) {
								$bio .= i18n({ format => 'with %s', args => $spouse_name });
								$phrase->append(i18n({ format => 'with %s', args => $spouse_name }));
							} else {
								complain({ person => $person, warning => "Can't determine spouse name from record" });
							}
							my @spouse_occupations = get_all_occupations($spouses[0]);
							if(my $soccupation = $spouse_occupations[0]) {
								if($language eq 'English') {
									$bio .= ' (' . Lingua::EN::Inflect::A(lc($soccupation)) . ')';
									$phrase->append(' (' . Lingua::EN::Inflect::A(lc($soccupation)) . ')');
								} else {
									# FIXME - handle feminine versions for women
									$bio .= ' (un ' . lc($soccupation) . ')';
									$phrase->append(' (un ' . lc($soccupation) . ')');
								}
							}
							$haveprintedspousename = 1;
							$bio .= ': ';
							$phrase->append(': ');
						}
						if($numberofchildrenwiththisspouse == 1) {
							my $child = $children[0];
							if($opts{'l'} || (!is_alive(person => $child)) || (defined($me) && ($child->xref() eq $me->xref()))) {
								if(my $first_name = given_names($child)) {
									$bio .= $first_name;
									$phrase->append($first_name);
								} else {
									$bio .= 'whose first name is unknown';
									$phrase->append('whose first name is unknown');
								}
								if($phrase->length()) {
									push @phrases, $phrase;
									$phrase = Data::Text->new();
									$bio .= ','  if(!$parentheses);
								}
							}
						} elsif($numberofchildrenwiththisspouse > 1) {
							# Construct the list for the static pages
							my $childnames = join(', ', map {
								'<a href="' . make_filename_from_person(person => $_) . '">' .
									given_names($_) . '</a>'
							} @childrenofthisspouse);
							substr($childnames, rindex($childnames, ', '), 2, ' and ');
							$bio .= $childnames;

							# Construct the list for the dynamic pages
							my @childlist;
							my $alive_children = 0;
							foreach my $child(@childrenofthisspouse) {
								if($opts{'l'} || (!is_alive(person => $child)) || (defined($me) && ($child->xref() eq $me->xref()))) {
									my $cgiven = given_names($child);
									if(length($cgiven)) {
										push @childlist,
											'<a href="?page=people&entry=' . $child->xref() . '">' .
											"$cgiven</a>";
									}
								} else {
									$alive_children++;
									# push @childlist, $child->given_names();
								}
							}
							if(scalar(@childlist)) {
								# $bio .= conjunction(@childlist);
								$phrase->append(conjunction(@childlist));
								if($alive_children == 1) {
									$bio .= ', along with 1 surviving child';
									$phrase->append(', along with 1 surviving child');
								} elsif($alive_children > 1) {
									$bio .= ", along with $alive_children surviving children";
									$phrase->append(", along with $alive_children surviving children");
								}
							}
						}
					}
				} else {	# no children
					my @spouse_occupations = get_all_occupations($spouses[0]);
					if($spouse_occupations[0]) {
						$bio .= ' (' . HTML::Entities::encode(Lingua::EN::Inflect::A(lc($spouse_occupations[0])));
						$phrase->append(' (' . HTML::Entities::encode(Lingua::EN::Inflect::A(lc($spouse_occupations[0]))));
						$parentheses = 1;
					}
				}
				if($opts{'l'} || !$is_alive) {
					if($parentheses) {
						$bio .= ')';
						$phrase->append(')');
					}
					if($placeofmarriage && $dateofmarriage &&
					   ($placeofbaptism and ($placeofmarriage eq $placeofbaptism))) {
						if(($language eq 'English') && (defined($placeofbaptism) and ($placeofmarriage eq $placeofbaptism))) {
							$bio .= ' there';
							$phrase->append(' there');

							if(my $address = $marriage->address()) {
								if($address eq 'Parish Church') {
									$bio .= ' at the Parish Church';
									$phrase->append(' at the Parish Church');
								} elsif($address eq 'Registry Office') {
									$bio .= ' at the Registry Office';
									$phrase->append(' at the Registry Office');
								} else {
									$bio .= " at $address";
									$phrase->append(" at $address");
								}
							}
						} else {
							$bio .= place({ person => $person, record => $marriage });
							$phrase->append(place({ person => $person, record => $marriage }));
						}
						$bio .= ', ' . year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt);
						$phrase->append(', ' . year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt));
					} else {
						if($placeofmarriage) {
							my $args = {
								place => $placeofmarriage,
								person => $person,
								places_printed => \%places_printed
							};
							if($marriage && (my $address = $marriage->address())) {
								$args->{'address'} = $address;
							}
							my $p = place($args);
							$bio .= $p;
							$phrase->append($p);
							$places_printed{$p} = 1;
						} elsif(!$haveprintedspousename) {
							if($numberofchildren && !$end_of_sentence) {
								$bio .= ". $pronoun";
							}
							if($numberofchildren) {
								push @phrases, $phrase;
								$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
								$phrase = Data::Text->new($pronoun);
								@phrases = ();
							}

							$spouse //= $spouses[0];
							if(my $s = $spouse->as_string({ middle_names => 1, title => 1 })) {
								if(is_alive(person => $person) && is_alive(person => $spouse)) {
									$bio .= i18n({ person => $person, format => ' is married to ' });
									$phrase->append(i18n({ person => $person, format => ' is married to ' }));
								} else {
									$bio .= i18n({ person => $person, format => ' was married to ' });
									$phrase->append(i18n({ person => $person, format => ' was married to ' }));
								}
								$bio .= $s;
								$phrase->append($s);
							} else {
								complain({ person => $spouse, warning => 'Seems to have no name' });
							}
							$haveprintedspousename = 1;
						}
						if($dateofmarriage) {
							my $string = ' ' . year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt, circa => 'around');
							$bio .= $string;
							$phrase->append($string);
						}
					}
					if($marriagecitation) {
						$bio .= cite(($marriagecitation));
						$phrase->append(cite(($marriagecitation)));
					}
					if(defined($marriage)) {
						my $do_marriage_notes = 1;
						if($placeofmarriage && (my $addr = $marriage->address()) && (my $notes = $marriage->get_value())) {
							if("$addr, $placeofmarriage" =~ /^\Q$notes\E/) {
								# This can happen with things like this
								# 1 MARR Ebenezer Chapel, Meeting Street, Ramsgate
								# 2 _PRIM Y
								# 2 DATE 10 Dec 1882
								# 2 PLAC Ramsgate, Kent, England
								# 2 ADDR Ebenezer Chapel, Meeting Street
								$do_marriage_notes = 0;
							}
						}
						if($do_marriage_notes && (my $notes = notes(record => $marriage))) {
							$notes =~ s/\.$//;
							$bio .= " ($notes)";
							$phrase->append(" ($notes)");
						}
					}
				}
			} elsif($opts{'l'} || !$is_alive) {	# scalar(@spouses) > 1
				if($is_alive) {
					$bio .= i18n(person => $person, format => 'has been married');
					$phrase->append(i18n(person => $person, format => 'has been married'));
				} elsif($language eq 'French') {
					$bio .= " a \N{U+00E9}t\N{U+00E9} mari\N{U+00E9}";
					$phrase->append(" a \N{U+00E9}t\N{U+00E9} mari\N{U+00E9}");
					if($sex eq 'F') {
						$bio .= 'e';
						$phrase->append('e');
					}
				} else {
					$bio .= ' was married';
					$phrase->append(' was married');
				}

				if(scalar(@spouses) == 2) {
					if($spouses[0]->xref() eq $spouses[1]->xref()) {
						complain({ person => $person, warning => [ 'Married twice to ', $spouses[0]->as_string() ] });
					} else {
						$bio .= i18n(' twice');
						$phrase->append(i18n(' twice'));
					}
				} else {
					$bio .= ' ' . scalar(@spouses) . i18n(' times');
					$phrase->append(' ' . scalar(@spouses))->append(i18n(' times'));
				}

				$bio .= ' - to';

				print $html wide_to_html({ string => $bio, keep_hrefs => 1 });
				# $bio =~ s/</&lt;/g;
				# $bio =~ s/>/&gt;/g;
				# $bio =~ s/&/&amp;/g;
				# print $xml $bio;

				$fullbio .= $bio;
				undef $bio;

				# Sort the marriages by date
				my $all_marriages_have_date = 1;
				foreach my $spouse(@spouses) {
					if(my $dom = dateofmarriage($spouse)) {
						if(!date_to_datetime($dom)) {
							$all_marriages_have_date = 0;
							last;
						}
					} else {
						$all_marriages_have_date = 0;
						last;
					}
				}

				if($all_marriages_have_date) {
					@spouses = Sort::Key::DateTime::dtkeysort {
						my $date = dateofmarriage($_);
						die "BUG: can't find all marriage dates" if(!defined($date));
						date_to_datetime(date => $date);
					} @spouses;
					# Already cached
					# @spouses = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @spouses;
				} elsif(scalar(@spouses) == 2) {
					# Married twice, even if we only know the years we can still sort
					my $date1 = dateofmarriage($spouses[0]);
					if(!defined($date1)) {
						if(my $mar = $spouses[0]->get_record('fams marriage')) {
							$date1 = $mar->date();
							if(!defined($date1)) {
								if($mar = $spouses[0]->get_record('marriage')) {
									$date1 = $mar->date();
								}
							}
						}
					}
					my $date2 = dateofmarriage($spouses[1]);
					if(!defined($date2)) {
						if(my $mar = $spouses[1]->get_record('fams marriage')) {
							$date2 = $mar->date();
							if(!defined($date2)) {
								if($mar = $spouses[1]->get_record('marriage')) {
									$date2 = $mar->date();
								}
							}
						}
					}

					if($date1 && $date2) {
						if($date1 ne $date2) {
							if($date1 =~ /.+(\d{4})$/) {
								my $year1 = $1;
								if($date2 =~ /.+(\d{4})$/) {
									my $year2 = $1;
									if($year2 < $year1) {
										# swap the spouses into marriage date order
										my $tmp = $spouses[0];
										$spouses[0] = $spouses[1];
										$spouses[1] = $tmp;
									}
								}
							}
						} else {
							complain({ person => $person, message => "Two marriages with the same date: $date1" });
						}
					}
				}

				my $spouse_number = 0;
				my $previousplace;
				my @names;
				foreach my $spouse(@spouses) {
					print $html ' <a href="', make_filename_from_person(person => $spouse), '">',
						$spouse->as_string(), '</a>';
					# print $xml ' &lt;a href="?page=people&amp;entry=', $spouse->xref(), '"&gt;',
						# $spouse->as_string(),
						# '&lt;/a&gt;';
					my $name = '<a href="?page=people&entry=' . $spouse->xref() . '">' .
						$spouse->as_string() .
						'</a>';
					my $dateofmarriage = dateofmarriage({ person => $spouse });
					my $placeofmarriage = get_value({ person => $spouse, value => 'marriage place' });
					if(!defined($placeofmarriage)) {
						if(my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage')) {
							$placeofmarriage = $marriage->place();
						}
					}
					if($placeofmarriage) {
						$placeofmarriage = undef if(lc($placeofmarriage) eq 'unknown');
					}
					if($placeofmarriage) {
						$placeofmarriage = place({ person => $spouse, place => $placeofmarriage, places_printed => \%places_printed });
						if($previousplace && ($placeofmarriage eq $previousplace)) {
							if($placeofmarriage =~ /^(.+?),/) {
								$placeofmarriage = i18n({ person => $person, format => ' also%s', args => $1 });
							}
						} else {
							$previousplace = $placeofmarriage;
						}
					} elsif(!$dateofmarriage) {
						# FIXME: possibly not married, so above it shouldn't have said "married x times"
						$name .= ' (possibly not married to ';
						if($spouse->sex() eq 'M') {
							$name .= 'him)';
						} else {
							$name .= 'her)';
						}
						push @names, $name;
						next;
					}

					my $printed_bracket = 0;
					if($dateofmarriage && $placeofmarriage) {
						$bio .= ' (' . year({ string => $dateofmarriage }) .
							$placeofmarriage;
						$name .= ' (' . year({ string => $dateofmarriage }) .
							$placeofmarriage;
						$printed_bracket = 1;
					} elsif($placeofmarriage) {
						$placeofmarriage =~ s/^\s+//;
						$bio .= " ($placeofmarriage";
						$name .= " ($placeofmarriage";
						$printed_bracket = 1;
					} elsif($dateofmarriage) {
						$bio .= ' (' . year({ string => $dateofmarriage });
						$name .= ' (' . year({ string => $dateofmarriage });
						$printed_bracket = 1;
					}
					$spouse_number++;
					if(defined($dateofmarriage) &&
					   (scalar(@spouses) == 2) &&
					   ($spouse_number == 2) &&
					   (my $death_of_first_spouse = dateofdeath($spouses[0]))) {
						# Determine if the second marriage was after a divorce or death
						if(datecmp($dateofmarriage, $death_of_first_spouse) > 0) {
							if($printed_bracket) {
								$bio .= ', ';
								$name .= ', ';
							} else {
								$bio .= '(';
								$name .= '(';
								$printed_bracket = 1;
							}
							if($death_of_first_spouse =~ /\s$/) {
								complain({ person => $person, warning => 'Removing trailing spaces from date' });
								$death_of_first_spouse =~ s/\s+$//;
							}
							$bio .= i18n('following the death of ') .
								given_names($spouses[0]) . ' ' .
								year({
									person => $spouses[0],
									record => $death_of_first_spouse,
								});
							$name .= i18n('following the death of ') .
								given_names($spouses[0]) . ' ' .
								year({
									person => $spouses[0],
									record => $death_of_first_spouse,
								});
						} elsif(my $divorce = $person->get_record('divorce') || $person->get_record('fams divorce')) {
							if(my $dateofdivorce = $divorce->date()) {
								if(datecmp($dateofmarriage, $dateofdivorce) > 0) {
									if($printed_bracket) {
										$name .= ', ';
									} else {
										$name .= '(';
										$printed_bracket = 1;
									}
									if($death_of_first_spouse =~ /\s$/) {
										complain({ person => $person, warning => 'Removing trailing spaces from date' });
										$dateofdivorce =~ s/\s+$//;
									}
									$name .= 'following ' .
										(($person->pronoun() eq 'She') ? 'her' : 'his') .
										' divorce ' .
										year({
											person => $person,
											record => $dateofdivorce
										});
								} else {
									complain({ person => $person, warning => "Divorced on $dateofdivorce after marriage on $dateofmarriage" });
								}
							}
						}
					}
					$bio .= ')' if($printed_bracket);
					$name .= ')' if($printed_bracket);
					push @names, $name;
					# $bio =~ s/&Atilde;&copy;/&eacute;/g;
					print $html wide_to_html({ string => $bio, keep_hrefs => 1 });
					# $bio =~ s/&eacute;/&#233;/g;
					# print $xml $bio;

					$fullbio .= $bio;
					undef $bio;
				}
				if(scalar(@names)) {
					$phrase->append(' (' . i18n('to ') . conjunction(@names) . ')');
					if($marriagecitation) {
						$phrase->append(cite(($marriagecitation)));
					}
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				# substr($names, rindex($names, ', '), 2, ' and ');
				if($marriagecitation) {
					$bio = cite(($marriagecitation));
				}

				# Determine if all the children are from one marriage, since that's
				# easier to print.
				# FIXME:  handle where offspring are from more than one marriage
				if($numberofchildren) {
					my %childrenbyspouse;
					my $childrenseen = 0;
					my $unknown;
					foreach my $family ($person->fams()) {
						if($family->number_of_children() &&
						   ($spouse = ($sex eq 'M') ? $family->wife() : $family->husband())) {
							foreach my $child($person->children()) {
								$unknown = $child;
								my $xref = $child->xref();
								foreach my $spouseschild($spouse->children()) {
									if($spouseschild->xref() eq $xref) {
										$childrenbyspouse{$spouse->xref()}++;
										$childrenseen++;
										$unknown = undef;
										last;
									}
								}
							}
						}
					}
					my $parentofall;
					if($childrenseen < $numberofchildren) {
						# Unable to find the parent of all of the children.  This
						# may be the case where someone married more than once,
						# and has a child by a 3rd unknown (or unfound) person
						if($opts{'w'}) {
							my $children_missing_parents = $numberofchildren - $childrenseen;
							my $warning_message = $children_missing_parents == 1
							? 'One of the parents of ' . ($unknown ? $unknown->as_string() : '1 child') . ' is not known'
							: "One of the parents of $children_missing_parents children is not known";

							complain({ person => $person, warning => $warning_message });
						}
					} else {
						foreach my $spouse(@spouses) {
							if($parentofall && $childrenbyspouse{$spouse->xref()}) {
								$parentofall = undef;
								last;
							}
							$parentofall = $spouse if $childrenbyspouse{$spouse->xref()};
						}
					}
					if($phrase->trim()->length() > 0) {
						push @phrases, $phrase;
					}

					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
					$phrase = Data::Text->new("$pronoun ");
					@phrases = ();

					$bio .= ". $pronoun " .
						($all_children_are_alive ? 'has ' : 'had ');
					$phrase->append($all_children_are_alive ? 'has ' : 'had ');
					if($numberofchildren == 1) {
						if($all_children_are_alive) {
							$bio .= '1 surviving child';
							$phrase->append('1 surviving child');
						} else {
							$bio .= '1 child';
							$phrase->append('1 child');
						}
						if($childrenseen >= $numberofchildren) {
							if($parentofall) {
								$bio .= i18n(' with ') . $parentofall->as_string();
								$phrase->append(i18n(' with ') . $parentofall->as_string());
							} else {
								if($opts{'f'}) {
									die $person->as_string(), ': BUG: parentofall not set when only one child';
								} else {
									red_warning({ person => $person, warning => 'BUG: parentofall not set when only one child' });
								}
							}
						} else {
							$bio .= ' with an unknown ' . i18n(($sex eq 'M') ? 'mother' : 'father');
							$phrase->append(' with an unknown ' . i18n(($sex eq 'M') ? 'mother' : 'father'));
						}
						# TODO: make hyperlink to the person's record, unless surviving
						if(my $given = given_names($children[0])) {
							$bio .= ", $given";
							$phrase->append(", $given");
						}
					} else {
						if($all_children_are_alive) {
							$bio .= "$numberofchildren surviving children";
							$phrase->append("$numberofchildren surviving children");
						} else {
							$bio .= "$numberofchildren children";
							$phrase->append("$numberofchildren children");
						}
						# FIXME: do hyperlinks - needs to be correct for $csv and $html
						if($parentofall) {
							my $format;
							if($numberofchildren == 2) {
								$bio .= ', ';
								$phrase->append(', ');
								$format = 'both with %s';
							} else {
								$format = ' with %s';
							}
							$bio .= i18n(person => $person, format => $format, args => $parentofall->as_string());
							$phrase->append(i18n(person => $person, format => $format, args => $parentofall->as_string()));
							# TODO: only add hyperlink to dead children
							# $childnames = join(', ', map {
								# '<a href="' . make_filename_from_person(person => $_) . '">' .
									# $_->given_names() . '</a>'
							# } @children);
							if(my $decoded = conjunction(map { given_names($_) } @children)) {
								if($language eq 'French') {
									$bio .= ' ';
									$phrase->append(' ');
								}
								$bio .= ": $decoded";
								$phrase->append(": $decoded");
							}
						} else {
							# List children by the same parent together
							# $childnames = join(', ', map {
								# my $father = $_->father();
								# '<a href="' . make_filename_from_person(person => $_) . '">' .
									# $_->given_names() . '</a>' .
								# ' (with ' .
								# '<a href="' . make_filename_from_person(person => $father) . '">' .
									# $father->given_names() . '</a>' .
								# ')'
							# } @children);
							my %childmap;
							my $surviving_children;
							if($sex eq 'M') {
								foreach my $child(@children) {
									if($opts{'l'} || (!is_alive(person => $child)) || (defined($me) && ($child->xref() eq $me->xref()))) {
										if(my $mother = $child->mother()) {
											push @{$childmap{given_names($mother)}}, $child;
										} else {
											push @{$childmap{'unknown mother'}}, $child;
										}
									} else {
										$surviving_children++;
									}
								}
							} else {
								foreach my $child(@children) {
									if($opts{'l'} || (!is_alive(person => $child)) || (defined($me) && ($child->xref() eq $me->xref()))) {
										if(my $father = $child->father()) {
											push @{$childmap{given_names($father)}}, $child;
										} else {
											push @{$childmap{'unknown father'}}, $child;
										}
									} else {
										$surviving_children++;
									}
								}
							}

							my @childnames;
							while(my ($key, $value) = each %childmap) {
								push @childnames,
									conjunction(map { given_names($_) || 'Unknown' } @{$value}) .
									i18n(' with ') .
									$key;
							}
							if(scalar(@childnames)) {
								Lingua::Conjunction->separator_phrase(';');
								Lingua::Conjunction->penultimate(1);
								$bio .= ': ' . conjunction(@childnames);
								$phrase->append(': ' . conjunction(@childnames));
								# TODO: restore old values
								Lingua::Conjunction->separator_phrase(',');
								Lingua::Conjunction->penultimate(0);
							}

							if(defined($surviving_children)) {
								if($surviving_children == 1) {
									$bio .= ', and one surviving child';
									$phrase->append(', and one surviving child');
								} elsif($surviving_children > 1) {
									$bio .= ", and $surviving_children surviving children";
									$phrase->append(", and $surviving_children surviving children");
								}
							}
						}
					}
				}
			}
			if(defined($bio) && ($bio =~ /\.$/)) {
				$end_of_sentence = 1;
			} else {
				$end_of_sentence = 0;
			}
		} elsif($numberofchildren) {
			# Neither date nor place of marriage is known
			if($end_of_sentence) {
				$bio .= " $pronoun ";
			} elsif(scalar(@residences) == 0) {
				$bio .= i18n(' and');
			}
			if(scalar(@phrases) == 0) {
				$phrase->append(" $pronoun ");
			} elsif($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
			if(is_alive(person => $person)) {
				$bio .= 'has';
				$phrase->append('has ');
			}
			$bio .= i18n('had ');
			$phrase->append(i18n('had '));
			if($language eq 'French') {
				$bio .= (($numberofchildren == 1) ? '1 enfant' : "$numberofchildren enfants");
				$phrase->append((($numberofchildren == 1) ? '1 enfant' : "$numberofchildren enfants"));
			} else {
				$bio .= (($numberofchildren == 1) ? '1 child' : "$numberofchildren children");
				$phrase->append((($numberofchildren == 1) ? '1 child' : "$numberofchildren children"));
			}
			if($numberofchildren == 1) {
				if(my $first_name = given_names($children[0])) {
					$bio .= ", $first_name";
					$phrase->append(", $first_name");
				}
			} else {
				# my $childnames = join(', ', map { $_->given_names() } @children);
				# substr($childnames, rindex($childnames, ', '), 2, ' and ');
				# $bio .= ", $childnames";
				my $all_children_have_names = 1;
				foreach my $child(@children) {
					if(length(given_names($child)) == 0) {
						$all_children_have_names = 0;
						last;
					}
				}
				if($all_children_have_names) {
					$bio .= ', ' . conjunction(map { given_names($_) } @children);
					$phrase->append(', ' . conjunction(map { given_names($_) } @children));
				}
			}
			$end_of_sentence = 0;
		}
	}

	my $birth_country;

	if($placeofbirth && ($placeofbirth =~ /(.+[a-z]) USA$/i)) {
		complain({ person => $person, warning => "Comma missing before USA in birth location '$placeofbirth'" });
		$placeofbirth = "$1, USA";
		$birth_country = 'United States';
	} elsif($placeofbirth && ($placeofbirth !~ /^\s+,\s+$/) && ($placeofbirth =~ /.+,\s?(.+)$/)) {
		my $c = $1;

		if($c =~ /\s+$/) {
			complain({ person => $person, warning => "Removing trailing spaces from place of birth '$c'" });
			$c =~ s/\s+$//;
		}
		if($c =~ /\)$/) {
			complain({ person => $person, warning => 'Trailing bracket in birth location' });
			$c =~ s/\)$//;
		}

		if(length($c) > 3) {
			$c = sortoutcase($c);
		}

		if($c eq 'England') {
			$birth_country = 'United Kingdom';
		} elsif(uc($c) eq 'USA') {
			$birth_country = 'United States';
		} elsif($c eq 'United States Of America') {
			$birth_country = 'United States';
		} elsif($c eq 'U.S.A.') {
			$birth_country = 'United States';
		} elsif($c eq 'Scotland') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Isle of Man') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			$birth_country = 'United Kingdom';
		} elsif(($c eq 'PreuÃen') || ($c eq 'Deutschland')) {	# Prussia
			$birth_country = 'Germany';
		} elsif(($c eq 'Holland') || ($c eq 'The Netherlands')) {
			$birth_country = 'Netherlands';
		} elsif($c eq 'NL') {
			$birth_country = 'Netherlands';
			complain({ person => $person, warning => 'Assuming country of birth is Netherlands' });
		} elsif(($c =~ /[A-Z]{2}/i) && ($us->{code2state}{uc($c)})) {
			complain({ person => $person, warning => "$c: assuming country of birth is USA" });
			$birth_country = 'United States';
			$placeofbirth .= ', USA';
		} elsif($us->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is USA" });
			$birth_country = 'United States';
			$placeofbirth .= ', USA';
		} elsif(($c =~ /[A-Z]{2}/) && ($ca_en->{code2province}{$c}) || $ca_fr->{code2province}{$c}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Canada" });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif($ca_en->{province2code}{uc($c)} || $ca_fr->{province2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Canada" });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif(($c =~ /[A-Z]{2,3}/) && ($au->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of birth is Australia" });
			$birth_country = 'Australia';
			$placeofbirth .= ', Australia';
		} elsif($au->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of birth is Australia" });
			$birth_country = 'Australia';
			$placeofbirth .= ', Australia';
		} elsif(uc($c) eq 'NFLD') {
			complain({ person => $person, warning => 'Assuming country of birth is Canada' });
			$birth_country = 'Canada';
			$placeofbirth .= ', Canada';
		} elsif(($c eq 'Norfolk') || ($c eq 'Kent') || ($c eq 'Sussex') || ($c eq 'Northumberland') || ($c eq 'London') || ($c eq 'Lancashire')) {
			$birth_country = 'United Kingdom';
			complain({ person => $person, warning => 'Assuming country of birth is UK' });
		} elsif($c =~ 'England,?\sUK') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Scot') {
			complain({ person => $person, warning => "$c: birth country should be Scotland'" });
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Slovenija') {
			$birth_country = 'Slovenia';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			$birth_country = $b->name();
		} elsif(my $user = $ENV{'GEONAMES_USER'}) {
			$geonames //= Geo::GeoNames->new(username => $user);
			$geonames->ua($cached_browser);
			my $result = $geonames->search(q => $placeofbirth, style => 'FULL');
			$result = @{$result}[0];
			if($birth_country = $result->{'countryName'}) {
				complain({ person => $person, warning => "$c: Assuming country of birth is $birth_country" });
			} else {
				complain({ person => $person, warning => "Unknown birth country: '$c' in '$placeofbirth'" });
			}
		} else {
			complain({ person => $person, warning => "Unknown birth country: '$c' in '$placeofbirth'" });
		}
	}

	my $death_country;

	if($placeofdeath && ($placeofdeath =~ /(.+[a-z]) USA$/)) {
		complain({ person => $person, warning => "Comma missing before USA in death location '$placeofdeath'" });
		$placeofdeath = "$1, USA";
		$death_country = 'United States';
	} elsif($placeofdeath && ($placeofdeath =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'England') {
			$death_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			$death_country = 'United States';
		# } elsif($c eq 'Texas') {
			$death_country = 'United States';
		} elsif(($c =~ /[A-Z]{2}/i) && ($us->{code2state}{uc($c)})) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			$death_country = 'United States';
		} elsif($us->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			$death_country = 'United States';
		} elsif($c eq 'United States of America') {
			$death_country = 'United States';
		} elsif($c eq 'U.S.A.') {
			$death_country = 'United States';
		} elsif($c eq 'Scotland') {
			$death_country = 'United Kingdom';
		} elsif($c eq 'Scot') {
			complain({ person => $person, warning => "$c: death country should be Scotland'" });
			$death_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			$death_country = 'United Kingdom';
		} elsif(($c eq 'Norfolk') || ($c eq 'Kent') || ($c eq 'Sussex') || ($c eq 'Northumberland')) {
			$death_country = 'United Kingdom';
			complain({ person => $person, warning => 'Assuming country of death is UK' });
		} elsif(($c eq 'Nova Scotia') || (uc($c) eq 'NFLD') || ($c eq 'Newfoundland') || ($c eq 'NS')) {
			complain({ person => $person, warning => "Country 'Canada' missing from death record" });
			$death_country = 'Canada';
		} elsif(($c =~ /[A-Z]{2,3}/) && ($au->{code2state}{$c})) {
			complain({ person => $person, warning => "$c: assuming country of death is Australia" });
			# $death_country = 'Australia';
		} elsif($au->{state2code}{uc($c)}) {
			complain({ person => $person, warning => "$c: assuming country of death is Australia" });
			# $death_country = 'Australia';
		} elsif(($c eq 'Holland') || ($c eq 'The Netherlands')) {
			$death_country = 'Netherlands';
		} elsif($c eq 'Isle of Man') {
			$death_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			$death_country = 'United Kingdom';
		} elsif(($c eq 'PreuÃen') || ($c eq 'Deutschland')) {	# Prussia
			$death_country = 'Germany';
		} elsif($c =~ /Can\./) {
			complain({ person => $person, warning => 'Assuming country of death is Canada' });
			$death_country = 'Canada';
		} elsif(($c =~ /[A-Z]{2} USA/) && ($us->{code2state}{substr($c, 0, 2)})) {
			complain({ person => $person, warning => "$c: assuming country of death is USA" });
			$death_country = 'United States';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			# Country is found
			$death_country = $b->name();
		} elsif(my $user = $ENV{'GEONAMES_USER'}) {
			$geonames //= Geo::GeoNames->new(username => $user);
			$geonames->ua($cached_browser);
			my $result = $geonames->search(q => $placeofdeath, style => 'FULL');
			$result = @{$result}[0];
			if($death_country = $result->{'countryName'}) {
				complain({ person => $person, warning => "$c: Assuming country of death is $death_country" });
			} else {
				complain({ person => $person, warning => "Unknown death country: '$c' in '$placeofdeath'" });
			}
		} else {
			complain({ person => $person, warning => "Unknown death country: '$c' in '$placeofdeath'" });
		}
	}

	if($opts{'w'} && defined($death_country) && ($death_country eq 'Canada') && defined($yod) && ($yod < 1500)) {
		complain ({ person => $person, warning => "Canada did not exist in $yod, check place of death ($placeofdeath)" });
		$placeofdeath = undef;
		undef $death_country;
	}

	my $military_location;

	if((scalar(@residences) == 1) && (scalar(@events) == 1) &&
	   $residences[0]->date() && ref($events[0]) && $events[0]->date() &&
	   (year(string => $residences[0]->date()) eq year(string => $events[0]->date())) &&
	   (($events[0]->type() eq 'Military service') || ($events[0]->type() eq 'Military'))) {
		# There's just one residence and one event which is military, and they are at the same time
		# so put them together: "in 1970 he was living in London when he was serving in the military"
		$military_location = 1;
	}

	my $printed_residence = 0;
	my %citationnotes;
	my @note_locations;
	my @residencelist;
	my $diedathome;
	my $living_alone = 1;

	if($opts{'l'} || !$is_alive) {
		if(scalar(@childrenunknownparent)) {
			$bio .= '. ' if(!$end_of_sentence);
			$bio .= "$pronoun ";

			push @phrases, $phrase;
			$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
			$phrase = Data::Text->new("$pronoun ");
			@phrases = ();

			if(scalar(@children) > scalar(@childrenunknownparent)) {
				$bio .= i18n('also ');
				$phrase->append(i18n('also '));
			}
			$bio .= i18n('had ') . scalar(@childrenunknownparent) . ' ';
			$phrase->append(i18n('had ') . scalar(@childrenunknownparent) . ' ');
			if(scalar(@childrenunknownparent) == 1) {
				$bio .= i18n('child, ');
				$phrase->append(i18n('child, '));
			} else {
				$bio .= i18n('children, ');
				$phrase->append(i18n('children, '));
			}
			$bio .= conjunction(map { given_names($_) || ($_->sex() eq 'F' ? 'a daughter' : 'a son') } @childrenunknownparent) .
				', whose ' .
				(($sex eq 'F') ? 'father' : 'mother') .
				' is unknown';
			$phrase->append(conjunction(map { given_names($_) || ($_->sex() eq 'F' ? 'a daughter' : 'a son') } @childrenunknownparent) .
				', whose ' .
				(($sex eq 'F') ? 'father' : 'mother') .
				' is unknown');
			$end_of_sentence = 0;
		}

		if($same_occupation_as_father) {
			$bio .= '.' if(!$end_of_sentence);

			if($phrase->length()) {
				push @phrases, $phrase;
			}
			if(scalar(@phrases)) {
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				$phrase = Data::Text->new();
				@phrases = ();
			}

			if($language eq 'French') {
				$bio .= " Comme son p\N{U+00E8}re, " . lcfirst($pronoun) .
					(is_alive(person => $person) ? ' est' : " \N{U+00E9}tait") . ' un';
				$phrase->set(" Comme son p\N{U+00E8}re, " . lcfirst($pronoun) .
					(is_alive(person => $person) ? ' est' : " \N{U+00E9}tait") . ' un');
				if($same_occupation_as_father =~ /^[AEIOU]/) {
					$bio .= 'e';
					$phrase->append('e');
				}
				$bio .= ' ' . lc($same_occupation_as_father);
				$phrase->append(' ' . lc($same_occupation_as_father));
			} else {
				$bio .= ' Like ' . lcfirst($person->possessive()) . ' father, ' . lcfirst($pronoun) .
					i18n((is_alive(person => $person) ? ' is' : ' was'));
				$phrase->set(' Like ' . lcfirst($person->possessive()) . ' father, ' . lcfirst($pronoun) .
					i18n((is_alive(person => $person) ? ' is' : ' was')));
				$bio .= ' ' . Lingua::EN::Inflect::A(lc($same_occupation_as_father));
				$phrase->append(' ' . Lingua::EN::Inflect::A(lc($same_occupation_as_father)));
			}
			$bio .= '. ';
			$end_of_sentence = 1;

			push @phrases, $phrase;
			$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
			$phrase = Data::Text->new();
			@phrases = ();
		}

		print "Handling residences\n" if($opts{'v'});
		# FMP stores Censuses as events
		if($opts{'w'}) {
			my $index = 0;
			foreach my $event(@events) {
				$index++;
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN', $index);
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					} else {
						red_warning({ person => $person, warning => "Event record is just description ($event), information has been lost" });
					}
				}
				if($event->can('type') || $event->isa('Class::Simple::Readonly::Cached')) {
					my $type = $event->type();
					if(!defined($type)) {
						red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
						next;
					}

					# if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939')) {
					if(($type =~ /Census/) || ($type eq 'Register UK 1939')) {
						if(!$dateofbirth) {
							complain({ person => $person, warning => 'Census information not used to approximate a date of birth' });
						}
					}
				}
			}
		}

		my @all_residences = get_all_residences($person);
		if(scalar(@all_residences)) {
			print scalar(@all_residences), " residences found\n" if($opts{'v'});
			# FIXME: handle duplicate locations better
			my %residencecitations;

			# This is an attempt to handle
			# https://github.com/pjcj/Gedcom.pm/issues/13
			my $index = 0;
			foreach my $residence(@all_residences) {
				$index++;
				if(!ref($residence)) {
					my $r = $person->tag_record('EVEN', $index);
					if(ref($r) eq 'Gedcom::Record') {
						$residence = $r;
					} else {
						$r = $person->record(['residence', $index]);
						if(ref($r) eq 'Gedcom::Record') {
							$residence = $r;
						} else {
							red_warning({ person => $person, warning => "Residence record is just description ($residence), information has been lost" });
						}
					}
				}
				if($residence->can('place') || $residence->isa('Class::Simple::Readonly::Cached')) {
					my $place = $residence->place();
					if(my $address = $residence->address()) {
						if($address->isa('Gedcom::Record')) {
							$place = getaddress($address);
						} elsif($place) {
							$place = "$address, $place";
						} elsif($opts{'f'}) {
							die $person->string(), ": address set to $address but place is empty";
						} else {
							red_warning({
								person => $person,
								warning => "Address set to $address but place is empty"
							});
						}
					}
					if(defined($place)) {
						if(my $dor = $residence->date()) {
							if($placeofbirth && $dateofbirth && ($dor eq $dateofbirth)) {
								next;
							}
							if($placeofmarriage && $dateofmarriage && ($dor eq $dateofmarriage)) {
								next;
							}
						}
						push @residencelist, $residence;
						if($opts{'c'}) {
							if(my $src = $residence->source()) {
								$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
								my $note = notes(record => $residence, note_locations => \@note_locations);
								foreach my $c(@birthcitations) {
									if($src eq $citations{$c}) {
										$residencecitations{$residence} = $c;
										if($note) {
											$citationnotes{$c} = $note;
										}
										last;
									}
								}
								unless($residencecitations{$residence}) {
									if($deathcitations[0] && ($src eq $citations{$deathcitations[0]})) {
										$residencecitations{$residence} = $deathcitations[0];
										if($note) {
											$citationnotes{$deathcitations[0]} = $note;
										}
									} else {
										$residencecitations{$residence} = ++$citationcount;
										$citations{$citationcount} = $src;
										if($note) {
											$citationnotes{$citationcount} = $note;
										}
									}
								}
							} elsif(my $dor = $residence->date()) {
								red_warning({ person => $person, warning => "Residence record for $dor contains no citation" });
							}
						}
					} elsif(my $dor = $residence->date()) {
						if(my $type = $residence->type()) {
							if(($type ne 'Military service') &&
							   ($type ne 'Story')) {
								red_warning({ person => $person, warning => "Residence record for $dor contains no location" });
							}
						} else {
							red_warning({ person => $person, warning => 'Residence record contains no type' });
						}
					} else {
						red_warning({ person => $person, warning => 'Residence record contains no date or place' });
					}
				}
			}

			if(scalar(@residencelist) == 2) {
				print "Check if the residences are the same\n" if($opts{'v'});
				my $date1 = $residencelist[0]->date();
				my $date2 = $residencelist[1]->date();

				if($date1 && $date2 && ($date1 eq $date2)) {
					if(places_are_the_same({ person => $person, first => $residencelist[0], second => $residencelist[1] })) {
						complain({ person => $person, warning => "Duplicate residence on $date1" });
						@residencelist = ($residencelist[0]);
					}
				}
			}

			# TODO: See RT110333

			# Sort residences chronologically
			# FIXME: This messes citations
			my $all_residences_have_date = 1;
			foreach my $residence(@residencelist) {
				my $date = $residence->date();
				if(!$date) {
					complain({ person => $person, warning => 'Contains a residence' . place(record => $residence) . ' without a date' });
					$all_residences_have_date = 0;
					last;
				}
				$date = $date_parser->parse(date => $date);
				if(!defined($date)) {
					complain({ person => $person, warning => "Can't parse date '$date'" });
					$all_residences_have_date = 0;
					last;
				}
				if(scalar(@{$date}) == 0) {
					# e.g. "Apr/May/Jun 2016"
					$all_residences_have_date = 0;
					last;
				}
			}
			if($all_residences_have_date && (scalar(@residencelist) > 1)) {
				print "Sort the residences\n" if($opts{'v'});
				# @residencelist = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @residencelist;
				@residencelist = sort { datecmp($a, $b) } @residencelist;
			}

			my $count = 0;
			my $prev_residence;
			my $spdeath_dt;
			if($spouses[0] && ($spdeath_dt = dateofdeath($spouses[0]))) {
				$spdeath_dt = date_to_datetime(date => $spdeath_dt);
			}
			# my $yod;
			# my $dod = dateofdeath($person);
			# if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				# $yod = $1;
			# }
			my $print_year_only;	# used when printing a range, e.g. 1871-1891
			my %printed_dates;

			print "Sanity checking the residences\n" if($opts{'v'});

			# Create a list of residence strings
			my @residencestringarray;
			my $printed_father_same_place;
			my $printed_mother_same_place;

			my $iterator = Array::Iterator->new({ __array__ => \@residencelist });
			while(my $residence = $iterator->get_next()) {
				my $rdate = $residence->date();
				my $residencestring;
				my %living_with;
				my $latitude;
				my $longitude;

				print __LINE__, ": count = $count\n" if($opts{'v'});

				if(defined($rdate)) {
					if($rdate =~ /^0/) {
						complain({ person => $person, warning => "Removing leading 0 from residence date '$rdate'" });
						# FIXME: Don't do this - it won't print this residence if you do
						# $rdate =~ s/^0//;
					}
					if($rdate =~ /^\s*(.+\d\d)\s*\-\s*(.+\d\d)\s*$/) {
						my $start = $1;
						my $end = $2;
						if($end !~ /^\d\d\-\d\d$/) {
							complain({ person => $person, warning => "Changing date '$rdate' to 'bet $start and $end'" });
							$rdate = "bet $start and $end";
						}
					}
				}

				if(($count == 0) || !places_are_the_same({ person => $person, first => $residence, second => $residencelist[$count - 1] })) {
					if($birth && $dateofbirth && $rdate && ($rdate !~ /^\d{3,4}$/) && (datecmp($rdate, $dateofbirth) == 0) &&
					   places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						# This residence record is for the place of birth, which is
						# printed elsewhere
						$count++;
						next;
					}
					if($birth && places_are_the_same({ person => $person, first => $birth, second => $residence })) {
						$residencestring = i18n(' at ');
						if($language eq 'French') {
							$residencestring .= 'sa';
						} else {
							$residencestring .= ($person->pronoun() eq 'She') ? 'her' : 'his';
						}
						$residencestring .= i18n(' birthplace');
					} elsif(my $p = place({ person => $person, record => $residence, places_printed => \%places_printed })) {
						if($residence->type() && ($residence->type() eq 'Hospitalisation')) {
							$residencestring = ' in hospital';
						}

						if((!defined($prev_residence)) ||
						   !places_are_the_same({ person => $person, first => $prev_residence, second => $residence })) {
							# Actually prints the place here
							$residencestring .= $p;
							$places_printed{$p} = 1;
							$p = place({
								person => $person,
								record => $residence,
								nopreposition => 1,
							});
							if(my $location = get_location($p)) {
								$latitude = $location->lat();
								$longitude = $location->long();
							}
						}
					}
					if($rdate && (my $rdate_dt = date_to_datetime($rdate))) {
						my $year = $rdate_dt->year();
						$year =~ s/^0+//;	# Strip leading zeros
						my $strftime = $rdate_dt->strftime('%x');
						if(my $place = place({ person => $person, record => $residence, nopreposition => 1 })) {
							if(my $location = get_location($place)) {
								push @{$all_locations{$year}}, {
									'record' => $residence,
									'person' => $person,
									'date' => $strftime,
									'latitude' => $location->lat(),
									'longitude' => $location->long(),
									'location' => $location
								}
							}
						}
						if($opts{'w'} && $marriage_dt && ($rdate_dt > $marriage_dt)) {
							if(!defined($spouses[0])) {
								complain({ person => $person, warning => 'Has a date of marriage but no spouse' });
							} else {
								# Check this person was living at the same place as their spouse.
								# TODO: Also check all children under 10
								foreach my $l(@{$all_locations{$year}}) {
									if(($l->{'person'}->xref() eq $spouses[0]->xref()) &&
									   (datecmp($l->{'date'}, $strftime) == 0)) {
										my $r1 = place(record => $residence, nopreposition => 1);
										my $r2 = place(record => $l->{'record'}, nopreposition => 1);
										if($r1 ne $r2) {
											$r1 =~ s/^\s+//;
											$r2 =~ s/^\s+//;
											complain({
												person => $person,
												warning => [
													"$strftime: not living at same address as spouse ",
													$spouses[0]->as_string(),
													" ('$r1'/'$r2')"
												]
											});
										}
									}
								}
							}
						}
					}
				}
				if($rdate) {
					next if($printed_dates{$rdate});
					$printed_dates{$rdate}++;
					if($rdate =~ /(\d{3,4})$/) {
						if($opts{'w'}) {
							my $yoe = $1;
							if($yod) {
								if($yoe > $yod) {
									complain({
										person => $person,
										warning => "Year of residence $yoe is after the year of death $yod"
									});
								} elsif($death_dt && (my $rdate_dt = date_to_datetime($rdate))) {
									# FIXME: If $rdate is a date range, should check both dates in the range
									if($rdate_dt > $death_dt) {
										complain({
											person => $person,
											warning => "Date of residence $rdate is after date of death " . $death_dt->strftime('%x')
										});
									}
								}
							}
							# Check if spouse listed at all residences when we only know the year
							if($spouses[0]) {
								my $spyod = dateofdeath($spouses[0]) || ($yoe + 1);
								if($spyod =~ /(\d{3,4})$/) {
									$spyod = $1;
								}
								if(defined($dateofmarriage) &&
								   ($dateofmarriage =~ /(\d{3,4})$/) &&
								   (my $spouse = $spouses[0]) &&
								   ($yoe < $spyod)) {
									my $yom = $1;
									if($yom < $yoe) {
										my $found_spouse;
										foreach my $residence(get_all_residences($spouse)) {
											my $date = $residence->date();
											if(defined($date) && ($date =~ /(\d{3,4})$/)) {
												if($1 == $yoe) {
													$found_spouse = $residence;
													last;
												}
											}
										}
										if(!$found_spouse) {
											complain({ person => $person, warning => ["Listed in the residence for $rdate, but spouse ", $spouse->as_string(), ' is not'] });
										}
									}
								}
							}
							if($yob && (($yoe - $yob) <= 12)) {
								my $found_parent = 0;
								if($mother) {
									foreach my $m_residence(get_all_residences($mother)) {
										my $date = $m_residence->date();
										if(defined($date) && ($date =~ /(\d{3,4})$/)) {
											if($1 == $yoe) {
												$found_parent = $m_residence;
												my $p1 = place({
														person => $mother,
														record => $m_residence,
														nopreposition => 1
													});
												my $p2 = place({
														person => $person,
														record => $residence,
														nopreposition => 1
													});
												if($p1 ne $p2) {
													$p1 =~ s/^\s+//;
													$p2 =~ s/^\s+//;
													complain({ person => $person, warning => "Location for $date ($p2) differs from mother's ($p1)" });
												}
												if(datecmp($date, $rdate) != 0) {
													complain({ person => $person, warning => "Date of residence ($rdate) differs from mother's in same year ($date)" });
												}
												last;
											}
										}
									}
								}
								if($father && !$found_parent) {
									foreach my $f_residence(get_all_residences($father)) {
										my $date = $f_residence->date();
										if(defined($date) && ($date =~ /(\d{3,4})$/)) {
											if($1 == $yoe) {
												$found_parent = $f_residence;
												my $p1 = place({
														person => $father,
														record => $f_residence,
														nopreposition => 1
													});
												my $p2 = place({
														person => $person,
														record => $residence,
														nopreposition => 1
													});
												if($p1 ne $p2) {
													$p1 =~ s/^\s+//;
													$p2 =~ s/^\s+//;
													complain({ person => $person, warning => "Location for $date ($p2) differs from father's ($p1)" });
												}
												if($date ne $rdate) {
													complain({ person => $person, warning => "Date of residence ($rdate) differs from father's in same year ($date)" });
												}
												last;
											}
										}
									}
								}
								if((!$mother) && !$father) {
									# People not related by blood tend not to have been researched
									if($relationship) {
										complain({ person => $person, warning => 'Census information not used to determine a parent' });
									}
								}	# TODO: else warn if both parents locations are different
							} elsif($numberofchildren && ($rdate !~ /^bet\s/i) && ($rdate !~ /\d{4}, \d{4}/)) {
								# Look if a young child isn't with this parent
								foreach my $child(@children) {
									my $cyob = dateofbirth($child);
									next if(!defined($cyob));
									next if($cyob !~ /\d$/);	# Probably missing year e.g. "14 Jul"
									if($cyob =~ /(\d{3,4})\s*$/) {
										$cyob = $1;
									} else {
										# Probably missing year e.g. "14 Jul"
										next;
									}
									if($rdate !~ /^Bef/i) {
										next if(datecmp($cyob, $rdate) >= 0);	# Child was not born yet
									}
									next if(($yoe - $cyob) > 10);	# Over 10 years old
									if(my $cyod = dateofdeath($child)) {
										next if(datecmp($cyod, $rdate) <= 0);	# Child was dead by this event
									}

									if(!person_in_residence_record({ person => $child, date => $rdate })) {
										if($firstname) {
											complain({ person => $child, warning => "Parent $firstname is listed in the residence for $rdate, but this child is not" });
										} else {
											complain({ person => $child, warning => "Parent is listed in the residence for $rdate, but this child is not" });
										}
									}
								}
							}
						}
					}
					if(scalar(@residencelist) > 1) {
						# Add the dates to this residence place, as in "lived in this place on these dates"
						if($rdate =~ /\s$/) {
							complain({ person => $person, warning => "Removing trailing spaces from '$rdate'" });
							$rdate =~ s/\s+$//;
						}
						my $this_date = year({ person => $person, date => $rdate });
						if($prev_residence && (year(record => $prev_residence) eq $this_date)) {
							if(!places_are_the_same({ person => $person, first => $prev_residence, second => $residence })) {
								complain({ person => $person, warning => "Two residence records for $rdate differ in location" });
							}
						} else {
							if($print_year_only) {
								if($count == (scalar(@residencelist) - 1)) {
									$residencestring .= $rdate;
									# $print_year_only = 0;
								}
							} elsif((!defined($residencestring)) && (my $p = pop(@residencestringarray))) {
								if($language eq 'French') {
									$p =~ s/ et /, /g;
								} else {
									$p =~ s/ and /, /g;
								}
								$residencestring = conjunction($p, $this_date);
								# We could just added a comma after a sibling's name
								$residencestring =~ s/,,/,/g;
							} else {
								$residencestring .= " $this_date";
							}
							$prev_residence = $residence;
						}
					}
				}
				if($opts{'c'}) {
					my @citationlist;
					if($residencecitations{$residence}) {
						push @citationlist, $residencecitations{$residence};
					}
					if($residence->place() &&
					  (!$rdate) &&
					  ($count <= (scalar(@residencelist) - 1)) &&
					  ($residencecitations{$residence})) {
						my $peek = $iterator->peek();
						if($peek &&
						   places_are_the_same({ person => $person, first => $residence, second => $peek }) &&
						   $residencecitations{$peek}) {
							push @citationlist, $residencecitations{$peek};
						}
					}
					if(scalar(@citationlist)) {
						if(!defined($residencestring) && (my $p = place({ person => $person, record => $residence, places_printed => \%places_printed }))) {
							$residencestring = $p;
						} else {
							$residencestring =~ s/,$//;
						}
						$residencestring .= cite(@citationlist);
					}
				} elsif($residence->source() && (my $notes = notes({ record => $residence, note_locations => \@note_locations }))) {
					$notes =~ s/\.$//;
					$notes = lcfirst($notes);
					$residencestring .= " ($notes)";
				}
				$count++;
				if(($count == 1) && (scalar(@residencelist) == 2)) {
					if($print_year_only) {
						$residencestring .= $rdate;
						$print_year_only = 0;
					}
				} else {
					my $peek = $iterator->peek();
					if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
						my $nextnotes = notes(record => $peek);
						$peek = $iterator->peek(2);
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							# FIXME: work with citations by printing them all
							if((!$opts{'c'}) && $rdate && ($rdate =~ /^\d{4}$/) && $peek->date() && ($peek->date() =~ /^\d{4}$/)) {
								if((!$print_year_only) && (!defined($nextnotes)) && !notes(record => $peek)) {
									$residencestring .= '-';
									$print_year_only = 1;
								}
							} elsif($print_year_only && $rdate) {
								$residencestring .= $rdate;
								$print_year_only = 0;
							}
						}
					} elsif($print_year_only) {
						$residencestring .= $rdate if((!defined($residencestring)) || ($rdate ne $residencestring));
						$print_year_only = 0;
					}
				}
				if($rdate) {	# residence has a date?
					my $age;
					if($birth_dt) {
						$age = $dfn->parse_datetime($rdate) - $birth_dt;
						$age = $age->in_units('years');
					} elsif(defined($yob)) {
						$age = get_year_from_date($rdate) - $yob;
					}
					# Find if they are an adult living with an adult sibling or in-law
					# if($all_residences_have_date && $birth_dt) {
					if($all_residences_have_date && defined($age)) {
						next if($residence->date() ne $rdate);

						my $place = place({ person => $person, record => $residence, nopreposition => 1 });
						next if(!defined($place));
						my $first = 1;
						my $printed_sibling = 0;

						if($age >= 35) {
							# Safe to assume both are adults at this time
							foreach my $sibling(@siblings) {
								if(my $ss = $sibling->spouse()) {
									# If they are living with an in-law, assume both are adults
									$ss = Class::Simple::Readonly::Cached->new({ object => $ss, cache => {}, quiet => 1 });
									my @ssr = get_all_residences(person => $ss);
									foreach my $ssr(@ssr) {
										if(my $d = $ssr->date()) {
											next if($d ne $rdate);

											# Compare only if full addresses to prevent
											# false positives when only a city is known
											if(($place =~ /^\s\d/ && (my $ssp = place({ person => $ss, record => $ssr, nopreposition => 1 })))) {
												if($ssp eq $place) {
													if($ss->sex() eq 'F') {
														$living_with{'sister-in-law'} = $ss
													} else {
														$living_with{'brother-in-law'} = $ss
													}
													$printed_sibling = 1;
													last;
												}
											}
										}
									}
								}
								my @sr = get_all_residences(person => $sibling);
								foreach my $sr(@sr) {
									my $sdate = $sr->date();
									next if(!defined($sdate));
									next if($sdate ne $rdate);
									if(($place =~ /^\s\d/) && (place({ person => $sibling, record => $sr, nopreposition => 1 }) eq $place)) {
										push @{$living_with{'sibling'}}, $sibling;
										last;
									}
								}
							}
						}

						# if(($bdiff->in_units('years') >= 30) || ($bdiff->in_units('years') < 16)) {
						if(1) {
							my $with_mother;
							my $same_road_as_mother = 0;
							my $address = $residence->address();
							my $road = $address;

							$rdate =~ s/^0//;	# FIXME: this should have been done earlier - see earlier FIXME
							if($road) {
								if($road =~ /,\s*(.+)/) {
									$road = $1;
								}
								if($road =~ /^\d*\s(.+)/) {
									$road = $1;
								}
							}
							my $mother_date;
							if($mother) {
								my @mr = get_all_residences(person => $mother);
								foreach my $mr(@mr) {
									my $mdate = $mr->date();
									next if(!defined($mdate));

									my $p = place({ person => $mother, record => $mr, nopreposition => 1 });
									next unless($p);

									if((datecmp($rdate, $mdate) == 0) && $road && ($mr->place() eq $residence->place())) {
										if($p eq $place) {
											$living_with{'mother'} = $mother;
											$with_mother++;
											$living_alone = 0;
											last;
										} elsif(my $mroad = $mr->address()) {
											if($mroad eq $address) {
												$living_with{'mother'} = $mother;
											}
											if($mroad =~ /,\s*(.+)/) {
												$mroad = $1;
											}
											if($mroad =~ /^\d*\s(.+)/) {
												$mroad = $1;
											}
											if($mroad eq $road) {
												$same_road_as_mother = $rdate;
											}
										}
									} elsif($p eq $place) {
										# if(($p =~ /^\s\d/) && ($p eq $place)) {
										if(datecmp($mdate, $rdate) == 0) {
											$with_mother++;
											$living_alone = 0;
											last;
										} elsif(!$printed_mother_same_place) {
											$mother_date = $mdate;
										}
									}
								}
								if($with_mother && !$living_with{'mother'}) {
									complain({ person => $person, warning => "May have been living with mother on $rdate, but the addresses don't match or aren't detailed enough to be sure" });
								}
							}
							my $with_father;
							my $same_road_as_father = 0;
							my $father_date;
							if($father) {
								my @fr = get_all_residences(person => $father);
								foreach my $fr(@fr) {
									my $fdate = $fr->date();
									next if(!defined($fdate));

									my $p = place({ person => $father, record => $fr, nopreposition => 1 });
									next unless($p);

									if((datecmp($rdate, $fdate) == 0) && $road && ($fr->place() eq $residence->place())) {
										if($p eq $place) {
											$living_with{'father'} = $father;
											$with_father++;
											$living_alone = 0;
											last;
										} elsif(my $froad = $fr->address()) {
											if($froad eq $address) {
												$living_with{'father'} = $father;
											}
											if($froad =~ /,\s*(.+)/) {
												$froad = $1;
											}
											if($froad =~ /^\d*\s(.+)/) {
												$froad = $1;
											}
											if($froad eq $road) {
												$same_road_as_father = $rdate;
											}
										}
									} elsif($p eq $place) {
										# if(($p =~ /^\s\d/) && ($p eq $place)) {
										if(datecmp($fdate, $rdate) == 0) {
											$with_father++;
											$living_alone = 0;
											last;
										} elsif(!$printed_father_same_place) {
											$father_date = $fdate;
										}
									}
								}
								if($with_father && !$living_with{'father'}) {
									complain({ person => $person, warning => "May have been living with father on $rdate, but the addresses don't match or aren't detailed enough to be sure" });
								}
							}
							if($living_with{'mother'} || $living_with{'father'}) {
								if($age >= 30) {
									$residencestring .= ' ';
									if($first) {
										$residencestring .= '(' .
											i18n('when ') .
											i18n(($sex eq 'M') ? 'he' : 'she') . i18n(' was living');
									}
									if($language eq 'French') {
										$residencestring =~ s/lorsque elle/lorsqu'elle/;
									}
									if($first) {
										if($language eq 'French') {
											$residencestring .= ($printed_sibling ? ' et ' : ' avec ');
											if($with_mother && $with_father) {
												$residencestring .= 'ses';
											} elsif($with_mother) {
												$residencestring .= 'sa';
											} else {
												$residencestring .= 'son';
											}
										} else {
											$residencestring .= i18n($printed_sibling ? ' and ' : ' with ') .
												($sex eq 'M' ? 'his' : 'her');
										}
									} else {
										$residencestring =~ s/,\s*$//;
										$residencestring .= i18n(' and');
									}
									$printed_sibling = 1;

									if($with_mother && $with_father) {
										$residencestring .= i18n(' parents');
									} elsif($with_mother) {
										$residencestring .= i18n(' mother, ') . given_names($mother);
									} elsif($with_father) {
										$residencestring .= i18n(' father, ') . given_names($father);
									} else {
										$Data::Dumper::Maxdepth = 2;
										print STDERR __LINE__, ': ', Data::Dumper->new([\%living_with])->Dump();
										die "BUG: living_with set, but can't determine with whom";
									}
									if($first) {
										$residencestring .= ')';
										$first = 0;
									}
								}
							} elsif(($same_road_as_mother || $same_road_as_father) && !$printed_sibling) {
								if($age >= 30) {
									$residencestring .= ' on the same road as ' .
												($person->pronoun() eq 'She' ? 'her' : 'his');
									$printed_sibling = 1;
									$first = 0;

									my @r;
									if($same_road_as_mother && $same_road_as_father) {
										$residencestring .= i18n(' parents');
										@r = get_all_residences(person => $father);
									} elsif($same_road_as_mother) {
										$residencestring .= i18n(' mother');
										@r = get_all_residences(person => $mother);
									} else {
										$residencestring .= i18n(' father');
										@r = get_all_residences(person => $father);
									}
									foreach my $r(@r) {
										if(($r->date() eq $rdate) && $r->address()) {
											if($same_road_as_mother && $same_road_as_father) {
												$residencestring .= ' who were';
											} else {
												$residencestring .= ' who was';
											}
											$residencestring .= ' living at ' . $r->address();
											last;
										}
									}
								}
							} elsif(($mother || $father) && ($age < 16)) {
								if(!($with_mother || $with_father)) {
									complain({ person => $person, warning => "$rdate: Not living with either parent in childhood when aged $age" });
								}
								$living_alone = 0;
							} elsif($father_date && (datecmp($rdate, $father_date) > 0)) {
								if($language eq 'French') {
									$residencestring .= " (le m\N{U+00EA}me endoite que";
								} else {
									$residencestring .= ' (the same place as ' .
										($person->pronoun() eq 'She' ? 'her' : 'his');
								}
								if($mother_date && (datecmp($father_date, $mother_date) == 0)) {
									$residencestring .= ' ses' if($language eq 'French');
									$residencestring .= i18n(' parents ');
									$printed_mother_same_place = 1;
								} else {
									$residencestring .= i18n(' father ');
								}
								if(datecmp($rdate, $father_date) > 0) {
									$residencestring .= i18n('had been');
								} elsif($printed_mother_same_place) {
									$residencestring .= 'were';
								} else {
									$residencestring .= 'was';
								}
								$residencestring .= i18n(' living ') .
									year({ person => $person, string => $father_date }) .
									')';
								$printed_father_same_place = 1;
							} elsif($mother_date && (datecmp($rdate, $mother_date) > 0)) {
								$residencestring .= ' (the same place as ' .
									($person->pronoun() eq 'She' ? 'her' : 'his') . i18n(' mother ');
								if(datecmp($rdate, $mother_date) > 0) {
									$residencestring .= 'had been';
								} else {
									$residencestring .= 'was';
								}
								$residencestring .= ' living ' .
									year({ person => $person, string => $mother_date }) .
									')';
								$printed_mother_same_place = 1;
							}
						}
						if($spouse && $marriage_dt && (my $rdate_dt = date_to_datetime($rdate))) {
							if($marriage_dt > $rdate_dt) {
								my @sr = get_all_residences(person => $spouse);
								foreach my $sr(@sr) {
									my $sdate = $sr->date();
									next if(!defined($sdate));
									next if($sdate ne $rdate);
									if(place({ person => $spouse, record => $sr, nopreposition => 1 }) eq $place) {
										if($language eq 'French') {
											$residencestring .= ($printed_sibling ? ' et ' : ' avec ') .
												($person->pronoun() eq 'She' ? 'son futur mari, ' : 'sa futur femme, ') .
												given_names($spouse);
										} else {
											$residencestring .= i18n($printed_sibling ? ' and ' : ' with ') .
												($person->pronoun() eq 'She' ? 'her future husband, ' : 'his future wife, ') .
												given_names($spouse);
										}
										last;
									}
								}
							}
						}
					}
					if(defined($latitude) && defined($age) &&
					  (my $dt = date_to_datetime($rdate))) {
						# Print close relatives living close by
						# This really only works when printing a lot of people, for example with the -a
						#	flag, or when producing a PDF book, since it relies on having found data
						#	on people beforehand
						my $year = $dt->year();
						$year =~ s/^0+//;	# Strip leading zeros
						my $printed_person = 0;
						my $gis = GIS::Distance->new('MathTrig');
						my $p2 = place({ record => $residence, nopreposition => 1 });
						$p2 =~ s/^\s+//g;
						my @people_near_p2;
						my $p3;	# previous place

						my @sorted_locations = sort { $a->{'location'}->latitude() <=> $b->{'location'}->latitude() } @{$all_locations{$year}};

						# $Data::Dumper::Maxdepth = 2;
						# print Data::Dumper->new([\@sorted_locations])->Dump();

						my $iterator = Array::Iterator->new({ __array__ => \@sorted_locations });
						while(my $l = $iterator->get_next()) {
							# print Data::Dumper->new([$l])->Dump();
							if(($l->{'person'}->xref() ne $person->xref()) &&
							   (($spouses[0] && ($l->{'person'}->xref() eq $spouses[0]->xref())) ||
							   (my $relationship = $person->relationship($l->{'person'})) &&
							    ((stepsabove($l->{'person'}, $person, 0) <= 3) &&
							     (stepsabove($person, $l->{'person'}, 0) <= 3)))) {
								my $p1 = place({ record => $l->{'record'}, nopreposition => 1 });
								# This stops verbosity when the list is:
								#	high street, 33 high street, high street
								next unless($p1 =~ /^\s?\d/);
								$p1 =~ s/^\s+//g;

								my $peek = $iterator->peek();
								next if($peek && ($peek->{'person'}->xref() eq $l->{'person'}->xref()));

								my $close_relative;
								my $distance = $gis->distance($l->{'location'}->latitude(), $l->{'location'}->longitude(), $latitude, $longitude);
								# print "p1: $p1\n\tp2 $p2\n";
								# print "\t", $distance->yards(), '/', $distance->miles(), "\n";

								if(($p1 eq $p2) || places_are_the_same({ person => $person, first => $l->{'record'}, second => $residence, exact => 1 })) {
									# mother and father are single entries, the others are arrays
									if($relationship && ((!$living_with{$relationship}) || (($relationship ne 'mother') && ($relationship ne 'father')))) {
										if($relationship =~ /^cousin/) {
											$relationship = 'cousin';
										}
										push @{$living_with{$relationship}}, $l->{'person'};
									}
								} elsif(($l->{'location'}->latitude() == $latitude) && ($l->{'location'}->longitude() == $longitude)) {
									complain({
										person => $person,
										warning => [ $l->{'person'}->as_string(nee => 1), " residence is same location probably should be recorded as the same address ('$p1'/'$p2') in $year" ]
									});
									$close_relative = 1;
								} elsif($distance->miles() < 1) {
									if($distance->yards() < 20) {
										complain({
											person => $person,
											warning => [ $l->{'person'}->as_string(nee => 1), " residence is very close probably should be recorded as the same address ('$p1'/'$p2') in $year" ]
										});
									}
									$close_relative = 1;
								}
								if($close_relative) {
									# Add this relative to the list of close people, unless they are
									#	already in the list
									# p1 is the place of the relative we're considering ($l)
									# p2 is the place of the current person
									# p3 is the place of the previous relative we're considering
									# if($p3 && $peek && (place({ record => $peek->{'record'}, nopreposition => 1 }) eq " $p3")) {
									if($p3 && $peek && (places_are_the_same({ person => $person, first => $l->{'record'}, second => $peek->{'record'}, exact => 1 }))) {
										if((!defined($people_near_p2[0])) || ($people_near_p2[0]->{'person'}->xref() ne $l->{'person'}->xref())) {
											push @people_near_p2, $l;
										}
										next;
									}
									if($relationship && (($relationship eq 'brother') || ($relationship eq 'sister')) && ($age < 18)) {
										# Ignore children living with or close to siblings
										next;
									}
									if(!defined($p3)) {
										# First time we've looked at this place
										$p3 = $p1;
										next;
									}
									my $first_string;
									my $future_spouse;
									if($spouses[0] && ($l->{'person'}->xref() eq $spouses[0]->xref())) {
										if(defined($dateofmarriage) && ($dateofmarriage =~ /(\d{3,4})$/)) {
											if($year < $1) {
												$future_spouse = 1;
											}
										} elsif($age < 16) {
											$future_spouse = 1;
										}
									}
									if($future_spouse) {
										# FIXME: Only when before they married, though when
										#	they are married it should be the same place, right?
										if($language eq 'French') {
											$first_string = (($sex eq 'M') ? 'sa futur femme ' : 'son futur mari ');
										} else {
											$first_string = (($sex eq 'M') ? 'his future wife ' : 'her future husband ');
										}
									} else {
										next unless($relationship);
										if($age < 21) {
											if(my $mother = $person->mother()) {
												if($l->{'person'}->xref() eq $mother->xref()) {
													next;
												}
											}
											if(my $father = $person->father()) {
												if($l->{'person'}->xref() eq $father->xref()) {
													next;
												}
											}
										}
										$first_string = ($sex eq 'M' ? 'his' : 'her') .
											" $relationship ";
									}
									if($l->{'person'}->surname() eq $surname) {
										$first_string .= given_names($l->{'person'});
									} else {
										$first_string .= $l->{'person'}->as_string({ middle_names => 1 });
									}
									my @people_living_together = ($first_string);
									if(scalar(@people_near_p2)) {
										while(my $p = pop(@people_near_p2)) {
											if(my $r = $person->relationship($p->{'person'})) {
												push @people_living_together,
													"$r " . $p->{'person'}->as_string({ middle_names => 1 });
											}
										}
									}
									if($printed_person) {
										$residencestring .= ', ';
									} else {
										$residencestring .= ' - less than a mile from ';
									}
									$residencestring .= conjunction(@people_living_together);

									if(scalar(@people_living_together) > 1) {
										if($language eq 'French') {
											$residencestring .= ' qui habitaient';
										} else {
											$residencestring .= ' who were living';
										}
									} else {
										if($language eq 'French') {
											$residencestring .= ' qui habitait';
										} else {
											$residencestring .= ' who was living';
										}
									}
									$Data::Dumper::Maxdepth = 2;
									print STDERR Data::Dumper->new([$l])->Dump() if($opts{'v'});
									die Data::Dumper->new([$l])->Dump() if(!defined($l->{'record'}));
									$residencestring .= place({ record => $l->{'record'}, there => $p2, places_printed => \%places_printed });
									$residencestring .= ' -' if($printed_person);
									$printed_person = 1;
								}
							}
						}
					}
					if($spdeath_dt && (my $rdate_dt = date_to_datetime($rdate))) {
						if($rdate_dt > $spdeath_dt) {
							# Living with a child following death of spouse?
							CHILD: foreach my $child(@children) {
								my @cevents = $child->event();
								my $index = 0;
								EVENT: foreach my $event(@cevents) {
									$index++;
									if(!ref($event)) {
										my $e = $child->tag_record('EVEN', $index);
										if(ref($e) eq 'Gedcom::Record') {
											$event = $e;
										} else {
											# red_warning({ person => $child, warning => "Event record is just description ($event), information has been lost" });
											next EVENT;
										}
									}
									my $type = $event->type();

									# if(($type !~ /^Census U[KS] \d{4}$/) && ($type ne 'Register UK 1939')) {
									if(($type !~ /Census/) && ($type ne 'Register UK 1939')) {
										next EVENT;
									}
									if($opts{'v'} && $event->date() && ($event->date() eq $rdate)) {
										print __LINE__, ">> check if living with children\n",
										print "\t$type, ", ref($event), "\n",
										"\t", $event->date(), " $rdate ", $residence->address(), "\n";
									}
									if(($event->can('date') || $event->isa('Class::Simple::Readonly::Cached')) &&
									   $event->date() && ($event->date() eq $rdate) &&
									   $residence->address() &&
									   places_are_the_same({ person => $child, first => $residence, second => $event, exact => 1 })) {
										# Only print once living with a relative after death of spouse
										# FIXME: would be better to note if someone was living with a different person
										if($child->sex() eq 'F') {
											push @{$living_with{'daughter'}}, $child;
											$spdeath_dt = undef;
										} else {
											push @{$living_with{'son'}}, $child;
											$spdeath_dt = undef;
										}
										last CHILD;
									}
								}
							}
							if($spdeath_dt) {
								# Outlived spouse, but not living with a child
								my $date = dateofdeath($spouses[0]);
								if($date =~ /\s$/) {
									complain({ person => $person, warning => 'Removing trailing spaces from date of marriage' });
									$date =~ s/\s+$//;
								}
								$residencestring .= i18n(' following the death of ') .
									($person->pronoun() eq 'She' ? 'her' : 'his') .
									(($sex eq 'M') ? ' wife ' : ' husband ') .
									year(date => $date);
								$spdeath_dt = undef;
							}
						}
					}
				}
				if($residencestring) {
					$residencestring =~ s/^\s//;
					if($language eq 'French') {
						$residencestring =~ s/(.+), (his|her) /$1 et $2 /;
					} else {
						$residencestring =~ s/(.+), (his|her) /$1 and $2 /;
					}
					if(scalar(keys %living_with)) {
						# if($opts{'w'}) {
							# $Data::Dumper::Maxdepth = 2;
							# print STDERR __LINE__, ": TODO ($rdate): ", Data::Dumper->new([\%living_with])->Dump();
						# }

						delete $living_with{'mother'};
						delete $living_with{'father'};

						if(scalar(keys %living_with)) {
							$residencestring .= ', ' . i18n('when ') .
								lcfirst(i18n($person->pronoun())) .
								' was living with ' .
								lcfirst($person->possessive());

							if($language eq 'French') {
								$residencestring =~ s/lorsque elle/lorsqu'elle/;
							}

							if($living_with{'son'}) {
								my @sons = @{$living_with{'son'}};
								$residencestring .= i18n((scalar(@sons) > 1) ? ' sons, ' : ' son ') .
									conjunction(map { given_names($_) } @sons);
								if($living_with{'daughter'}) {
									$residencestring .= i18n(' and');
								} elsif(dateofdeath($spouses[0])) {
									$residencestring .= ', ' .
									i18n('following the death of ') .
									(($sex eq 'M') ? 'his wife ' : 'her husband ') .
									year(date => dateofdeath($spouses[0]));
								}
								delete $living_with{'son'};
							}
							if($living_with{'daughter'}) {
								my @daughters = @{$living_with{'daughter'}};
								$residencestring .= i18n((scalar(@daughters) > 1) ? ' daughters, ' : ' daughter ') .
									conjunction(map { given_names($_) } @daughters);
								if(my $sdod = dateofdeath($spouses[0])) {
									$residencestring .= i18n(' following the death of ') .
										(($sex eq 'M') ? 'his wife ' : 'her husband ') .
										year(date => $sdod);
								}
								delete $living_with{'daughter'};
							}

							foreach my $sibling (@{$living_with{'brother'}}, @{$living_with{'sister'}}) {
								push @{$living_with{'sibling'}}, $sibling;
							}
							delete $living_with{'sister'};
							delete $living_with{'brother'};

							if($living_with{'sibling'}) {
								# Print out all the siblings this person was living with
								# as an adult
								my @siblings = @{$living_with{'sibling'}};
								my $sex = $siblings[0]->sex();
								if(scalar(@siblings) == 1) {
									$residencestring .= i18n(($sex eq 'F') ? ' sister, ' : ' brother, ') .
										given_names($siblings[0]);
								} else {
									foreach my $sibling(@siblings) {
										if($sibling->sex() ne $sex) {
											undef $sex;
											last;
										}
									}
									if($sex) {
										# living with more than one sibling all of the same gender
										$residencestring .= i18n(($sex eq 'F') ? ' sisters, ' : ' brothers, ') .
											conjunction(map { given_names($_) } @siblings);
									} elsif(scalar(@siblings) == 2) {
										# Living with one brother and one sister
										my $brother;
										my $sister;
										if($siblings[0]->sex() eq 'M') {
											$brother = $siblings[0];
											$sister = $siblings[1];
										} else {
											$sister = $siblings[0];
											$brother = $siblings[1];
										}
										$residencestring .= i18n(' brother ') .
											given_names($brother) .
											i18n(' and ') .
											i18n('sister ') .
											given_names($sister);
									} else {
										# Living with siblings of differing genders
										my @brothers = grep { $_->sex() eq 'M' } @siblings;
										my @sisters = grep { $_->sex() eq 'F' } @siblings;
										if(scalar(@brothers) == 1) {
											$residencestring .= i18n(' brother, ') .
												given_names($brothers[0]) .
												i18n(' and') .
												i18n(' sisters, ') .
												conjunction(map { given_names($_) } @sisters);
										} else {
											$residencestring .= i18n(' sister, ') .
												given_names($sisters[0]) .
												i18n(' and') .
												i18n(' brothers, ') .
												conjunction(map { given_names($_) } @brothers);
										}
									}
								}
								delete $living_with{'sibling'};
							}

							# TODO: go through the keys when I'm sure it's all sensible
							foreach my $r('aunt', 'uncle', 'nephew', 'brother-in-law', 'sister-in-law', 'grandfather', 'grandmother', 'cousin') {
								next unless($living_with{$r});

								if(ref($living_with{$r}) eq 'ARRAY') {
									my @people = @{$living_with{$r}};
									if(scalar(@people) == 1) {
										$residencestring .= i18n(" $r, ") .
											given_names($people[0]);
									} elsif($r =~ /(.+)-in-law$/) {
										die $1, 's-in-law';
									} else {
										# Handle more than one
										$residencestring .= i18n(" ${r}s, ") .
											conjunction(map { given_names($_) } @people);
									}
								} else {
									$residencestring .= i18n(" $r, ") .
										given_names($living_with{$r});
								}
								delete $living_with{$r};
							}

							if($opts{'w'} && scalar(keys %living_with)) {
								warn $residencestring;
								$Data::Dumper::Maxdepth = 2;
								die $person->as_string({ include_years => 1, middle_names => 1 }), ": TODO ($rdate): ", Data::Dumper->new([\%living_with])->Dump();
							}
						}
						$living_alone = 0;
					}
					$residencestring =~ s/\sand$//;
					$residencestring =~ s/,$//;
					print __LINE__, ": adding '$residencestring' to residencestringarray\n" if($opts{'v'});
					push @residencestringarray, $residencestring;
					$printed_residence = 1;
				}
			}

			# Print out the residence strings with semi-colons between each residence
			if(scalar(@residencestringarray)) {
				$bio .= '.' unless($end_of_sentence || $start_of_paragraph);

				push @phrases, $phrase if($phrase->rtrim()->length());
				if(scalar(@phrases)) {
					if(scalar(@phrases) == 2) {
						# Not a list, but a sentance like this where a comma is useful:
						# She was born in Ramsgate, Kent, England on May 8, 1897, and was baptized at St Paul's Church, King St on May 26, 1897
						Lingua::Conjunction->penultimate(1);
					}
					my $text = conjunction(map { $_->as_string() } @phrases);
					if(!defined($text)) {
						die $person->as_string({ include_years => 1 }), ': BUG: residencestring array is unexpectedly empty';
					}
					Lingua::Conjunction->penultimate(0);
					$text =~ s/[\,;]\s*$//;
					$text =~ s/\s\-;/;/g;
					$bio_dt->append("$text.");
					$phrase = Data::Text->new();
					@phrases = ();
					$start_of_paragraph = 0;
				}

				my $first = $residencelist[0];
				my $all_in_county;
				my $all_in_country;
				if((scalar(@residencelist) == 1) && (my $rdate = $first->date())) {
					my $date = ucfirst(year({ person => $person, date => $rdate, circa => 'About' }));
					$bio .= " $date";
					$phrase->set(" $date");
				} else {
					if(!$start_of_paragraph) {
						$bio .= '</p><p>';
						$bio_dt->append('</p><p>');
						$start_of_paragraph = 1;
					}
					# See if this person was born, lived and died all in the same county
					if((scalar(@residencelist) > 3) && $birth_country && $death_country && ($birth_country eq $death_country)) {
						my $all_in_one_county = 1;
						$all_in_country = $birth_country;

						if($placeofbirth =~ /.+,\s*(.+),\s*.+$/) {
							$all_in_county = $1;
						} elsif($placeofbirth =~ /^(.+),\s*.+$/) {
							$all_in_county = $1;
						}
						foreach my $residence(@residencelist) {
							my $place = $residence->place();
							if(($place !~ /,\s*\Q$birth_country\E$/i)) {
								if($birth_country eq 'United Kingdom') {
									if(($place !~ /.+,\s*(UK|England|Wales|Scotland)$/i)) {
										$all_in_one_county = 0;
										last;
									}
									$all_in_country = $1;	# Use which country in the UK
								} else {
									$all_in_one_county = 0;
									last;
								}
							}
							if(defined($all_in_county) &&
							  (($place =~ /.+,\s*(.+),\s*.+$/) || ($place =~ /^(.+),\s*.+$/))) {
								if($1 ne $all_in_county) {
									$all_in_one_county = 0;
									last;
								}
							}
						}
						foreach my $event(@events) {
							next unless ref($event);
							if(my $type = $event->type()) {
								if(($type eq 'Military service') || ($type eq 'Military')) {
									$all_in_one_county = 0;	# Possibly served abroad
									last;
								}
							}
							if(my $place = $event->place()) {
								if(($place !~ /,\s*\Q$birth_country\E$/i)) {
									if($birth_country eq 'United Kingdom') {
										if(($place !~ /.+,\s*(UK|England|Wales|Scotland)$/i)) {
											$all_in_one_county = 0;
											last;
										}
										$all_in_country = $1;
									} else {
										$all_in_one_county = 0;
										last;
									}
								}
								if($place =~ /.+,\s*(.+),\s*.+$/) {
									if($1 ne $all_in_county) {
										$all_in_one_county = 0;
										last;
									}
								} elsif($place =~ /^(.+),\s*.+$/) {
									if($1 ne $all_in_county) {
										$all_in_one_county = 0;
										last;
									}
								}
							}
						}
						if($all_in_one_county) {
							if($phrase->length()) {
								push @phrases, $phrase;
							}
							if(scalar(@phrases)) {
								$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
								@phrases = ();
								$phrase = Data::Text->new();
							}
							$bio_dt->append("$firstname spent all of " .
								(($person->pronoun() eq 'She') ? 'her' : 'his') .
								" life in $all_in_county" .
								(($ENV{'LANG'} && ($ENV{'LANG'} =~ /^en_US/)) ? ',' : ' in') .
								" $all_in_country. ");
							$bio .= "$firstname spent all of " .
								(($person->pronoun() eq 'She') ? 'her' : 'his') .
								" life in $all_in_county" .
								(($ENV{'LANG'} && ($ENV{'LANG'} =~ /^en_US/)) ? ',' : ' in') .
								" $all_in_country. ";
						} else {
							undef $all_in_country;
							undef $all_in_county;
						}
					}

					if(scalar(@residencelist) > 1) {
						if($language eq 'French') {
							$phrase->set('Pendant sa vie');
							$bio .= 'Pendant sa vie';
						} else {
							$phrase->set('Throughout ' . lc($person->possessive()) . ' life');
							$bio .= 'Throughout ' . lc($person->possessive()) . ' life';
						}
					} else {
						$bio .= ucfirst(i18n(person => $person, format => 'during %s life', args => lc($person->possessive())));
						$phrase->set(ucfirst(i18n(person => $person, format => 'during %s life', args => lc($person->possessive()))));
					}
				}

				# print Data::Dumper->new([\@residencestringarray])->Dump();

				# Because peek above only looks ahead one element:
				# [
					  # 'at Shuart Cottage, Podden Street, St Nicholas-at-Wade on Apr 5, 1891 (was age 0 and the son of the head of the household; was age 0 and the son of the head of the household)',
					  # 'at Cottage, Nash Court, Garlinge, Kent on Mar 31, 1901 (was age 10, the son of the head of the household) and on Apr 2, 1911 (was age 20 and the son of the head of the household)',
					  # 'at 1 Hill View Cottages, Twenties, Shottendane Road, Margate, Kent in 1915-',
					  # '1923, in 1929 and on Sep 29, 1939 (was the head of the household)'
				# ];
				foreach my $i(0..(scalar(@residencestringarray) - 2)) {
					if($residencestringarray[$i+1] =~ /^\d/) {
						$residencestringarray[$i+1] =~ s/^\d{4}, in //g;
						$residencestringarray[$i] .= $residencestringarray[$i+1];
						$residencestringarray[$i+1] = undef;
					}
				}
				# while(!defined($residencestringarray[scalar(@residencestringarray) - 1])) {
					# pop @residencestringarray;
				# }
				# while(!defined($residencestringarray[0])) {
					# shift @residencestringarray;
				# }
				@residencestringarray = grep { defined } @residencestringarray;
				# $phrase->append(', ' . lcfirst($pronoun) . i18n(' was living ') .
					# Lingua::EN::Inflect::WORDLIST(@residencestringarray, {sep => '; ', conj => i18n('and')});
				my $s = ', ';
				if(scalar(@residencestringarray) < 3) {
					if($language eq 'German') {
						# Since it's just after a date, lose the comma and ensure the verb will be the
						# second thing in the sentence
						$s = ' lebte ' . lcfirst($pronoun);
					} else {
						$s .= lcfirst($pronoun);
						if(is_alive($person)) {
							if($first->date()) {
								$s .= i18n(' was living');
							} else {
								$s .= i18n(' has lived');
							}
						} else {
							$s .= i18n(' lived');
						}
					}
				} else {
					if($all_in_county) {
						$s .= lcfirst($pronoun) . ' ';
					} else {
						$s .= "$firstname ";
					}
					if(is_alive($person) && !$first->date()) {
						$s .= 'has ';
					}
					$s .= i18n('lived in several places');
					if($all_in_county) {
						$s .= ' around the county';
						@residencestringarray = map { if($_ =~ /(.+),\s*$all_in_county ([io]n .+)/) { "$1 $2" } else { $_ } } @residencestringarray;
					} elsif($all_in_country) {
						$s .= " around $all_in_country";
						@residencestringarray = map { if($_ =~ /(.+),\s*$all_in_country ([io]n .+)/) { "$1 $2" } else { $_ } } @residencestringarray;
					}
					$s .= ($language eq 'French') ? ' :' : ':';
				}

				print Data::Dumper->new([\@residencestringarray])->Dump() if($opts{'v'});
				if($language eq 'French') {
					Lingua::Conjunction->separator_phrase(' ;');
				} else {
					Lingua::Conjunction->separator_phrase(';');
				}
				Lingua::Conjunction->penultimate(1);
				$bio .= "$s " . conjunction(@residencestringarray);
				$phrase->append([ "$s ", conjunction(@residencestringarray)]);
				Lingua::Conjunction->separator_phrase(',');
				Lingua::Conjunction->penultimate(0);

				if($placeofdeath) {
					my $lastresidence = $residencelist[scalar(@residencelist) - 1];
					my $deathplace = place({ person => $person, record => $death });
					my $lastdate = $lastresidence->date();
					$lastresidence = place({ person => $person, record => $lastresidence });
					if(defined($lastdate) && defined($lastresidence) && defined($deathplace) && ($deathplace eq $lastresidence)) {
						my $p = lcfirst($pronoun);
						if($language eq 'French') {
							$bio .= " c'est o\N{U+00F9} $p est mort";
							$phrase->append(" c'est o\N{U+00F9} $p est mort");
							if($sex eq 'F') {
								$bio .= 'e';
								$phrase->append('e');
							}
						} else {
							$bio .= " which is where $p died";
							$phrase->append(" which is where $p died");
						}
						if($dateofdeath) {
							if($dateofdeath =~ /\s$/) {
								complain({ person => $person, warning => 'Removing trailing spaces from date of death' });
								$dateofdeath =~ s/\s+$//;
							}
							my $date = year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
							$lastdate =~ s/^.*(\d{4})$/$1/;
							$date =~ /, (\d{3,4})$/;
							if($lastdate == $yod) {
								$date =~ s/, (\d{3,4})$//;
							}
							$bio .= " $date";
							$phrase->append(" $date");
						}
						$bio .= cite(@deathcitations);
						$phrase->append(cite(@deathcitations));

						# Cause of death
						if(my $cause = $person->cause()) {
							$cause = lc($cause);
							$bio .= " ($cause)";
							$phrase->append(" ($cause)");
						}

						# Print notes about the death, if any
						my $notes;
						if($notes = notes({ person => $person, record => $death, note_locations => \@note_locations })) {
							$notes =~ tr/\r//;
							$notes =~ tr/\n/ /;
							$notes =~ s/[\.,]$//;
							$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
							$bio .= " ($notes)";
							$phrase->append(" ($notes)");
						}
						$diedathome = 1;
					}
				}
				if(!$military_location) {
					$bio .= '. ';
					$end_of_sentence = 1;

					if($phrase->length()) {
						push @phrases, $phrase;
					}
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
					$phrase = Data::Text->new();
					@phrases = ();
				}
			}
		}
	}

	# FIXME - these start and end dates for censuses should depend on countries
	if($living_alone && $yob && $yod && (($yod - $yob) > 10) && ($yob >= 1842) && ($yob <= 1920)) {
		# Age at death > 10 years - should have at least appeared on one census
		complain({ person => $person, warning => 'No records of living with anyone' });
	}
	# if(scalar(@residences) == 0) {
		# print $csv '.';
		# print $xml '.';
		# $phrase->append('XXXXXXXXXXXXXXXXXXXXXX');
	# }

	# $bio =~ s/,;/;/g;
	# $bio =~ s/;$//;
	# $bio =~ s/,.$/./;

	my $all_events_have_date = 1;
	foreach my $event(@events) {
		if((ref($event) ne 'Gedcom::Record') || !$event->date()) {
			$all_events_have_date = 0;
			last;
		}
		my $date = $event->date();
		if(($date !~ /^\d/) || ($date =~ /[a-z]$/i) ||
		   ($date =~ /[\/\-]/) || !date_parser_cached(date => $date)) {
			$all_events_have_date = 0;
			last;
		}
		if(!date_parser_cached(date => $date)) {
			complain({
				person => $person,
				warning => "Event has an invalid date of $date"
			});
			$all_events_have_date = 0;
			last;
		}
	}

	# Sort the events by date
	if(all_records_have_date({ person => $person, records => \@events }) && (scalar(@events) > 0)) {
		# @events = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @events;
		@events = sort { datecmp($a, $b) } @events;
	}

	# Let's remove things that aren't relevant that may
	# allow optimisations in the English
	# while(scalar(@events) > 2) {
		# my $e = $events[scalar(@events) - 1];
		# # TODO: add more
		# if(ref($e) && ($e->type() eq 'Register UK 1939')) {
			# pop @events;
		# } else {
			# last;
		# }
	# }

	my $funeral;

	if((scalar(@events) == 2) &&
	   $events[0]->can('type') && $events[1]->can('type') &&
	   $events[0]->type() && $events[1]->type() &&
	   ((($events[0]->type() eq 'Arrival') && ($events[1]->type() eq 'Departure')) ||
	   (($events[1]->type() eq 'Arrival') && ($events[0]->type() eq 'Departure')))) {
		$bio .= '. ' if(!$end_of_sentence);

		if($phrase->length()) {
			push @phrases, $phrase;
			$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
			$phrase = Data::Text->new();
			@phrases = ();
		}

		my $arrival = ($events[0]->type() eq 'Arrival') ? $events[0] : $events[1];
		my $departure = ($events[0]->type() eq 'Departure') ? $events[0] : $events[1];
		if($events[0]->type() ne $events[1]->type()) {
			# Simple case - one journey made
			my $s = journey({ person => $person, arrival => $arrival, departure => $departure, spouses => \@spouses, children => \@children }) . '. ';
			$bio .= $s;
			$bio_dt->append($s);
		} else {
			my $date1 = year(record => $events[0]);
			my $date2 = year(record => $events[1]);
			my $year1;
			my $year2;
			if($date1 =~ /(.*)\s?(\d{4})$/) {
				$date1 = $1;
				$year1 = $2;
				$date1 =~ s/,\s//;
			}
			if($date2 =~ /(.*)\s?(\d{4})$/) {
				$date2 = $1;
				$year2 = $2;
				$date2 =~ s/,\s//;
			}
			if($year1 == $year2) {
				my $motion;
				if($events[0]->type() eq 'Arrival') {
					$motion = 'arrived';
				} else {
					$motion = 'departed';
				}
				$bio .= "During $year1 " . lcfirst($pronoun) . i18n(" $motion") .
					place({ person => $person, record => $events[0] }) .
					"$date1 and" .
					place({ person => $person, record => $events[1], nopreposition => 1 }) .
					" $date2.";
				$bio_dt->append("During $year1 " . lcfirst($pronoun) . " $motion" .
					place({ person => $person, record => $events[0] }) .
					"$date1 and" .
					place({ person => $person, record => $events[1], nopreposition => 1 }) .
					" $date2.");
			} else {
				die 'TODO';
			}
		}

		$end_of_sentence = 1;
	} elsif(scalar(@events) == 1) {
		$bio .= '.' if(!$end_of_sentence);
		$end_of_sentence = 1;

		if($phrase->length()) {
			push @phrases, $phrase;
			$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
			$phrase = Data::Text->new();
			@phrases = ();
		}

		my $event = $person->event();
		if(!ref($event)) {
			my $e = $person->tag_record('EVEN');
			if(ref($e) eq 'Gedcom::Record') {
				$event = $e;
			} else {
				red_warning({ person => $person, warning => "Event record is just description ($event), information has been lost" });
				$bio .= ' ' . ucfirst($event) . '.';
				$bio_dt->append(' ' . ucfirst($event) . '.');
				$end_of_sentence = 1;
			}
		}
		if($event->can('type') || $event->isa('Class::Simple::Readonly::Cached')) {
			# FIXME:  a lot of this code is duplicated with scalar(@events) > 1
			my $type = $event->type();
			if(!defined($type)) {
				red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
			} elsif($type eq 'Arrival') {
				if($end_of_sentence) {
					$bio .= ' ' unless($bio =~ /\s$/);
				} else {
					$bio .= '. ';
				}
				$bio .= " $pronoun" . i18n({ person => $person, format => ' arrived' });
				if((scalar(@phrases) == 0) && ($phrase->length() == 0)) {
					$phrase->set($pronoun);
				} else {
					$phrase->append(lcfirst($pronoun));
				}
				$phrase->append(i18n({ person => $person, format => ' arrived' }));
				if(my $p = place({ person => $person, record => $event })) {
					$bio .= $p;
					$phrase->append($p);
				} else {
					complain({ person => $person, warning => 'Arrival record has no place' });
				}
				if(my $y = year({ person => $person, record => $event })) {
					$bio .= " $y";
					$phrase->append(" $y");
				} else {
					complain({ person => $person, warning => "Arrival record has no date" });
				}
				if(my $spouse = $spouses[0]) {
					foreach my $sevent($spouse->event()) {
						if(ref($sevent) eq 'Gedcom::Record') {
							my $stype = $sevent->type();
							if(!defined($stype)) {
								red_warning({ person => $spouse, warning => "Can't determine type of event, or the event type is empty" });
							} elsif($sevent->place() && ($stype eq 'Arrival') &&
							   $event->date() && $sevent->date() &&
							   ($event->date() eq $sevent->date()) &&
							   ($event->place() eq $sevent->place())) {
								$bio .= i18n(' with ') .
									lcfirst($person->possessive()) . ' ' .
									(($sex eq 'M') ? 'wife' : 'husband') .
									' ' . given_names($spouse);
								$phrase->append(i18n(' with ') .
									lcfirst($person->possessive()) . ' ' .
									(($sex eq 'M') ? 'wife' : 'husband') .
									' ' . given_names($spouse));
							}
						}
					}
				}
				if(my $notes = notes({ record => $event, note_locations => \@note_locations })) {
					$notes = lcfirst($notes);
					$notes =~ s/\.$//;
					$bio =~ s/\s$//;
					$bio .= " ($notes)";
					$phrase->rtrim()->append(" ($notes)");
				}
				$bio .= '. ';
				$end_of_sentence = 1;

				push @phrases, $phrase;
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				$phrase = Data::Text->new();
				@phrases = ();

				if($event->address()) {
					if($ENV{'LANG'} =~ /^en_US/) {
						$place_records{'Traveled to'} = $event;
					} else {
						$place_records{'Travelled to'} = $event;
					}
				} else {
					complain({ person => $person, warning => 'Date is known but not location in arrival record' });
				}
			} elsif($type eq 'Departure') {
				$phrase->set($pronoun);
				if($end_of_sentence) {
					$bio .= ' ' unless($bio =~ /\s$/);
				} else {
					$bio .= '. ';
				}
				$bio .= $pronoun;

				if($ENV{'LANG'} =~ /^en_US/) {
					$bio .= ' traveled';
					$phrase->append(' traveled');
				} else {
					$bio .= ' travelled';
					$phrase->append(' travelled');
				}
				my $place = place({ person => $person, record => $events[0] });
				if($language eq 'German') {
					$place =~ s/^\sin/ von/;
				} else {
					$place =~ s/^\sin/ from/;
				}
				$bio .= $place;
				$phrase->append($place);
				if(my $date = year({ person => $person, record => $event })) {
					$bio .= " $date";
					$phrase->append(" $date");
				}
				if(my $notes = notes({ record => $event, note_locations => \@note_locations })) {
					$notes = lcfirst($notes);
					$bio .= " ($notes)";
					$phrase->append(" ($notes)");
				}
				$bio .= '. ';
				$end_of_sentence = 1;

				push @phrases, $phrase;
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				$phrase = Data::Text->new();
				@phrases = ();
			} elsif(($type eq 'Military service') || ($type eq 'Military')) {
				if($end_of_sentence) {
					$bio .= ' ' unless($bio =~ /\s$/);
				} else {
					$bio .= '.';
				}
				if(scalar(@phrases)) {
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
					$phrase = Data::Text->new(' ');
					@phrases = ();
				} else {
					$phrase->append(' ');
				}
				my $date = year(record => $event);
				if($military_location) {
					$bio .= 'when ' . lcfirst($pronoun) . (' was serving in the military');
					$phrase->append('when ' . lcfirst($pronoun) . (' was serving in the military'));
				} elsif($date) {
					if($date =~ /^from /i) {
						$bio .= "$pronoun was serving in the military";
						$phrase->append("$pronoun was serving in the military");
					} else {
						my $service = ucfirst($date) . ' ' . lcfirst($pronoun) . ' was serving in the military';
						$bio .= $service;
						$phrase->append($service);
					}
				} else {
					$bio .= "</p><p>$pronoun served in the military";
					$phrase->append("</p><p>$pronoun served in the military");
				}
				if(my $place = place({ person => $person, record => $event })) {
					$bio .= $place;
					$phrase->append($place);
					$parse_tree->{'military'}->{'place'} = $place;
				}
				if($date && ($date =~ /^from /i)) {
					$bio .= " $date";
					$phrase->append(" $date");
				}

				if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
					$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
					$notes =~ s/[\s\.]+$//;
					$bio .= " (<em>$notes</em>). ";

					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append(" (<em>$notes</em>). ");
					$phrase = Data::Text->new();
					@phrases = ();

					$end_of_sentence = 1;
				} else {
					$end_of_sentence = 0;
				}
			} elsif($type eq 'Newspaper') {
				if($phrase->length()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				}
				if(scalar(@phrases) > 0) {
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases));
					@phrases = ();
				} else {
					$phrase->set($firstname // $pronoun)->append(' ');
				}
				$bio .= '. ' if(!$end_of_sentence);
				$bio .= "$pronoun appeared in a newspaper";
				$phrase->append('appeared in a newspaper');
				my $newspaper = newspaper({ gedcom => $ged, person => $person, event => $event });
				if(my $date = $newspaper->date()) {
					$phrase->append(" on $date");
					$bio .= " on $date";
				}
				my $url = $newspaper->url();
				if(my $title = $newspaper->title()) {
					$url = "<a href=\"$title\">$url</a>";
				}
				$phrase->append(" ($url)");
				$bio .= " ($url)";
				$bio_dt->append($phrase)->append('. ');

				# die $i->page();
			} elsif($type eq 'Funeral') {
				$funeral = $event;
				if($end_of_sentence) {
					$bio .= ' ' unless($bio =~ /\s$/);
				} else {
					$bio .= '. ';
				}
				if(scalar(@phrases)) {
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
					$phrase = Data::Text->new();
				} else {
					$phrase->append(' ');
				}
			} elsif($type eq 'event') {
				# 1 EVEN Some text describing the event
				# 2 TYPE event
				# 2 DATE 29 Sep 1939
				# 2 PLAC Margate, Kent, England
				# $Data::Dumper::Maxdepth = 2;
				# print Data::Dumper->new([$event])->Dump();
				if($end_of_sentence) {
					$bio .= ' ' unless($bio =~ /\s$/);
				} else {
					$bio .= '. ';
				}
				if($phrase->length()) {
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
					$phrase = Data::Text->new();
					@phrases = ();
				}
				if(my $date = year(record => $event)) {
					$date = ucfirst($date);
					$bio .= " $date ";
					$phrase->set("$date ");
				}
				$bio .= lc($pronoun);
				$phrase->append(lc($pronoun));
				if(my $value = $event->value()) {
					$value = ' ' . lcfirst($value);
					$bio .= $value;
					$phrase->append($value);
				}
				if(my $place = place({ person => $person, record => $event })) {
					$bio .= $place;
					$phrase->append($place);
				}
				$end_of_sentence = 0;
			} elsif($type eq 'Granted Arms') {
				if($end_of_sentence) {
					$bio .= ' ' unless($bio =~ /\s$/);
				} else {
					$bio .= '. ';
				}
				if($phrase->length()) {
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
					$phrase = Data::Text->new();
					@phrases = ();
				} else {
					$phrase->set(' ');
					$bio_dt->append(' ');
				}
				if(my $date = year(record => $event)) {
					$date = ucfirst($date);
					$bio .= "$date " . lc($pronoun);
					$phrase->append("$date " . lc($pronoun));
				} else {
					$bio .= $pronoun;
					$phrase->append($pronoun);
				}
				$bio .= ' was granted a coat of arms';
				$phrase->append(' was granted a coat of arms');
				$end_of_sentence = 0;
			} elsif($type eq 'Employment') {
				if($end_of_sentence) {
					$bio .= ' ' unless($bio =~ /\s$/);
				} else {
					$bio .= '. ';
				}
				if($phrase->length()) {
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
					$phrase = Data::Text->new();
					@phrases = ();
				} else {
					$phrase->set(' ');
					$bio_dt->append(' ');
				}
				if(my $date = year(record => $event)) {
					$date = ucfirst($date);
					$bio .= "$date " . lcfirst($pronoun) . ' was working';
					$phrase->append("$date " . lcfirst($pronoun) . ' was working');
				} else {
					$bio .= "$pronoun worked";
					$phrase->append("$pronoun worked");
				}
				if(my $place = place(person => $person, record => $event)) {
					$bio .= $place;
					$phrase->append($place);
				}
				$end_of_sentence = 0;
			} elsif($type eq 'Custom') {
				# TODO: Custom records will be, by definition, difficult to parse and standardise.
				if($end_of_sentence) {
					$bio .= ' ' unless($bio =~ /\s$/);
				} else {
					$bio .= '. ';
				}
				if($phrase->length()) {
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
					$phrase = Data::Text->new();
					@phrases = ();
				} else {
					$phrase->set(' ');
					$bio_dt->append(' ');
				}
				if(my $date = year(record => $event)) {
					$bio .= "$date " . lcfirst($pronoun);
					$phrase->append("$date " . lcfirst($pronoun));
				}
				if(my $place = place(person => $person, record => $event)) {
					if($phrase->length() == 0) {
						$place = ucfirst($place);
					}
					$bio .= $place;
					$phrase->append($place);
				}
				$end_of_sentence = 0;
			} elsif($type eq 'Unknown') {
				if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
					$notes = ucfirst($notes);
					$bio .= " ($notes)";
					$bio =~ s/\s$//;
					$phrase->rtrim()->append(" ($notes)");
					$end_of_sentence = 0;
				}
			# } elsif(($type !~ /^Census U[KS] \d{4}$/) &&
			} elsif(($type !~ /Census/) &&
				($type ne 'Race') &&
				($type ne 'Custom Marriage') &&
				($type ne 'Email') &&
				($type ne 'Register UK 1939')) {

				complain({ person => $person, warning => "Unhandled event type: $type" });
				# die 'TODO: ', $person->as_string({ nee => 1, include_years => 1, middle_names => 1 }), " event type $type";
				my $notes = $type;
				if(my $n = notes(record => $event, note_locations => \@note_locations)) {
					$n =~ s/[\s\.]+$//;
					$notes = "$type: $n";
				}
				my $date = year(record => $event);
				$bio =~ s/\s$//;
				if($end_of_sentence) {
					if($date) {
						$bio .= ' ' . ucfirst($notes) . " $date. ";
					} else {
						$bio .= ' ' . ucfirst($notes) . '. ';
					}
				} else {
					$notes = lcfirst($notes);
					if($date) {
						$bio .= " ($date, $notes)";
					} else {
						$bio .= " ($notes)";
					}
					$end_of_sentence = 0;
				}
				if($phrase->rtrim()->length()) {
					$notes = lcfirst($notes);
					if($date) {
						$phrase->append(" ($date, $notes)");
					} else {
						$phrase->append(" ($notes)");
					}
				} else {
					if($date) {
						$phrase->set(' ' . ucfirst($notes) . " $date");
					} else {
						$phrase->set(' ' . ucfirst($notes));
					}
				}

				# Try hard to get some information
				my @objects = $event->obje();
				foreach my $o(@objects) {
					# If there's a hyperlink in the object, honour that
					my $obje;
					if($o->isa('Gedcom::Record')) {
						$obje = $o;	# e.g. Ancestry
					} else {
						$obje = $ged->resolve_xref($o);	# e.g. FMP
					}
					next if(!defined($obje));
					next if(!ref($obje));
					my $title = $obje->file->title();
					foreach my $item($obje->items()) {
						next if($item->tag() ne '_ORIG');
						foreach my $item2($item->items()) {
							next if($item2->tag() ne '_URL');
							my $link = "$title (" . $item2->value() . ')';
							$bio .= $link;
							$phrase->append($link);
							last;
						}
					}

					# If there's a location in the object, add that to the known locations
					if((my $place = $obje->place()) && (my $date = $obje->date())) {
						my $dt = date_to_datetime($date);
						my $strftime = $dt->strftime('%x');
						my $year = $dt->year();
						$year =~ s/^0+//;	# Strip leading zeros
						if(my $location = get_location($place)) {
							push @{$all_locations{$year}}, {
								'record' => $obje,
								'person' => $person,
								'date' => $strftime,
								'latitude' => $location->lat(),
								'longitude' => $location->long(),
								'location' => $location
							};
							# Add it to the map of where a person has been
							$place_records{"$title: " . year({ person => $person, string => $date })} = $obje;
							warn "DEBUGGING: object has a location: $place";
						}
					}
				}
				$notes = ucfirst($notes);
				$bio .= " ($notes)";
				$bio =~ s/\s$//;
				$phrase->rtrim()->append(" ($notes)");
				$end_of_sentence = 0;
			}
		}
	} elsif(scalar(@events) > 0) {
		my @newspapers;
		foreach my $event(@events) {
			# This is a non-standard thing that FMP has invented :-(
			if(ref($event) && $event->can('type')) {
				if(my $type = $event->type()) {
					push @newspapers, $event if($type eq 'Newspaper');
				}
			}
		}
		if(scalar(@newspapers) == 1) {
			# FIXME: duplicate code with one event
			my $s;
			if($phrase->length()) {
				push @phrases, $phrase;
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
				$phrase = Data::Text->new();
				@phrases = ();
			}
			$bio .= '. ' if(!$end_of_sentence);
			$s = ($firstname // $pronoun) . ' ';
			$s .= 'appeared ';

			if(my $newspaper = newspaper({ gedcom => $ged, person => $person, event => $newspapers[0] })) {
				my $title = $newspaper->title();
				my $url = $newspaper->url();
				if(defined($title) && ($title =~ /^https?:\/\//)) {
					if($url) {
						# FIXME: This really should be a citation
						$s .= "<a href=\"$url\">$title</a>";
					} else {
						$s .= "<a href=\"$title\">$title</a>";
					}
				}

				if($title) {
					$s .= "in $title";
				} else {
					$s .= 'in a newspaper'
				}
				if(my $date = $newspaper->date()) {
					$s .= " on $date";
				}
				if(my $page = $newspaper->page()) {
					$s .= " on page $page";
				}
				if((!defined($title)) && defined($url)) {
					# FIXME: This really should be a citation
					$s .= " (<a href=\"$url\">$url</a>)";
				}
				$bio .= $s;
				$phrase->append($s);
				push @{$parse_tree->{'newspapers'}}, $newspaper;
			}
		} elsif(scalar(@newspapers) > 1) {
			if($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
			if(scalar(@phrases) == 0) {
				$phrase->set($firstname // $pronoun)->append(' ');
				$bio .= '<p>' . ($firstname // $pronoun) . ' ';
			}
			$bio .= ('appeared in ' . scalar(@newspapers) . ' newspapers: ');
			$phrase->append('appeared in ' . scalar(@newspapers) . ' newspapers: ');
			my @newspaper_list;
			foreach my $n(@newspapers) {
				my $newspaper = newspaper({ gedcom => $ged, person => $person, event => $n });
				my $string;
				if(my $title = $newspaper->title()) {
					$string = "in $title ";
				} else {
					$string = 'in an unknown newspaper ';
				}
				if(my $date = $newspaper->date()) {
					$string .= "on $date ";
				}
				if(my $page = $newspaper->page()) {
					$string .= "on page $page ";
				}
				if(my $url = $newspaper->url()) {
					$string .= "(<a href=\"$url\">$url</a>)";
				}
				push @newspaper_list, $string;
			}
			$bio .= conjunction(@newspaper_list) . '.</p><p>';
			$end_of_sentence = 1;

			$phrase->appendconjunction(@newspaper_list);
			push @phrases, $phrase;
			$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.</p><p>');
			$phrase = Data::Text->new();
		}

		my $index = 0;
		my $mentioned_military;
		my $previous;
		my $prev_type;

		foreach my $event(@events) {
			$index++;
			if(!ref($event)) {
				my $e = $person->tag_record('EVEN', $index);
				if($e->isa('Gedcom::Record')) {
					$event = $e;
				} else {
					red_warning({ person => $person, warning => "Event record is just description ($event), information has been lost" });
					$bio =~ s/\s$//;
					$bio .= ' ' . ucfirst($event) . '.';

					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append(' ' . ucfirst($event) . '.');
					$phrase = Data::Text->new();
					@phrases = ();
				}
			}
			if($event->can('type')) {
				my $type = $event->type();
				if(!defined($type)) {
					red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
					next;
				}
				print "Event type: $type\n" if($opts{'v'});
				if($type eq 'Military service') {
					if(!$mentioned_military) {
						if($end_of_sentence) {
							$bio .= ' ' unless($bio =~ /\s$/);
						} else {
							$bio .= '.';
						}

						if($phrase->length()) {
							push @phrases, $phrase;
							$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
							$phrase = Data::Text->new();
							@phrases = ();
						}

						my $service = service($event);
						if(defined(my $date = year(record => $event))) {
							if($date =~ /^from /) {
								$bio .= ' ' unless($bio =~ /\s$/);
								$bio .= "$pronoun served in the $service $date";
								$phrase->set("$pronoun served in the $service $date");
								if(defined($dateofmarriage) && ($dateofmarriage =~ /(\d{3,4})$/)) {
									my $yom = $1;

									my @dates = $dfg->parse_datetime($date);
									if($dates[1]) {
										if($marriage_dt &&
										   ($dates[1]->year() == $marriage_dt->year())) {
											if(datecmp($dates[1], $marriage_dt) > 0) {
												$bio .= ', just before ';
												$phrase->append(', just before ');
											} else {
												$bio .= ', just after ';
												$phrase->append(', just after ');
											}
											$bio .= lcfirst($pronoun) . ' married ' . $spouses[0]->as_string();
											$phrase->append(lcfirst($pronoun))->append(' married ')->append($spouses[0]->as_string());

										}
									} elsif($date =~ /^from (\d{3,4}) to (\d{3,4})$/) {
										if($2 == $yom) {
											$bio .= ' the year ' . lcfirst($pronoun) . ' married ' . $spouses[0]->as_string();
											$phrase->append(', the year ')->append(lcfirst($pronoun))->append(' married ')->append($spouses[0]->as_string());
										}
									}
								}
							} else {
								if($date =~ /^on /) {
									$bio .= ucfirst($date) . ' ';
									$phrase->set(' ' . ucfirst($date) . ' ');
								} elsif($date =~ /^in (\d{4})/) {
									$bio .= "During $1, ";
									$phrase->set(" During $1, ");
								} elsif($date =~ /(.+)\-(.+)/) {
									$bio .= "Between $1 and $2 ";
									$phrase->set(" Between $1 and $2 ");
								} else {
									$bio .= ucfirst($date) . ' ';
									$phrase->set(' ' . ucfirst($date) . ' ');
								}
								$bio .= lcfirst($pronoun) . " was serving in the $service";
								$phrase->append(lcfirst($pronoun) . " was serving in the $service");
							}
						} else {
							$bio .= "$pronoun served in the $service";
							$phrase->set(" $pronoun served in the $service");
						}

						if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
							$bio .= $place;
							$phrase->append($place);
							$parse_tree->{'military'}->{'place'} = $place;
						}

						$mentioned_military = 1;
					}

					if((!$mentioned_military) || ($event->get_value() && (notes(record => $event) ne 'Royal Navy.'))) {
						if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
							$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
							$notes =~ s/[\s\.]+$//;
							$bio .= " (<em>$notes</em>)";
							$phrase->append(" (<em>$notes</em>)");
						}
					}
					$end_of_sentence = 0;
				} elsif($type eq 'Arrival') {
					if(!defined($event->place())) {
						complain({ person => $person, warning => 'Arrival record without destination' });
						next;
					}
					if(my $e = $events[$index]) {
						if(ref($e) && $e->type() && ($e->type() eq 'Arrival') && $event->date() && $e->date()) {
							$previous = $event;
							$prev_type = $event->type();
							# FIXME: not all locations will be noted or notes printed
							next;
						}
					}
					if($previous) {
						if($prev_type eq 'Departure') {
							$bio .= '. ' if(!$end_of_sentence);
							$bio .= journey({ person => $person, arrival => $event, departure => $previous });
							if($phrase->length()) {
								push @phrases, $phrase;
								$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
								$phrase = Data::Text->new();
								@phrases = ();
							}
							$phrase->set(' ' . journey({ person => $person, arrival => $event, departure => $previous }));
						} else {
							# Two arrival records, put into one sentence for improved readability
							my $date1 = year({ record => $previous });
							my $date2 = year({ record => $event });
							my $year1;
							my $year2;
							if($date1 =~ /(.*)\s?(\d{4})$/) {
								$date1 = $1;
								$year1 = $2;
								$date1 =~ s/,\s//;
							}
							if($date2 =~ /(.*)\s?(\d{4})$/) {
								$date2 = $1;
								$year2 = $2;
								$date2 =~ s/,\s//;
							}
							$bio .= '. ' if(!$end_of_sentence);
							if($phrase->length()) {
								push @phrases, $phrase;
								$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
								$phrase = Data::Text->new();
								@phrases = ();
							}
							if(defined($year1) && defined($year2) && ($year1 == $year2)) {
								if($date1 eq 'in ') {
									$date1 = '';
								} else {
									$date1 = " $date1";
								}
								$bio .= "During $year1 " . lcfirst($pronoun) . ' arrived' .
									place({ person => $person, record => $previous }) .
									" $date1 and" .
									place({ person => $person, record => $event, nopreposition => 1 }) .
									" $date2";
								$phrase->set("During $year1 " . lcfirst($pronoun) . ' arrived' .
									place({ person => $person, record => $previous }) .
									" $date1 and" .
									place({ person => $person, record => $event, nopreposition => 1 }) .
									" $date2");
							} else {
								$bio .= ucfirst(year({ person => $person, record => $previous })) .
									' ' . lcfirst($person->pronoun()) .
									' arrived' .
									place({ person => $person, record => $previous }) .
									' and ' .
									year({ person => $person, record => $event }) .
									' ' . lcfirst($pronoun) .
									' arrived' .
									place({ person => $person, record => $event });
								$phrase->set(ucfirst(year({ person => $person, record => $previous })) .
									' ' . lcfirst($person->pronoun()) .
									' arrived' .
									place({ person => $person, record => $previous }) .
									' and ' .
									year({ person => $person, record => $event }) .
									' ' . lcfirst($pronoun) .
									' arrived' .
									place({ person => $person, record => $event }));
							}
							$end_of_sentence = 0;
						}
						$previous = undef;
					} elsif(my $place = place({ person => $person, record => $event })) {
						if(my $year = year({ person => $person, record => $event })) {
							if($place =~ /,/) {
								if($mentioned_military && !$end_of_sentence) {
									$bio .= '.';
									$end_of_sentence = 1;
								}
								if($phrase->length()) {
									push @phrases, $phrase;
									$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
									$phrase = Data::Text->new();
									@phrases = ();
								}
								if($end_of_sentence) {
									$bio .= ' ' . ucfirst($year);
								} else {
									$bio .= $year;
								}
								$phrase->set(' ' . ucfirst($year));
								if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
									$notes = lcfirst($notes);
									$bio .= " ($notes)";
									$phrase->append(" ($notes)");
								}
								$bio .= ' ' . lcfirst($pronoun) . ' ';
								$phrase->append(' ' . lcfirst($pronoun) . ' ');
								if($language eq 'French') {
									$bio .= "est arriv\N{U+00E9}";
									$phrase->append("est arriv\N{U+00E9}");
									if($sex eq 'F') {
										$bio .= 'e';
										$phrase->append('e');
									}
									$place =~ s/^ in//;
									$bio .= $place;
									$phrase->append($bio);
								} else {
									$bio .= "arrived$place";
									$phrase->append("arrived$place");
								}
							} else {	# Arriving in a country
								if($end_of_sentence) {
									$bio .= ' ';
								}
								$bio .= "$pronoun ";
								$phrase->append(' ') if(scalar(@phrases) == 0);
								$phrase->append("$pronoun ");
								if($language eq 'French') {
									$bio .= "est arriv\N{U+00E9}";
									$phrase->append("est arriv\N{U+00E9}");
									if($sex eq 'F') {
										$bio .= 'e';
										$phrase->append('e');
									}
									$bio .= " \N{U+00E0}";
									$phrase->append(" \N{U+00E0}");
									$place =~ s/^ in//;
									$bio .= $place;
									$phrase->append($place);
								} else {
									$bio .= "arrived$place";
									$phrase->append("arrived$place");
								}
								$bio .= " $year";
								$phrase->append(" $year");
								if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
									$notes = lcfirst($notes);
									$bio .= " ($notes)";
									$phrase->append(" ($notes)");
								}
							}
						} else {
							complain({ person => $person, warning => "Can't determine $type date" });

							$bio .= "arrived$place";
							$phrase->append("arrived$place");
						}
					} else {
						complain({ person => $person, warning => "Can't determine $type location" });
					}
					if(my $notes = notes({ record => $event, note_locations => \@note_locations })) {
						$notes = lcfirst($notes);
						$bio =~ s/\s$//;
						$bio .= " ($notes)";
						$phrase->rtrim()->append(" ($notes)");
					}
					$bio .= '.';
					$end_of_sentence = 1;

					if(defined($phrase) && ($phrase->length() > 0)) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
						print Data::Dumper->new([\@phrases])->Dump() if($opts{'v'});
						$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
						undef @phrases;
					}
				} elsif($type eq 'Departure') {
					if(!defined($event->place())) {
						complain({ person => $person, warning => 'Departure record without destination' });
						next;
					}
					if(my $e = $events[$index]) {
						if(ref($e) && defined($e->type()) && ($e->type() eq 'Arrival') && $event->date() && $e->date()) {
							$previous = $event;
							$prev_type = $event->type();
							# FIXME: not all locations will be noted or notes printed
							next;
						}
					}
					if($previous) {
						if($prev_type eq 'Arrival') {
							$bio .= journey({ person => $person, arrival => $event, departure => $previous });
							$phrase->append(journey({ person => $person, arrival => $event, departure => $previous }));
						}
						$previous = undef;
					} else {
						$bio .= ucfirst(i18n($person->pronoun()));
						$phrase->append(ucfirst(i18n($person->pronoun())));

						if($ENV{'LANG'} =~ /^en_US/) {
							$bio .= ' traveled';
							$phrase->append(' traveled');
						} elsif($language eq 'French') {
							$bio .= " a voyag\N{U+00E9}";
							$phrase->append(" a voyag\N{U+00E9}");
						} else {
							$bio .= ' travelled';
							$phrase->append(' travelled');
						}
						my $place = place({ person => $person, record => $event });
						if($language eq 'German') {
							$place =~ s/^\sin/ von/;
						} else {
							$place =~ s/^\sin/ from/;
						}
						if($event->date()) {
							$bio .= "$place " .
								year({ person => $person, record => $event });
							$phrase->append("$place " .
								year({ person => $person, record => $event }));
						} else {
							$bio .= $place;
							$phrase->append($place);
						}
					}
					if(my $notes = notes({ record => $event, note_locations => \@note_locations })) {
						$notes = lcfirst($notes);
						$bio =~ s/\s$//;
						$bio .= " ($notes)";
						$phrase->rtrim()->append(" ($notes)");
					}
					$bio .= '.';
					$end_of_sentence = 1;

					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
					$phrase = Data::Text->new();
					@phrases = ();
				} elsif($type eq 'Story') {
					if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
						if(!$end_of_sentence) {
							$bio .= '. ';
						}

						if($phrase->length()) {
							push @phrases, $phrase;
							$phrase = Data::Text->new();
						}
						if(scalar(@phrases)) {
							$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
							undef @phrases;

							# TODO:  Do this if the notes doesn't include a date
							# $notes =~ s/\.$//;
							# if(my $date = year(record => $event)) {
								# $bio .= ' ' . ucfirst($notes) . " $date. ";
							# } else {
								$bio .= ' ' . ucfirst($notes) . '. ';
								$bio_dt->append( ' ' . ucfirst($notes) . '. ');
							# }
							$end_of_sentence = 1;
						}
					}
				} elsif($type eq 'Court') {
					$bio .= '. ' if(!$end_of_sentence);
					$bio .= $firstname // $pronoun;

					if($phrase->length()) {
						push @phrases, $phrase;
					}
					if(scalar(@phrases)) {
						$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
						$phrase = Data::Text->new($firstname // $pronoun);
						@phrases = ();
					}

					if($language eq 'French') {
						$bio .= " a \N{U+00E9}t\N{U+00E9} au tribunal";
						$phrase->append(" a \N{U+00E9}t\N{U+00E9} au tribunal");
					} else {
						$bio .= ' appeared in court';
						$phrase->append(' appeared in court');
					}
					if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
						$bio .= $place;
						$phrase->append($place);
					}
					if(my $date = year(record => $event)) {
						$bio .= " $date";
						$phrase->append(" $date");
					}
					if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
						$notes = lcfirst($notes);
						$notes =~ s/\.$//;
						$bio .= " ($notes).";

						push @phrases, $phrase;
						$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append(" ($notes).");
						$phrase = Data::Text->new();
						@phrases = ();

						$end_of_sentence = 1;
					}
				} elsif($type eq 'Employment') {
					if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
						if($notes !~ /^household duties/i) {
							$notes =~ s/\.$//;
							$bio .= '.' if(!$end_of_sentence);
							$bio .= ' ';
							$bio .= $firstname // $pronoun;

							if($phrase->length()) {
								push @phrases, $phrase;
								$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
								$phrase = Data::Text->new();
								@phrases = ();
							} else {
								$bio_dt->append(' ');
							}

							my $employment;
							if(my $date = year(record => $event)) {
								if(scalar(@phrases) == 0) {
									$date = ucfirst($date);
								}
								$phrase->set("$date " . lcfirst($pronoun) . ' was working');
								$employment->{'date'} = year(record => $event, nopreposition => 1);
							} else {
								$phrase->set("$pronoun worked");
							}
							$phrase->append(" at $notes");
							$employment->{'notes'} = $notes;
							if(my $place = place(person => $person, record => $event)) {
								$phrase->append($place);
								$employment->{'place'} = place({ person => $person, record => $event, nopreposition => 1, places_printed => \% places_printed });
							}
							push @phrases, $phrase;
							$bio .= ' ' . $phrase->as_string();
							$phrase = Data::Text->new();
							$end_of_sentence = 0;
							push @{$parse_tree->{'employments'}}, $employment;
						}
					}
				} elsif($type eq 'Newspaper') {
					next;	# handled earlier
				} elsif($type eq 'Newspaper Death Notice') {
					# More non-standard FMP stuff
					# TODO - difficult to handle because the field is broken
					my $newspaper = newspaper({ gedcom => $ged, person => $person, event => $event });
					complain({ person => $person, warning => 'Ignoring Newspaper Death Notice from ' . $newspaper->date() });
				} elsif($type eq 'Funeral') {
					$funeral = $event;
				} elsif($type eq 'Custom Marriage') {
					die 'BUG: ', $person->as_string(), ' missed custom marriage' if(!defined($marriage));
				} elsif($type eq 'Email') {
					# The person's e-mail address is in $event->value()
					next;
				# } elsif(($type !~ /^Census U[KS] \d{4}$/) &&
				} elsif(($type !~ /Census/) &&
					($type ne 'Register UK 1939') &&
					($type ne 'Race') &&
					($type ne 'Hospitalisation')) {
					complain({ person => $person, warning => "Unhandled event type: $type" });
					# die 'TODO: ', $person->as_string({ nee => 1, include_years => 1, middle_names => 1 }), " event type $type";
					# TODO: How do I get the WWW information from this?
					# 1 EVEN
					# 2 TYPE Feb 1, 1957 The Cumberland News
					# 2 DATE 1 Feb 1957
					# 2 PLAC Cumberland, Maryland
					# 2 SOUR @S1376455579@
					# 3 PAGE Feb 1, 1957 The Cumberland News 1 Feb 1957
					# 3 DATA
					# 4 WWW https://www.newspapers.com/clip/20559043/feb_1_1957_the_cumberland_news/?xid=637
					# 3 OBJE @O163@
					# 2 OBJE @O163@

					my $notes = $type;
					if(my $n = notes(record => $event, note_locations => \@note_locations)) {
						$n =~ s/[\s\.]+$//;
						$notes = "$type: $n";
					}
					my $date = year(record => $event);
					$bio =~ s/\s$//;
					if($end_of_sentence) {
						if($date) {
							$bio .= ' ' . ucfirst($notes) . " $date. ";
						} else {
							$bio .= ' ' . ucfirst($notes) . '. ';
						}
					} else {
						$notes = lcfirst($notes);
						if($date) {
							$bio .= " ($date, $notes)";
						} else {
							$bio .= " ($notes)";
						}
						$end_of_sentence = 0;
					}
					if($phrase->rtrim()->length()) {
						$notes = lcfirst($notes);
						if($date) {
							$phrase->append(" ($date, $notes)");
						} else {
							$phrase->append(" ($notes)");
						}
					} else {
						if($date) {
							$phrase->set(' ' . ucfirst($notes) . " $date");
						} else {
							$phrase->set(' ' . ucfirst($notes));
						}
					}

					# Try hard to get some information
					my @objects = $event->obje();
					foreach my $o(@objects) {
						# If there's a hyperlink in the object, honour that
						my $obje;
						if($o->isa('Gedcom::Record')) {
							$obje = $o;	# e.g. Ancestry
						} else {
							$obje = $ged->resolve_xref($o);	# e.g. FMP
						}
						next if(!defined($obje));
						next if(!ref($obje));
						my $title = $obje->file->title();
						foreach my $item($obje->items()) {
							next if($item->tag() ne '_ORIG');
							foreach my $item2($item->items()) {
								next if($item2->tag() ne '_URL');
								my $link = ' - <a href="' .
									$item2->value() .
									"\">$title</a>";
								$bio .= $link;
								$phrase->append($link);
								last;
							}
						}

						# If there's a location in the object, add that to the known locations
						if((my $place = $obje->place()) && (my $date = $obje->date())) {
							my $dt = date_to_datetime($date);
							my $strftime = $dt->strftime('%x');
							my $year = $dt->year();
							$year =~ s/^0+//;	# Strip leading zeros
							if(my $location = get_location($place)) {
								push @{$all_locations{$year}}, {
									'record' => $obje,
									'person' => $person,
									'date' => $strftime,
									'latitude' => $location->lat(),
									'longitude' => $location->long(),
									'location' => $location
								};
								# Add it to the map of where a person has been
								$place_records{"$title: " . year({ person => $person, string => $date })} = $obje;
								warn "DEBUGGING: '$title': object has a location: $place";
							}
						}
					}
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
					$phrase = Data::Text->new();
					@phrases = ();
				}
			}
		}
		if($bio) {
			$bio .= '.' if(!$end_of_sentence);
			$end_of_sentence = 1;
		}
		if($phrase->length()) {
			push @phrases, $phrase;
		}
		if(scalar(@phrases)) {
			$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
			$phrase = Data::Text->new();
			@phrases = ();
		}
	}

	if(my $profile_object = $person->tag_record('_MILT')) {
		# Ancestry does this, FMP stores military records as events
		# $person->resolve_xref($profile_object->value());
		if(my $value = $profile_object->get_value()) {
			$bio .= '.' if(!$end_of_sentence);
			$value =~ s/[\s\.]+$//;
			$bio .= " $pronoun served in the military ($value).";
			$end_of_sentence = 1;

			if($phrase->length()) {
				push @phrases, $phrase;
				$phrase = Data::Text->new();
			}
			if(scalar(@phrases)) {
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				@phrases = ();
			}
			$bio_dt->append(" $pronoun served in the military ($value).");
		}
	}

	if($person->tag_record('EVEN.MRRGNOTICE')) {
		die 'TODO: handle FMP marriage notice'
	}
	if($person->tag_record('EVEN.RESIDENCEFAMILY')) {
		die 'TODO: handle FMP family residence'
	}

	if($placeofburial && $dateofburial && !$place_records{'Burial'}) {
		$place_records{'Burial'} = $burial;
	}
	if($funeral && $funeral->place()) {
		$place_records{'Funeral'} = $funeral;
		if((!defined($dateofburial)) && (!defined($dateofcremation))) {
			complain({ person => $person, warning => 'Taking details of burial from funeral record' });
			$dateofburial = $funeral->date();
			$placeofburial = $funeral->place();
		}
	}

	if($placeofburial || $dateofburial || $placeofcremation || $dateofcremation) {
		if(defined($dateofdeath) && (!defined($dateofburial)) && (!defined($dateofcremation))) {
			complain({ person => $person, warning => "Adding date of burial as 'aft $dateofdeath'" });
			if($placeofburial) {
				$dateofburial = "aft $dateofdeath";
			} else {
				$dateofcremation = "aft $dateofdeath";
			}
		}
		if((!$dateofdeath) && !$placeofdeath) {
			$bio .= '.' if((!$end_of_sentence) && (scalar(@spouses) || $numberofchildren));
			if($phrase->length()) {
				push @phrases, $phrase;
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('. ');
				$phrase = Data::Text->new();
				@phrases = ();
			}
			$end_of_sentence = 1;

			my $type = 'burial';
			if($placeofcremation || $dateofcremation) {
				$type = 'cremation';
			}
			if($dateofburial) {
				$end_of_sentence = 0;
				$bio .= $firstname // $pronoun;
				if((scalar(@phrases) == 0) && ($phrase->length() == 0)) {
					$phrase->set(text => $firstname // $pronoun);
				}
				$bio .= ($type eq 'burial') ? i18n({ person => $person, format => ' was buried' }) : 'was cremated';
				$phrase->append(($type eq 'burial') ? i18n({ person => $person, format => ' was buried' }) : ' was cremated');
				$bio .= year({ person => $person, date => $dateofburial });
				$phrase->append(year({ person => $person, date => $dateofburial }));

				# Neither burial nor cremation could be set if we guessed information from the funeral
				if(($burial || $cremation) && (my $city = ($placeofburial // $placeofcremation))) {
					if($placeofbirth && places_are_the_same(first => $city, second => $placeofbirth)) {
						if($burial) {
							if(my $address = $burial->address()) {
								$bio .= " at $address";
								$phrase->append(" at $address");
								$parse_tree->{'burial'}->{'address'} = $address;
							}
						} elsif(my $address = $cremation->address()) {
							$bio .= " at $address";
							$phrase->append(" at $address");
							$parse_tree->{'cremation'}->{'address'} = $address;
						}
						$bio .= ' in ' .
							lcfirst($person->possessive()) .
							' home town of ';
						$phrase->append(' in ' .
							lcfirst($person->possessive()) .
							' home town of ');
						$parse_tree->{$type}->{'hometown'} = 1;
						if($city =~ /^(.+?),/) {
							$bio .= $1;
							$phrase->append($1);
							$parse_tree->{$type}->{'place'} = $1;
						} else {
							my $opts = {
								person => $person,
								there => $placeofdeath,
								places_printed => \%places_printed,
								must_postdate => $birth_dt
							};
							if($type eq 'burial') {
								$opts->{'place'} = $placeofburial;
								if(my $address = $burial->address()) {
									$opts->{'address'} = $address;
								}
							} else {
								$opts->{'place'} = $placeofcremation;
								if(my $address = $cremation->address()) {
									$opts->{'address'} = $address;
								}
							}
							$bio .= place($opts);
							$phrase->append(place($opts));
							$parse_tree->{$type}->{'place'} = place(place => $city);
						}
					} else {
						$bio .= place({
							person => $person,
							place => $placeofburial // $placeofcremation,
							there => $placeofdeath,
							places_printed => \%places_printed,
							must_postdate => $birth_dt
						});
						$phrase->append(place({
							person => $person,
							place => $placeofburial // $placeofcremation,
							there => $placeofdeath,
							places_printed => \%places_printed,
							must_postdate => $birth_dt
						}));
					}
				}
				my $record;
				if($type eq 'burial') {
					$bio .= ' ' . year({ person => $person, date => $dateofburial });
					$phrase->append(' ' . year({ person => $person, date => $dateofburial }));
					$record = $burial;
					$parse_tree->{'burial'}->{'date'} = year({ date => $dateofburial });
				} else {
					$bio .= ' ' . year({ person => $person, date => $dateofcremation });
					$phrase->append(' ' . year({ person => $person, date => $dateofcremation }));
					$record = $cremation;
					$parse_tree->{'cremation'}->{'date'} = year({ date => $dateofcremation });
				}
				if(my $n = notes({ record => $record, paragraph => 0, note_locations => \@note_locations })) {
					$n =~ s/\.$//;
					$n =~ tr/\r//;
					$bio .= " ($n)";
					$phrase->append(" ($n)");

					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
					$phrase = Data::Text->new();
					@phrases = ();
				}
			} elsif($placeofbirth && places_are_the_same(first => $placeofburial, second => $placeofbirth)) {
				$bio .= "$pronoun ";
				$bio .= i18n({ person => $person, format => 'was buried' });
				$phrase->append(" $pronoun ")->append(i18n({ person => $person, format => 'was buried' }));
				if(my $address = $burial->address()) {
					if($language eq 'French') {
						$bio .= " \N{U+00E0} $address";
						$phrase->append(" \N{U+00E0} $address");
					} else {
						$bio .= " at $address";
						$phrase->append(" at $address");
					}
				}
				$bio .= ' in ' . lcfirst($person->possessive()) .
					' home town of ';
				$phrase->append(' in ' . lcfirst($person->possessive()) .
					' home town of ');
				my $city = $placeofburial;
				if($city =~ /^(.+?),/) {
					$bio .= $1;
					$phrase->append($1);
				} else {
					$bio .= place({ person => $person, place => $placeofburial });
					$phrase->append( place({ person => $person, place => $placeofburial }));
				}
			} else {
				$bio .= " $pronoun is buried" .
					place({ person => $person, record => $burial, places_printed => \%places_printed, there => $placeofmarriage });
				$phrase->append("$pronoun is buried" .
					place({ person => $person, record => $burial, places_printed => \%places_printed, there => $placeofmarriage }));
			}
			$bio .= '. ';
			$end_of_sentence = 1;

			if($phrase->length()) {
				push @phrases, $phrase;
			}
			if(scalar(@phrases)) {
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				$phrase = Data::Text->new();
				@phrases = ();
			}
		} else {	# $dateofdeath || $placeofdeath
			if((!$placeofburial) && !$diedathome) {
				$bio .= '. ' if(!$end_of_sentence);
				$end_of_sentence = 1;
			}
			if($phrase->trim()->length()) {
				push @phrases, $phrase;
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				$phrase = Data::Text->new();
				@phrases = ();
			}
			my $notes;
			if(!$diedathome) {
				$bio .= '.' if((!$end_of_sentence) && !$start_of_paragraph);
				if($phrase->length()) {
					push @phrases, $phrase;
					$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
					$phrase = Data::Text->new();
					@phrases = ();
				}

				$bio .= "<p>$pronoun" . i18n({ person => $person, format => ' died' });
				$phrase->set("<p>$pronoun" . i18n({ person => $person, format => ' died' }));

				$start_of_paragraph = 0;
				$end_of_sentence = 0;

				if($dateofdeath) {
					$bio .= ' ' . between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt }));
					$phrase->append(' ' . between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt })));
				}
				if($placeofdeath && (my $p = place({ person => $person, record => $death, places_printed => \%places_printed }))) {
					$bio .= $p;
					$phrase->append($p);
					$places_printed{$p} = 1;
				}
				$bio .= cite(@deathcitations);
				$phrase->append(cite(@deathcitations));

				# Cause of death
				if(my $cause = $person->cause()) {
					$cause = lc($cause);
					$bio .= " ($cause)";
					$phrase->append(" ($cause)");
				}

				# Print notes about the death, if any
				if($notes = notes({ person => $person, record => $death, note_locations => \@note_locations })) {
					$notes =~ tr/\r//;
					$notes =~ tr/\n/ /;
					$notes =~ s/\.$//;
					$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
					$bio .= " ($notes)";
					$phrase->append(" ($notes)");
				}

				$end_of_sentence = 0;
			}
			my $opts = {
				person => $person,
				place => $placeofburial,
				there => $placeofdeath,
				places_printed => \%places_printed,
				must_postdate => $birth_dt,
			};
			my $address;
			if($address = get_value({ person => $person, value => 'burial address' })) {
				$opts->{'address'} = $address;
			}

			my $type = 'burial';
			if($placeofcremation || $dateofcremation) {
				$type = 'cremation';
			}
			if($dateofburial) {
				if($diedathome) {
					$bio .= $pronoun;
					$phrase->append(" $pronoun ");
				} else {
					$bio .= i18n(' and');
					if($phrase->length()) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
				}
				if(($language eq 'French') && $placeofburial &&
				  defined($placeofdeath) && ($placeofburial eq $placeofdeath) && (!$address) && !$death->address()) {
					$bio .= ' y';
					$phrase->append(' y');
				}
				$bio .= i18n({ person => $person, format => ' was buried' });
				$phrase->append(i18n({ person => $person, format => 'was buried' }));
				if($placeofburial) {
					if(defined($placeofdeath) && ($placeofburial eq $placeofdeath) && !$death->address()) {
						$bio .= ' there';
						$phrase->append(' there');
						if($address) {
							if($language eq 'French') {
								$bio .= " \N{U+00E0} $address";
								$phrase->append(" \N{U+00E0} $address");
							} else {
								$bio .= " at $address";
								$phrase->append(" at $address");
							}
						}
					} else {
						$bio .= place($opts);
						$phrase->append(place($opts));
					}
				}
				my $must_postdate;
				if($death_dt) {
					$must_postdate = $death_dt;
				} elsif(!defined($dateofdeath)) {
					complain({
						person => $person,
						warning => 'Date of burial is known but not of death, suggest adding "Abt. YEAR"'
					});
				} elsif($dateofdeath =~ /^(Abt|ca?)\.?\s*(.+)/i) {
					my $d = $2;
					if($d !~ /^\d/) {
						$must_postdate = date_to_datetime("1 $d");
					} else {
						$must_postdate = date_to_datetime($d);
					}
				}
				my $record;
				if($type eq 'burial') {
					$bio .= ' ' . year({ person => $person, date => $dateofburial, must_postdate => $must_postdate });
					$phrase->append(' ' . year({ person => $person, date => $dateofburial, must_postdate => $must_postdate }));
					$record = $burial;
				} else {
					$bio .= ' ' . year({ person => $person, date => $dateofcremation, must_postdate => $must_postdate });
					$phrase->append(' ' . year({ person => $person, date => $dateofcremation, must_postdate => $must_postdate }));
					$record = $cremation;
				}
				if(defined($record)) {
					# Prefer burial date, but use funeral if that is available instead
					if($funeral &&
					   (!$record->date() || (datecmp($funeral->date(), $record->date()) == 0)) &&
					   (my $place = place({ person => $person, record => $funeral }))) {
						if(my $weather = weather({ person => $person, record => $funeral, meteo => $meteo })) {
							$phrase->append(" ($weather)");
							$bio .= " ($weather)";
							$parse_tree->{$type}->{'weather'} = $weather;
						}
						if($record->place() && ($funeral->place() eq $record->place())) {
							# Burial and funeral in the same town
							$place = i18n(' at ') . $funeral->address() if($funeral->address());
						}
						$phrase->append(' following ' .
							lcfirst($person->possessive()) .
							i18n(' funeral') .
							$place);
						$bio .= ' following ' .
							lcfirst($person->possessive()) .
							i18n(' funeral') .
							$place;
					} elsif(my $weather = weather({ person => $person, record => $record, meteo => $meteo })) {
						$phrase->append(" ($weather)");
						$bio .= " ($weather)";
						$parse_tree->{$type}->{'weather'} = $weather;
					}
				} elsif(my $weather = weather({ person => $person, record => $funeral, meteo => $meteo })) {
					# Funeral record, but no burial or cremation
					$phrase->append(" ($weather)");
					$bio .= " ($weather)";
				}
				if(my $b = notes({ person => $person, record => $burial // $cremation // $funeral, paragraph => 0, note_locations => \@note_locations })) {
					$b =~ s/\.$//;
					$b =~ tr/\r//;
					$bio .= " ($b)";
					$phrase->append(" ($b)");
				}
			} elsif($placeofdeath && $placeofburial && ($placeofburial eq $placeofdeath) &&
			   $burial->address() && !$death->address()) {
				if($end_of_sentence) {
					$bio .= $pronoun;
					$phrase->append($pronoun);
				} else {
					$bio .= i18n(' and');
					$phrase->append(i18n(' and'));
				}
				if($language eq 'French') {
					$bio .= " est y enterr\N{U+00E9}";
					$phrase->append(" est y enterr\N{U+00E9}");
					if($sex eq 'F') {
						$bio .= 'e';
						$phrase->append('e');
					}
					$bio .= " \N{U+00E0} " . $burial->address();
					$phrase->append(" \N{U+00E0} " . $burial->address());
				} else {
					$bio .= ' is buried there at ' . $burial->address();
					$phrase->append(' is buried there at ' . $burial->address());
				}
			} elsif(my $b = place($opts)) {
				if($diedathome) {
					$bio .= " $pronoun ";
				} else {
					$bio .= i18n(' and ');
				}
				if($phrase->length()) {
					push @phrases, $phrase;
					$phrase = Data::Text->new();
				} else {
					$phrase->set(" $pronoun ");
				}

				my $weather;
				if($type eq 'burial') {
					if($dateofburial) {
						$bio .= i18n({ person => $person, format => 'was buried' });
						$phrase->append(i18n({ person => $person, format => 'was buried' }));
					} else {
						$bio .= i18n({ person => $person, format => 'is buried' });
						$phrase->append(i18n({ person => $person, format => 'is buried' }));
					}
					if($b eq ' there') {
						if($b = $burial->address()) {
							$bio .= i18n(' at ')->append($b);
							$phrase->append(i18n(' at '))->append($b);
						}
						$bio .= ' ';
						$phrase->append(' ');
					} else {
						$bio .= "$b ";
						$phrase->append("$b ");
					}
					if($dateofburial) {
						$bio .= year({ person => $person, date => $dateofburial });
						$phrase->append(year({ person => $person, date => $dateofburial }));
					}
					$weather = weather({ person => $person, record => $burial, meteo => $meteo });
				} else {
					$bio .= "was cremated$b";
					$phrase->append("was cremated$b");
					if($b eq ' there') {
						if($b = $cremation->address()) {
							$bio .= i18n(' at ')->append($b);
							$phrase->append(i18n(' at '))->append($b);
						}
					}
					if($b eq ' there') {
						if($b = $cremation->address()) {
							$bio .= i18n(' at ')->append($b);
							$phrase->append(i18n(' at '))->append($b);
						}
						$bio .= ' ';
						$phrase->append(' ');
					} else {
						$bio .= "$b ";
						$phrase->append("$b ");
					}
					if($dateofcremation) {
						$bio .= ' ' . year({ person => $person, date => $dateofcremation });
						$phrase->append(' ' . year({ person => $person, date => $dateofcremation }));
					}
					$weather = weather({ person => $person, record => $cremation, meteo => $meteo });
				}
				if(defined($weather)) {
					$bio .= " ($weather)";
					$phrase->append(" ($weather)");
				}
			}

			if($notes && (length($notes) > 160)) {
				$bio .= ".</p><p>";
				$end_of_sentence = 1;

				push @phrases, $phrase;
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.</p><p>');
				$phrase = Data::Text->new();
				@phrases = ();
			} else {
				$end_of_sentence = 0;
			}
		}
		$bio .= cite(@burialcitations);
		$phrase->append(cite(@burialcitations));
	} elsif(($placeofdeath || $dateofdeath) && !$diedathome) {
		# TODO - extract marriage banns information
		# if($person->marriage_bann()) {
			# die 'foo';
		# }
		if($placeofdeath && (scalar(@spouses) <= 1) && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && (scalar(@events) == 0)) {
			if($language eq 'French') {
				if($end_of_sentence) {
					$bio .= " C'est";
				} else {
					$bio .= ', qui est';
				}
				if(scalar(@phrases) == 0) {
					$phrase->set(" C'est");
				} else {
					if($phrase->length()) {
						push @phrases, $phrase;
						$phrase = Data::Text->new();
					}
					$phrase->set('qui est');
				}
				$bio .= " aussi o\N{U+00F9} " . lcfirst($pronoun);
				$phrase->append(" aussi o\N{U+00F9} " . lcfirst($pronoun));
			} else {
				if($end_of_sentence) {
					$bio =~ s/\s$//;
					$bio .= ' That';
				} else {
					$bio .= ', which';
				}
				if(scalar(@phrases) == 0) {
					$phrase->set('That');
				} else {
					$phrase->append(', which');
				}
				$bio .= ' is also where ' . lcfirst($pronoun);
				$phrase->append(' is also where ' . lcfirst($pronoun));
			}
		} else {
			$bio .= '.' if((!$end_of_sentence) && !$start_of_paragraph);
			$bio .= "<p>$pronoun";

			if($phrase->length()) {
				push @phrases, $phrase;
			}
			if(scalar(@phrases)) {
				$bio_dt->append(conjunction(map { $_->as_string() } @phrases))->append('.');
				$phrase = Data::Text->new();
				@phrases = ();
			}
			$phrase->append("<p>$pronoun");
		}
		$bio .= i18n({ person => $person, format => ' died' });
		$phrase->append(i18n({ person => $person, format => ' died' }));

		if($dateofdeath) {
			if($dateofbirth && ($dateofdeath eq $dateofbirth)) {
				$bio .= i18n(' on the same day');
				$phrase->append(i18n(' on the same day'));
			} elsif($placeofdeath && $placeofmarriage && (scalar(@spouses) == 1) && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
				$bio .= ' ' . between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt }));
				$phrase->append(' ' . between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt })));
				if((scalar(@events) > 0) && (my $place = place({ person => $person, record => $death, places_printed => \%places_printed }))) {
					# Place hasn't already been printed with "that is also where she died"
					$phrase->append($place);
					$bio .= $place
				}
			} elsif($placeofbirth && $placeofdeath && ($placeofdeath eq $placeofbirth) && ($placeofdeath =~ /^(.+?),.*/) && !$printed_residence) {
				my $p = $1;
				if($dateofdeath =~ /\s$/) {
					complain({ person => $person, warning => 'Removing trailing spaces from date of death' });
					$dateofdeath =~ s/\s+$//;
				}
				$bio .= " in $p " .
					year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
				$phrase->append(" in $p " .
					year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt }));
			} else {
				if($dateofdeath =~ /\s$/) {
					complain({ person => $person, warning => "Removing trailing spaces from date of death '$death'" });
					$dateofdeath =~ s/\s+$//;
				}
				$bio .= ' ' . between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt }));
				$phrase->append(' ' . between(year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt })));
				if($placeofdeath && ((scalar(@spouses) > 1) || (!$placeofmarriage) || ($placeofdeath ne $placeofmarriage) || $printed_residence)) {
					my $place = place({ person => $person, record => $death, places_printed => \%places_printed });
					if(!defined($place)) {
						$place = place({ person => $person, place => $placeofdeath, places_printed => \%places_printed });
					}
					if(defined($place)) {
						if($place eq ' in , , ') {
							complain({ person => $person, warning => 'Assuming place of death is unknown' });
							$place = undef;
						} elsif($place =~ /[\,;]\s*$/) {
							complain({ person => $person, warning => "Removing trailing spaces from '$place'" });
							$place =~ s/[\,;]\s*//g;
						}
					}
					if(defined($place)) {
						$bio .= $place;
						$phrase->append($place);
						if($place =~ /\s\d+\s/) {
							foreach my $child(@children) {
								my @cr = get_all_residences(person => $child);
								foreach my $cr(@cr) {
									if(my $d = $cr->date()) {
										next if($d ne $dateofdeath);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($place =~ /^\s\d/) && (my $cp = place({ person => $child, record => $cr }))) {
											if($cp eq $place) {
												$bio .= i18n(' when ') . lcfirst($person->pronoun()) .
													' was living with ' . lcfirst($person->possessive()) .
													i18n('child ') . $child->as_string();
												$phrase->append(i18n(' when ') . lcfirst($person->pronoun) .
													' was living with ' . lcfirst($person->possessive()) .
													i18n('child ') . $child->as_string());
												last;
											}
										}
									}
								}
							}
							# FIXME: handle when living with both parents
							if($father) {
								my @fr = get_all_residences(person => $father);
								foreach my $fr(@fr) {
									if(my $d = $fr->date()) {
										next if($d ne $dateofdeath);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($place =~ /^\s\d/) && (my $fp = place({ person => $father, record => $fr }))) {
											if($fp eq $place) {
												$bio .= i18n(' when ') . lcfirst($person->pronoun()) .
													' was living with ' . lcfirst($person->possessive()) .
													i18n('father ') . $father->as_string();
												$phrase->append(i18n(' when ') . lcfirst($person->pronoun) .
													' was living with ' . lcfirst($person->possessive()) .
													i18n('father ') . $father->as_string());
												last;
											}
										}
									}
								}
							}
							if($mother) {
								my @mr = get_all_residences(person => $mother);
								foreach my $mr(@mr) {
									if(my $d = $mr->date()) {
										next if($d ne $dateofdeath);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($place =~ /^\s\d/) && (my $mp = place({ person => $mother, record => $mr }))) {
											if($mp eq $place) {
												$bio .= i18n(' when ') . lcfirst($person->pronoun()) .
													' was living with ' . lcfirst($person->possessive()) .
													i18n('mother ') . $mother->as_string();
												$phrase->append(i18n(' when ') . lcfirst($person->pronoun()) .
													' was living with ' . lcfirst($person->possessive()) .
													i18n('mother ') . $mother->as_string());
												last;
											}
										}
									}
								}
							}
							foreach my $sibling(@siblings) {
								my @sr = get_all_residences(person => $sibling);
								foreach my $sr(@sr) {
									if(my $d = $sr->date()) {
										next if($d ne $dateofdeath);

										# Compare only if full addresses to prevent
										# false positives when only a city is known
										if(($place =~ /^\s\d/) && (my $sp = place({ person => $sibling, record => $sr }))) {
											if($sp eq $place) {
												$bio .= i18n(' when ') . lcfirst($pronoun) .
													' was living with ' . lcfirst($person->possessive()) .
													i18n(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
													$sibling->as_string();
												$phrase->append(i18n(' when ') . lcfirst($pronoun) .
													' was living with ' . lcfirst($person->possessive()) .
													i18n(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
													$sibling->as_string());
												last;
											}
										}
									}
								}
							}
						}
					} else {
						complain({
							person => $person,
							warning => "Place of death ($placeofdeath) can't be parsed"
						});
					}
				}
			}
		} elsif((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage)) {
			my $place = place({ person => $person, place => $placeofdeath });
			if($place =~ /[\,;]\s*$/) {
				complain({ person => $person, warning => "Removing trailing spaces from '$place'" });
				$place =~ s/[\,;]\s*//g;
			}
			$bio .= $place;
			$phrase->append($place);
		}
		$bio .= cite(@deathcitations);
		$phrase->append(cite(@deathcitations));

		# Cause of death
		if(my $cause = $person->cause()) {
			$cause = lc($cause);
			$bio .= " ($cause)";
			$phrase->append(" ($cause)");
		}

		# Print notes about the death, if any
		if(defined($death) && (my $notes = notes({ person => $person, record => $death, paragraph => 0, note_locations => \@note_locations }))) {
			$notes =~ tr/\r//;
			$notes =~ s/\.$//;
			$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
			$bio .= " ($notes)";
			$phrase->append(" ($notes)");
			if(length($notes) > 160) {
				$bio .= '.</p><p>';

				push @phrases, $phrase;
				my $str = conjunction(map { $_->as_string() } @phrases);
				$bio_dt->append($str)->trim();
				if($str !~ /\.\s+$/) {
					$bio_dt->append('.');
				}
				$bio_dt->append('</p><p>');
				$phrase = Data::Text->new();
				@phrases = ();
			}
		}
		if($bio =~ /\."?$/) {
			$end_of_sentence = 1;
		} else {
			$end_of_sentence = 0;
		}
	}
	$bio .= '.' if(!$end_of_sentence);

	if($phrase->length()) {
		push @phrases, $phrase;
	}
	if(scalar(@phrases)) {
		# GitHub#127 - Don't put consecutive periods when a county ends with one, e.g. 'Los Angeles Co.'
		my $str = conjunction(map { $_->as_string() } @phrases);
		$bio_dt->append($str)->trim();
		if($str !~ /\.\s*$/) {
			$bio_dt->append('.');
		}
		$phrase = undef;
		@phrases = ();
	}

	if(($language eq 'English') && $bio_dt->length()) {
		if($ENV{'LANG'} =~ /^en_US/) {
			$bio = Lingua::EN::ABC::b2a($bio);
			$bio_dt->set(Lingua::EN::ABC::b2a($bio_dt->as_string()));
		} elsif($ENV{'LANG'} =~ /^en_CA/) {
			$bio = Lingua::EN::ABC::b2c($bio);
			$bio_dt->set(Lingua::EN::ABC::b2c($bio_dt->as_string()));
		} else {
			$bio = Lingua::EN::ABC::a2b($bio);
			$bio_dt->set(Lingua::EN::ABC::a2b($bio_dt->as_string()));
		}
	}

	print $html wide_to_html({ string => $bio, keep_hrefs => 1 });
	$fullbio .= $bio;
	undef $bio;

# warn $bio_dt->as_string(), ">>>>>>>>>>>>>>>>$fullbio";
########################

	if($opts{'l'} || !$is_alive) {
		if(my $s = $bio_dt->as_string()) {
			# print $csv $bio;
			# utf8::decode($copy);
			print $csv wide_to_html({ string => $s, keep_hrefs => 1 });
			# utf8::decode($s);
			$s = wide_to_xml($s);
			$s =~ s/\s\s+/ /g;
			$both_xmls->print($s);
		}
		$both_xmls->print("\n\t\t\t</en>\n\t\t</bio>");
	}
	print $csv '!';

	if($opts{'l'} || !$is_alive) {
		print "Create parents\n" if($opts{'v'});
		print $html '</p>';
		if($mother || $father) {
			print $html "<h2>Parents</h2><ol>";
			if($father && (my $f = person_line_html({ person => $father, year => $year }))) {
				print $html "<li>$f</li>";
				print $csv person_line_csv({ person => $father, year => $year });
				$both_xmls->print("\n\t\t<father>\n\t\t\t<xref>")
					->print($father->xref())
					->print('</xref>');
				if(my $given_names = given_names($father)) {
					if(length($given_names)) {
						$both_xmls->print("\n\t\t\t<first_name>")
							->print(wide_to_xml($given_names))
							->print('</first_name>');
					}
				}
				$both_xmls->print("\n\t\t\t<surname>")
					->print(wide_to_xml(normalize_name($father->surname())))
					->print("</surname>\n\t\t</father>");
			}
			print $csv '!';
			if($mother && (my $m = person_line_html({ person => $mother, year => $year }))) {
				print $html "<li>$m</li>";
				print $csv person_line_csv({ person => $mother, year => $year });
				$both_xmls->print("\n\t\t<mother>\n\t\t\t<xref>")
					->print($mother->xref())
					->print('</xref>');
				if(my $given_names = given_names($mother)) {
					if(length($given_names)) {
						$both_xmls->print("\n\t\t\t<first_name>")
							->print(wide_to_xml($given_names))
							->print('</first_name>');
					}
				}
				$both_xmls->print("\n\t\t\t<surname>")
					->print(wide_to_xml(normalize_name($mother->surname())))
					->print("</surname>\n\t\t</mother>");
			}
			print $html '</ol>';
		} else {
			print $csv '!';
		}
		print $csv '!';
		my $printed_children_header;

		my $c = '';
		foreach my $child(@children) {
			next if((!$opts{'l'}) && is_alive(person => $child));

			my $line = person_line_html({ person => $child, year => $year });
			next if($line eq '');
			if(!$printed_children_header) {
				print $html '<h2>Children</h2><ol>';
				$both_xmls->print("\n\t\t<children>");
				$printed_children_header = 1;
			}
			print $html "<li>$line</li>";
			$both_xmls->print("\n\t\t\t<child>\n\t\t\t\t<xref>")
				->print($child->xref())
				->print('</xref>');
			if(my $cdob = dateofbirth($child)) {
				if(my $cbirth_dt = date_to_datetime(date => $cdob)) {
					$both_xmls->print("\n\t\t\t\t<birth>")->print($cbirth_dt->strftime('%Y/%m/%d'))->print('</birth>');
				}
			}
			if(my $cdod = dateofdeath($child)) {
				if(my $cdeath_dt = date_to_datetime(date => $cdod)) {
					$both_xmls->print("\n\t\t\t\t<death>")->print($cdeath_dt->strftime('%Y/%m/%d'))->print('</death>');
				}
			}
			if(my $given_names = given_names($child)) {
				if(length($given_names)) {
					$both_xmls->print("\n\t\t\t\t<first_name>")
						->print(wide_to_xml($given_names))
						->print('</first_name>');
				}
			}
			$both_xmls->print("\n\t\t\t</child>");
			if(length($c)) {
				$c .= '----' . person_line_csv({ person => $child, year => $year });
			} else {
				$c = person_line_csv({ person => $child, year => $year });
			}
			if($opts{'w'} && ($birth_dt || $death_dt)) {
				my $dob = dateofbirth($child);
				if($dob && ($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
					if(my $d = date_parser_cached(date => $dob)) {
						$d = $dfn->parse_datetime($d->{'canonical'});
						if($birth_dt && ($d <= $birth_dt)) {
							complain({ person => $child, warning => 'born before parent was born' });
						}
						if(($sex eq 'F') && $death_dt && ($d > $death_dt)) {
							complain({ person => $child, warning => 'born after mother died' });
						} elsif(($sex eq 'M') && $death_dt && ($d > ($death_dt + $tenmonths))) {
							# Allow the child to be
							# born up to 9 months
							# after the death of the
							# father
							complain({ person => $child, warning => 'born more than 10 months after father died' });
						}
					}
				}
			}
		}
		if($printed_children_header) {
			print $html '</ol>';
			$both_xmls->print("\n\t\t</children>");
		}
		print $csv $c;
	} else {
		print $csv '!!';
	}

	print $csv '!';
	my $profile_image;
	my $profile_thumbnail;

	if($opts{'l'} || !$is_alive) {
		# Output the citations field
		if($opts{'c'} && $citationcount) {
			# TODO: add citations from dbpedia
			print "Create $citationcount citations\n" if($opts{'v'});
			print $html '<h2>Citations</h2><ol>';
			$both_xmls->print("\n\t\t<citations>");
			my $ufinder = URI::Find::Schemeless->new(sub {
				my($uri, $orig_uri) = @_;

				my $u = URI->new($orig_uri);
				if($u && (ref($u) ne 'URI::_generic')) {
					if((!$browser->head($orig_uri)) && !$browser->get($orig_uri)) {
						complain({ person => $person, warning => "$orig_uri: not found" });
					} else {
						$uri =~ s/:$//;
						return "<a href=\"$uri\">" .
							$u->host() .
							'</a>';
					}
				}
				return $orig_uri;
			});

			my %census_years;
			foreach my $index(1..$citationcount) {
				my $citation = $citations{$index};
				if(!$citation) {
					complain({
						person => $person,
						warning => "[$index]: empty citation"
					});
					next;
				}
				my $title = $citation->title();
				if(!defined($title)) {
					# For example, FMP 'web' source
					if($citation->items()) {
						my @items = $citation->items();
						# $Data::Dumper::Maxdepth = 2;
						# print Data::Dumper->new([\@items])->Dump();
						$title = $items[0]->{'value'};
					} elsif($citation->value()) {
						$title = $citation->value();
					} else {
						complain({
							person => $person,
							warning => "[$index]: no citation title"
						});
						$title = 'No citation title';
					}
				}
				utf8::decode($title);	# ACOM
				my $c;
				if(my $file = $citation->file()) {
					$c = "<a href=\"$file\">$title</a>";
				} else {
					if($title =~ /^https?:\/\//) {
						if($title =~ /^<a href=\"/) {
							$c .= $title;
						} else {
							$c = "<a href=\"$title\">$title</a>";
						}
					} else {
						$c = $title;
						if($title =~ /Census/) {
							if(my $census = $censusmaps{$title}) {
								# TODO: Add pointer to image
								$censuses{$census}->{$person->as_string(include_years => 1)} = $person;
							} elsif($title !~ /^Archive reference: RG/) {	# FMP has these
								complain({ person => $person, warning => "Add '$title' to censusmaps" });
							}
						}
					}
				}
				if(defined(my $publication = $citation->publication())) {
					utf8::decode($publication);	# Seems to be needed from ACOM publications
					$c .= ' ' . $publication;
					if(defined(my $continuation = $citation->cont())) {
						$c .= ' ' . $continuation;
					}
				}
				if(defined(my $page = $citation->page())) {
					$c .= ' ' . $page;
				}
				my @notes = $citation->note();
				foreach my $note(@notes) {
					if(ref($note) eq 'Gedcom::Record') {
						$note = $note->note();
					}

					if($note && ($note !~ /^This information comes from/)) {
						utf8::decode($note);	# ACOM
						$note = HTML::Entities::decode($note);
						if($note !~ /<a href="/i) {
							$ufinder->find(\$note);
						}
						$c .= ' (' . $note . ')' unless($note eq $title);
					}
				}
				if($citationnotes{$index}) {
					$citationnotes{$index} =~ s/\.$//;
					$c .= ' (' . $citationnotes{$index} . ')';
				}
				if(($title =~ /census/i) && ($title =~ /(\d{3,4})/)) {
					$census_years{$1} = $title;
				}

				$c =~ s/\R//g;	# Remove line breaks from the citations
				my $h = wide_to_html({ string => $c, keep_hrefs => 1 });

				# ACOM embeds these HTML codes in citations
				$h =~ s/<p>/ /g;
				$h =~ s/<\/p>//g;
				$h =~ s/<li>/ /g;
				$h =~ s/<\/li>//g;
				$h =~ s/\s\s+/ /g;

				print $csv '----' if($index > 1);
				print $csv $h;
				print $html "<li>$h</li>";
				$both_xmls->print("\n\t\t\t<citation>")
					->print(wide_to_xml($c))
					->print('</citation>');
			}
			print $html '</ol>';
			$both_xmls->print("\n\t\t</citations>");

			if($opts{'w'}) {
				# People alive during the years when censuses have been available must
				# have appeared in at least one census
				# FIXME:  should be a better test, e.g. catch people 1861-1930, don't
				#	catch 1862-1865.  The current test misses some but should have
				#	no false positives
				print "Checking for missing census entries\n" if($opts{'v'});
				if((defined($yob) && ($yob >= 1841) && ($yob <= 1921)) &&
				  ((defined($yod)) && ($yod >= 1841) && ($yod <= 1921)) &&
				  (($yod - $yob) >= 10) &&
				  (scalar(keys(%census_years)) == 0)) {
					complain({ person => $person, warning => 'Appears in no censuses' });
				}

				my %unused_censuses = %census_years;
				foreach my $residence(@residencelist) {
					if(my $rdate = $residence->date()) {
						if($rdate =~ /(\d{3,4})$/) {
							$rdate = $1;
							delete $unused_censuses{$1};
						}
					}
				}
				foreach my $year(sort keys %unused_censuses) {
					complain({
						person => $person,
						warning => "The census for the year $year has been cited, but its information has not been used as a residence"
					});
				}
				foreach my $event(@events) {
					if($event->can('type') && defined(my $type = $event->type())) {
						my $year;
						if($type =~ /^Census U[KS] (\d{4})$/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
						} elsif($type eq 'Register UK 1939') {
							if(!$event->date()) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
							$year = 1939;
						} elsif($type =~ /^(\d{4}) Census of Canada/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
							# Check Location includes Canada
							if(my $place = place({ person => $person, record => $event, nopreposition => 1 })) {
								if($place =~ /Canada$/i) {
									complain({ person => $person, warning => "Canadian census for $year doesn't list Canada as the location" });
								}
							} else {
								complain({ person => $person, warning => "Canadian census for $year doesn't list Canada as the location" });
							}
						} elsif($type eq 'Census') {
							if(my $date = $event->date()) {
								if($date =~ /(\d{4})$/) {
									$year = $1;
								}
							}
							if(!defined($year)) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
						} else {
							next;
						}
						$census_years{$year} = $type;
						if(defined($yod) && ($year > $yod)) {
							complain({ person => $person, warning => "Census for $year after year of death ($yod)" });
						} elsif(defined($yob) && ($year < $yob)) {
							complain({ person => $person, warning => "Census for $year before year of birth ($yob)" });
						}
					}
				}
				foreach my $year(sort { $a <=> $b } keys(%census_years)) {
					if($census_years{$year + 20} && !$census_years{$year + 10}) {
						# FIXME: the 1890 US Census was lost, don't error on that
						complain({
							person => $person,
							warning => 'Census information missing between ' . $census_years{$year} . ' and ' . $census_years{$year + 20}
						});
					}
				}
				if($dateofdeath && !defined($placeofdeath)) {
					complain({ person => $person, warning => 'Date of death is known, but not place' });
				} elsif($placeofbirth && $placeofdeath && $dateofdeath && (!$census_years{1939}) &&
				   (datecmp($dateofdeath, '1939') >= 0) && ($placeofbirth =~ /England$/) && ($placeofdeath =~ /England$/) &&
				   ((!$dateofbirth) || (datecmp($dateofbirth, '1939') <= 0))) {
					my $has1939 = 0;
					foreach my $residence(@residencelist) {
						if($residence->date() && ($residence->date() =~ /1939$/)) {
							$has1939 = 1;
							last;
						}
					}
					if(!$has1939) {
						complain({
							person => $person,
							warning => '1939 UK register information missing'
						});
					}
				}
				my $lastname = $surname;
				if(defined($sex) && ($sex eq 'F') && (my $husband = $person->husband())) {
					$lastname = $husband->surname();
				}
				if($yod && $firstname && $lastname) {
					my %opts = (
						date_of_death => $yod,
						firstname => $firstname,
						lastname => $lastname,
						ua => $browser,
					);
					if($placeofburial) {
						if($placeofburial =~ /.+,\s+(\w+)$/) {
							$opts{'country'} = $1;
						}
					} elsif($placeofdeath) {
						if($placeofdeath =~ /.+,\s+(\w+)$/) {
							$opts{'country'} = $1;
						}
					}
					if($opts{'country'} && ($opts{'country'} eq 'USA')) {
						$opts{'country'} = 'United States of America';
					}
					# foreach my $b(Genealogy::FindaGrave->new(\%opts)) {
					if(defined($grave_modules)) {
						if(ref($grave_modules)) {
							foreach my $m(@{$grave_modules}) {
								my $b = $m->new(\%opts);
								while(my $url = $b->get_next_entry()) {
									complain({
										person => $person,
										warning => "Possible burial link $url"
									});
								}
							}
						} elsif(my $b = $grave_modules->new(\%opts)) {
							while(my $url = $b->get_next_entry()) {
								complain({
									person => $person,
									warning => "Possible burial link $url"
								});
							}
						}
					}
				}
			}
		}

		print $csv '!';	# Separator between citations and notes fields

		# my $printed_notes;
		# if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 1 }))) {
			# print $html "<h2>Notes</h2>$notes";
			# $printed_notes = 1;
		# }

		# if($opts{'w'} && (my $dbpedia = dbpedia({ person => $person, birth_dt => $birth_dt, yob => $yob, yod => $yod, birth_country => $birth_country }))) {
		# }

		if(($person->get_value('note')) &&
		   (my $notes = notes({ person => $person, paragraph => 1, record => $person, note_locations => \@note_locations }))) {
			print "Handling notes\n" if($opts{'v'});
			# Don't use encode => 1 in the call to notes() because we do wide_to_html
			my $encoded_notes = HTML::Entities::encode($notes);
			$encoded_notes =~ s/&lt;p&gt;/<p>/g;	# avoid double encoding
			$encoded_notes =~ s/&lt;\/p&gt;/<\/p>/g;
			print $html '<h2>Notes</h2>', HTML::Entities::encode($notes);
			# No Need to to note_locations, it was just done
			print $csv wide_to_html({
				string => notes({ person => $person, paragraph => 1, record => $person, encode => 0 }),
				keep_hrefs => 1
			});
			$notes =~ s/^<p>//;
			$notes =~ s/<\/p>$//;
			$notes =~ s/<br>/<br \/>/g;
			$notes =~ s/<p><\/p>//g;
			$notes = wide_to_xml($notes);
			# $notes =~ s/</&lt;/g;
			# $notes =~ s/>/&gt;/g;
			$notes =~ s/\s*&excl;/!/g;
			$both_xmls->print("\n\t\t<note><p>$notes</p></note>");
			# print $html map { "<p>$_</p>" } @notes;
		}

		print $csv '!';

		# FIXME: Should be a table mapping from records to profiles
		my $s_profile_image;

		# print 'f:', $person->form() if($person->form());

		my @objlist = $person->obje();
		if(scalar(@objlist)) {
			print "Downloading objects\n" if($opts{'v'});
			# TODO - find primary and do something different with that
			#	The obje should be in order with primary first, but FMP
			#	doesn't do that
			#	Gedcom doesn't seem to be able to handle extra _ tags,
			#	or if it can I can't work out how to make use of it
			warn $person->{"_prof"}, "\n" if($person->{'_prof'});
			warn $person->{"prof"}, "\n" if($person->{'prof'});
			warn $person->{"_PROF"}, "\n" if($person->{'_PROF'});
			warn $person->{"PROF"}, "\n" if($person->{'PROF'});
			warn $person->{"_prim"}, "\n" if($person->{'_prim'});
			warn $person->{"prim"}, "\n" if($person->{'prim'});
			warn $person->{"_PRIM"}, "\n" if($person->{'_PRIM'});
			# warn $person->tag_records("PRIM"), "\n" if($person->tag_records('PRIM'));
			# warn $person->tag_records("_PRIM"), "\n" if($person->tag_records('_PRIM'));
			# warn $person->get_value("_prof"), "\n" if($person->get_value('_prof'));
			# warn $person->get_value("prof"), "\n" if($person->get_value('prof'));
			# warn $person->get_value("_PROF"), "\n" if($person->get_value('_PROF'));
			# warn $person->get_value("PROF"), "\n" if($person->get_value('PROF'));
			# warn $person->get_value("_prim"), "\n" if($person->get_value('_prim'));
			# warn $person->get_value("prim"), "\n" if($person->get_value('prim'));
			# warn $person->get_value("_PRIM"), "\n" if($person->get_value('_PRIM'));
			my $profile_object = $person->tag_record('_PROF');
			if($profile_object) {
				$profile_object = $person->resolve_xref($profile_object->value());
			}
			my $printed_media_header = 0;

			my %titlehistory;
			my %downloadhistory;

			# FIXME:  refactor - this code is horribly dense
			# Two passes, the first one where the links are pictures, the second where they are not
			for(my $pass = 1; $pass <= 2; $pass++) {
				print "Media pass $pass\n" if($opts{'v'});
				OBJE: foreach my $o(@objlist) {
					my $obje;
					if(ref($o) eq 'Gedcom::Record') {
						$obje = $o;	# e.g. Ancestry
					} else {
						$obje = $ged->resolve_xref($o);	# e.g. FMP
					}
					next if(!defined($obje));
					if(my $file = $obje->file()) {
						if(ref($file) eq 'Gedcom::Record') {
							# warn $file->tag(), "\n" if($file->tag());
							$file = $file->{'file'};
							next if($file eq '*');
						}
						if(!$printed_media_header) {
							print $html '<h2>Media</h2>';
							$both_xmls->print("\n\t\t<media>");
							$printed_media_header = 1;
						}

						warn $obje->{"_prim"}, "\n" if($obje->{'_prim'});
						warn $obje->{"prim"}, "\n" if($obje->{'prim'});
						warn $obje->{"_PRIM"}, "\n" if($obje->{'_PRIM'});
						warn $obje->{"PRIM"}, "\n" if($obje->{'PRIM'});
						warn $obje->{"_prof"}, "\n" if($obje->{'_prof'});
						warn $obje->{"prof"}, "\n" if($obje->{'prof'});
						warn $obje->{"_PROF"}, "\n" if($obje->{'_PROF'});
						warn $obje->{"PROF"}, "\n" if($obje->{'PROF'});
						warn $obje->{"_DATE"}, "\n" if($obje->{'_DATE'});
						warn $obje->{"_date"}, "\n" if($obje->{'_date'});
						# warn $obje->tag(), "\n" if($obje->tag());
						my $title = $obje->title() || $obje->tag_record('TITL', 1);
						if(defined($title)) {
							$title =~ s/\s\s+/ /g;
						}
						my $form = $obje->form();
						if((!$form) && $obje->items()) {
							# Family Tree Maker does this
							my @items = $obje->items();
							$file = $items[0]->{'value'};
							# TODO: Find the title
						}
						$file =~ s/\{0\}//g;
						$file =~ s/\r//g;
						if($opts{'d'} && ($file =~ /^https?:\/\//) && ($file !~ /\.jpe?g$/) && ($file !~ /ancestry.com.*image.*guid=/)) {
							$file =~ s/%2f/\//gi;

							my $localfile = 'static-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
							# FIXME: It should check if the remote image is newer than the local image
							if(!-r $localfile) {
								if($file =~ /^http:\/\/(\w+)\.findmypast\.(co[\w\.]+)\/(.+)/) {
									$file = "https://$1.findmypast.$2/$3";
								}

								if($downloadhistory{$file}) {
									# Ancestry does this
									print "Skip duplicate image $file\n" if($opts{'v'});
									next OBJE;
								}

								print "Download non-image $file\n" if($opts{'v'});
								my $resp = $cached_browser->get($file);
								if($resp->is_success() && ($resp->content_type() eq 'image/jpeg')) {
									next OBJE if($pass == 2);
									$downloadhistory{$file} = 1;
									my $key = $person->as_string() . ";$localfile";
									if($images{$key}) {
										# Flag a person having two images of the same
										# name
										complain({ person => $person, warning => "duplicate filename: $localfile" });
									}
									my $tmp;
									if($jpegtran) {
										open($tmp, '|-', "$jpegtran -progressive -outfile '$localfile'");
									} elsif($jpegoptim) {
										# jpegoptim 1.4.7 wants a filename even with the --stdin option
										open($tmp, '|-', "$jpegoptim -q --all-progressive --stdin /dev/null > '$localfile'");
									} else {
										open($tmp, '>', $localfile);
									}
									# FIXME: breaks with
									# use open qw(:std :utf8);
									print $tmp $resp->decoded_content();
									close $tmp;
									$form = 'JPG';
									$images{$key} = 1;
									if($^O eq 'MSWin32') {
										copy($localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg');
									} else {
										link $localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
										chmod 0444, $localfile;
									}
									print "File saved in $localfile\n" if($opts{'v'});
								} else {
									next OBJE if($pass == 1);
									$downloadhistory{$file} = 1;
								}
							}
						} elsif(($file =~ /^([A-Z]:[\/\\].+\.jpe?g+)/) || ($file =~ /^(\/.+\.jpe?g)/)) {
							next OBJE if($pass == 2);
							my $srcfile = $1;
							if(!-r $srcfile) {
								# Patch from github.com/cablespaghetti
								complain({ person => $person, warning => "$srcfile: file not found" });
								next OBJE;
							}
							my $localfile = 'static-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
							if(!-r $localfile) {
								if($jpegtran) {
									system("$jpegtran -progressive -outfile '$localfile' '$srcfile'");
								} elsif($jpegoptim) {
									copy($srcfile, $localfile);
									system("$jpegoptim -q --all-progressive '$localfile'");
								} else {
									copy($srcfile, $localfile);
								}
								if($^O eq 'MSWin32') {
									copy($localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg');
								} else {
									link $localfile, 'dynamic-site/img/' . make_filename_from_object(object => $obje) . '.jpg';
									chmod 0444, $localfile;
								}
							}
							$form = 'JPG';
							my $key = $person->as_string() . ";$localfile";
							$images{$key} = 1;
						}
						if($form && (lc($form) eq 'jpg')) {
							next OBJE if($pass == 2);
							if($title) {
								print "Process image $title\n" if($opts{'v'});
								next if($titlehistory{$title});
								my $escaped_title = wide_to_html($title);
								print $html "<h3>$escaped_title</h3>";
								$titlehistory{$title} = 1;
							} else {
								print "Process file with no title\n" if($opts{'v'});
								print $html '<br>';
							}
							if($opts{'d'}) {
								# Get and stash a local copy
								if($file =~ /ancestry.com.+guid=.+&tid=/) {
									# Ancestry's Gedcoms are broken, perhaps pointing to an old
									# location that they forgot to fix
									print "Map from $file\n" if($opts{'v'});
									if($file =~ /guid=([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/) {
										# FIXME: Ancestry pictures attached from another
										# tree aren't downloaded.  This URL will generate a
										# 404
										$file = "https://mediasvc.ancestry.com/v2/image/namespaces/1093/media/$1.jpg?client=Trees";
									} elsif($opts{'w'}) {
										complain({ person => $person, warning => "BUG: update ACOM mapping for $file" });
										next OBJE;
									}
								}
								if($file =~ /^http:\/\/(\w+)\.findmypast\.(co[\w\.]+)\/(.+)/) {
									$file = "https://$1.findmypast.$2/$3";
								}

								print "Download image $file\n" if($opts{'v'});
								my $localfile = 'img/' . make_filename_from_object(object => $obje) . '.jpg';
								my $rc;
								if((-r "static-site/$localfile") ||
								   LWP::Simple::WithCache::is_success($rc = LWP::Simple::WithCache::getstore($file, "static-site/$localfile"))) {
									my $info = Image::Info::image_info("static-site/$localfile");
									my ($w, $h) = Image::Info::dim($info);
									if(!defined($w)) {
										complain({ person => $person, warning => "Can't get image information for static-site/$localfile" });
										# unlink "static-site/$localfile";
										next OBJE;
									}
									$h *= 175 / $w;
									$h = int($h);
									# print $html "<a href=\"$file\" target=\"_blank\">",
									my $escaped_file = $localfile;
									$escaped_file =~ s/&/&amp;/g;
									if($title) {
										my $escaped_title = $title;
										$escaped_title =~ s/&/&amp;/g;
										print $html "<a href=\"$escaped_file\" target=\"_blank\">",
											'<img src="', $escaped_file, "\" alt=\"$escaped_title\" width=\"175\" height=\"$h\">",
											'</a>';
										print $csv "/$localfile---$title---$h----";
										$both_xmls->print("\n\t\t\t<image>\n\t\t\t\t<file>$escaped_file</file>\n\t\t\t\t<title>$escaped_title</title>\n\t\t\t\t<height>$h</height>\n\t\t\t</image>");
									} else {
										print $html "<a href=\"$localfile\" target=\"_blank\">",
											'<img src="', $localfile, "\" width=\"175\" height=\"$h\">",
											'</a>';
										print $csv "/$localfile--- ---$h----";
										$both_xmls->print("\n\t\t\t<image>\n\t\t\t\t<file>$escaped_file</file>\n\t\t\t\t<height>$h</height>\n\t\t\t</image>");
									}
									if(defined($profile_object) && ($obje eq $profile_object)) {
										$s_profile_image = "static-site/$localfile";
									}
									unless(-r "dynamic-site/$localfile") {
										if($^O eq 'MSWin32') {
											copy("static-site/$localfile", "dynamic-site/$localfile");
										} else {
											link "static-site/$localfile", "dynamic-site/$localfile";
										}
									}
								} else {
									red_warning({ person => $person, warning => "download $file failed to static-site/$localfile: $rc" });

									if($title) {
										print $html "<a href=\"$file\" target=\"_blank\">",
											"<img src=\"$file\" alt=\"$title\" width=\"175\">",
											'</a>';
										print $csv "$file---$title---0----";
										$title =~ s/&/&amp;/g;
										$both_xmls->print("\n\t\t<image><url>$file</url><title>$title</title></image>");
									} else {
										print $html "<a href=\"$file\" target=\"_blank\">",
											"<img src=\"$file\" width=\"175\">",
											'</a>';
										print $csv "$file--- ---0----";
										$both_xmls->print("\n\t\t<image><url>$file</url></image>");
									}
									if(defined($profile_object) && ($obje eq $profile_object)) {
										$s_profile_image = $file;
									}
								}
							} else {
								# Use the remote copy
								my $escaped_file = $file;
								$escaped_file =~ s/&/&amp;/g;
								if($title) {
									print $html "<a href=\"$escaped_file\" target=\"_blank\">",
										"<img src=\"$file\" alt=\"$title\" width=\"175\">",
										'</a>';
									print $csv "$file---$title---0----";
									$title =~ s/&/&amp;/g;
									$both_xmls->print("\n\t\t\t<image>\n\t\t\t\t<url>$escaped_file</url>\n\t\t\t\t<title>$title></title>\n\t\t\t</image>");
								} else {
									print $html "<a href=\"$file\" target=\"_blank\">",
										"<img src=\"$file\" width=\"175\">",
										'</a>';
									print $csv "$file--- ---0----";
									$both_xmls->print("\n\t\t\t<image>\n\t\t\t\t<url>$escaped_file</url></image>");
								}
								if(defined($profile_object) && ($obje eq $profile_object)) {
									$s_profile_image = $file;
								}
							}
						} else {
							next OBJE if($pass == 1);
							print "Process non-image $title\n" if($opts{'v'} && $title);
							my $escaped_file = $file;
							$escaped_file =~ s/&/&amp;/g;
							print $html "<a href=\"$escaped_file\" target=\"_blank\">",
								$title ? HTML::Entities::encode($title) : 'Media',
								'</a>';
							print $csv "$file---",
								$title ? HTML::Entities::encode($title) : 'Media',
								'---0----';
							if($file =~ /^https?:/) {
								$file = HTML::Entities::encode($file);
								if($title) {
									$title = HTML::Entities::encode($title);
									$title =~ s/&acirc;//g;
									$both_xmls->print("\n\t\t\t<image>\n\t\t\t\t<url>$file</url>\n\t\t\t\t<title>$title</title>\n\t\t\t</image>");
								} else {
									$both_xmls->print("\n\t\t\t<image>\n\t\t\t\t<url>$file</url>\n\t\t\t</image>");
								}
							} else {
								if($title) {
									$title = HTML::Entities::encode($title);
									$title =~ s/\xc3\xab/&#235;/g;	# eumlaut
									$both_xmls->print("\n\t\t\t<image>\n\t\t\t\t<file>$file</file>\n\t\t\t\t<title>$title</title>\n\t\t\t</image>");
								} else {
									$both_xmls->print("\n\t\t\t<image>\n\t\t\t\t<file>$file</file>\n\t\t\t</image>");
								}
							}
						}
						# if($obje->date()) {
							# die $obje->date();
						# }
						print $html '<br>';
					}
				}
			}
			if($printed_media_header) {
				$both_xmls->print("\n\t\t</media>");
			}
		}
		print $csv '!';

		if(defined($dot)) {
			print "Create family tree\n" if($opts{'v'});
			my $png = 'static-site/img/family-tree-' . $person->xref() . '.png';
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/bin/cat')) {
				# We're using UTF-8 for the graphviz encoding
				binmode($fout, ':utf8');

				# print $fout 'digraph family { graph [rankdir=LR];';
				print $fout 'digraph family {',
					' charset="UTF-8"',
					' subgraph parents { rank="min"; ';
				if($father) {
					print_graphviz({ person => $father, fout => $fout, format => 'static' });
				}
				if($mother) {
					print_graphviz({ person => $mother, fout => $fout, format => 'static' });
				}
				print $fout '} subgraph main { rank="same"; ';
				print_graphviz({ person => $person, fout => $fout, profile_image => $s_profile_image, format => 'static' });
				foreach my $spouse(@spouses) {
					print_graphviz({ person => $spouse, fout => $fout, format => 'static' });
				}
				print $fout '} subgraph children { rank="max"; ';
				# TODO: sort by date of birth
				foreach my $child(@children) {
					print_graphviz({ person => $child, fout => $fout, format => 'static' });
				}
				print $fout '} ';

				if($mother) {
					print $fout $mother->xref(), ' -> ', $person->xref(), ";\n";
				}
				if($father) {
					print $fout $father->xref(), ' -> ', $person->xref(), ";\n";
				}
				if(scalar(@spouses) == 2) {
					# Married twice, put the person in the middle,
					# it looks better
					# print $fout $person->xref(), ' -> ', $spouses[0]->xref(), " [dir=none];\n";
					print $fout $spouses[0]->xref(), ' -> ',
						$person->xref(), ' -> ',
						$spouses[1]->xref(), " [dir=none];\n";
				} else {
					foreach my $spouse(@spouses) {
						print $fout $person->xref(), ' -> ', $spouse->xref(), " [dir=none];\n";
						# print $fout $person->xref(), ' -> ', $spouse->xref(), " [dir=none];\n";
					}
				}
				foreach my $child(@children) {
					print $fout $person->xref(), ' -> ', $child->xref(), ";\n";
				}

				print $fout '}';
				# If you get an error that png isn't supported, run apt-get install graphviz-dev
				close $fout;

				print $html '<h2>Family Tree</h2>';
				my $filename = 'family-tree-' . $person->xref();
				my $dim = Image::Info::html_dim(Image::Info::image_info($png));
				print $html "<img src=\"img/$filename.png\" $dim", ' usemap="#family" alt="Family Tree">';
				$tmp->seek(0, SEEK_SET);
				foreach my $line(<$tmp>) {
					chomp $line;
					print $html $line;
				}
			}
			$png = 'dynamic-site/img/family-tree-' . $person->xref() . '.png';
			$tmp = File::Temp->new();
			$filename = $tmp->filename();
			binmode($tmp, ':utf8');
			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/bin/cat')) {
				# We're using UTF-8 for the graphviz encoding
				binmode($fout, ':utf8');

				# print $fout 'digraph family { graph [rankdir=LR];';
				# Best to agree with the colour in css/web.css
				# print $fout 'digraph family { bgcolor="#d6d6d6"',
				print $fout 'digraph family {',
					' charset="UTF-8"',
					' subgraph parents { rank="min"; ';
				if($father) {
					print_graphviz({ person => $father, fout => $fout, format => 'dynamic' });
				}
				if($mother) {
					print_graphviz({ person => $mother, fout => $fout, format => 'dynamic' });
				}
				print $fout '} subgraph main { rank="same"; ';
				$profile_image = $s_profile_image;
				if(defined($profile_image)) {
					$profile_image =~ s/static/dynamic/;
				}
				$profile_thumbnail = print_graphviz({ person => $person, fout => $fout, profile_image => $profile_image, format => 'dynamic' });
				foreach my $spouse(@spouses) {
					print_graphviz({ person => $spouse, fout => $fout, format => 'dynamic' });
				}
				print $fout '} subgraph children { rank="max"; ';
				# TODO: sort by date of birth
				foreach my $child(@children) {
					print_graphviz({ person => $child, fout => $fout, format => 'dynamic' });
				}
				print $fout '} ';

				if($mother) {
					print $fout $mother->xref(), ' -> ', $person->xref(), ";\n";
				}
				if($father) {
					print $fout $father->xref(), ' -> ', $person->xref(), ";\n";
				}
				if(scalar(@spouses) == 2) {
					# Married twice, put the person in the middle,
					# it looks better
					# print $fout $person->xref(), ' -> ', $spouses[0]->xref(), " [dir=none];\n";
					print $fout $spouses[0]->xref(), ' -> ',
						$person->xref(), ' -> ',
						$spouses[1]->xref(), " [dir=none];\n";
				} else {
					foreach my $spouse(@spouses) {
						print $fout $person->xref(), ' -> ', $spouse->xref(), " [dir=none];\n";
						# print $fout $person->xref(), ' -> ', $spouse->xref(), " [dir=none];\n";
					}
				}
				foreach my $child(@children) {
					print $fout $person->xref(), ' -> ', $child->xref(), ";\n";
				}

				print $fout '}';
				close $fout;

				my $filename = 'family-tree-' . $person->xref();
				my $dim = Image::Info::html_dim(Image::Info::image_info($png));
				print $csv "/img/$filename.png---$dim---";
				$both_xmls->print("\n\t\t<profile>/img/$filename.png</profile>");
				$tmp->seek(0, SEEK_SET);
				$both_xmls->print("\n\t\t<family_tree>");
				foreach my $line(<$tmp>) {
					chomp $line;
					print $csv wide_to_html({ string => $line, keep_hrefs => 1 });
					$line =~ s/</&lt;/g;
					$line =~ s/>/&gt;/g;
					$line =~ s/&/&amp;/g;
					$line =~ s/&amp;amp;/&amp;/g;
					$both_xmls->print(wide_to_xml($line));
				}
				$both_xmls->print('</family_tree>');
			}
		} elsif(defined($dot)) {
			complain(warning => "$dot: $!");
		}
	} else {	# alive
		print $csv '!!!';
	}

	print $csv '!';

	foreach my $residence(@residencelist) {
		if(my $rdate = $residence->date()) {
			$place_records{'Living ' . year({ person => $person, string => $rdate })} = $residence;
		}
	}

	# Create a Google map of the interesting places in this person's lifetime
	my @place_events = keys %place_records;
	if($opts{'m'} && ($opts{'l'} || !$is_alive) && (scalar(@place_events) || scalar(@note_locations))) {
		print "Create map\n" if($opts{'v'});
		my $map;
		my $current_place;
		my $annotation;

		if($opts{'w'}) {
			while(my($key, $value) = each %place_records) {
				if(!defined(place({ person => $person, record => $value, nopreposition => 1 }))) {
					$Data::Dumper::Maxdepth = 2;
					print STDERR __LINE__, ': ', ref($value), ': ', Data::Dumper->new([$value])->Dump();
					die "BUG: ", $person->as_string(), ": $key (", $value->place(), ') record has no location';
				}
			}
		}

		$both_xmls->print("\n\t\t<events>");
		foreach my $event(@place_events) {
			next if($event =~ /^Living /);	# Already put in above

			$both_xmls->print("\n\t\t\t<event>");
			my $record = $place_records{$event};
			$both_xmls->print("\n\t\t\t\t<text>")->print(wide_to_xml($event))->print('</text>');
			if(my $place = place({ record => $record, nopreposition => 1 })) {
				$place =~ s/^\s+//;
				$both_xmls->print("\n\t\t\t\t<location>")->print(wide_to_xml($place))->print('</location>');
			}
			if($record->date()) {
				my $date = year({ person => $person, record => $record, nopreposition => 1 });
				$date =~ s/^[io]n //;
				# Dates in the XML files are of the format YYYY/MM/DDD
				if(my $rdate_dt = date_to_datetime(date => $date)) {
					$date = $rdate_dt->strftime('%Y/%m/%d');
				} else {
					$date = wide_to_xml($date);
				}
				$both_xmls->print("\n\t\t\t\t<date>$date</date>");
			}
			$both_xmls->print("\n\t\t\t</event>");
		}
		$both_xmls->print("\n\t\t</events>");

		# Sort put all events at a place on the same pointer
		# TODO: then sort in date order
		foreach my $event(sort { place({ person => $person, record => $place_records{$a}, nopreposition => 1 }) cmp place({ person => $person, record => $place_records{$b}, nopreposition => 1 }) } @place_events ) {
			my $record = $place_records{$event};
			my $place = place({ record => $record, nopreposition => 1 });
			if(defined($place) && ($place =~ /,.+,/)) {
				$place =~ s/&eacute;/&#x0E9;/g;
				$place =~ s/^\s+//;
				print "Adding '$place' to map\n" if($opts{'v'});
				if(defined($current_place) && ($place ne $current_place)) {
					$current_place =~ s/&rsquo;/'/g;
					if(!defined($map)) {
						# my %args = (geocoder => $geocoder, z_index => -1);
						my %args = (geocoder => $geocoder);
						if($javascript_key) {
							$args{'api_key'} = $javascript_key;
						}
						$map = $maps_module->new(%args);
						if(!$map->center($current_place)) {
							warn "Couldn't centre the map on $current_place";
						}
					}
					add_marker(person => $person, map => $map, place => HTML::Entities::decode($current_place), annotation => $annotation);
					$current_place = $place;
					$annotation = undef;
				} elsif(!defined($current_place)) {
					$current_place = $place;
				}
				my $text = $event;
				# $text =~ s/\/.+//;	# Remove count e.g. when more than one residence
				if($event !~ /^Living /) {	# Already put in above
					if($record->date()) {
						$text .= ' ' . year({ person => $person, record => $record });
					}
				}
				$annotation .= "<p>$text</p>";
			}
		}

		# Go through the locations discovered in notes
		# FIXME: Merge into place_records, rather as was done with residencelist
		foreach my $location(@note_locations) {
			my $match;
			if($location->{'match'}) {
				$match = $location->{'match'};
			} else {
				$match = $location;
			}
			# print Data::Dumper->new([$match])->Dump();
			next if(defined($match->{'confidence'}) && ($match->{'confidence'} < 1.0));
			my $place = $match->{'location'};
			next if(!defined($place));	# The text didn't match a location
			if(defined($current_place) && ($place ne $current_place)) {
				$current_place =~ s/&rsquo;/'/g;
				# FIXME: no need to look up again, use $match->longt and lat
				if(!defined($map)) {
					# my %args = (geocoder => $geocoder, z_index => -1);
					my %args = (geocoder => $geocoder);
					if($javascript_key) {
						$args{'api_key'} = $javascript_key;
					}
					$map = $maps_module->new(%args);
					if(!$map->center($current_place)) {
						warn "Couldn't centre the map on $current_place";
					}
				}
				add_marker(person => $person, map => $map, place => HTML::Entities::decode($current_place), annotation => $annotation);
				$current_place = $place;
				$annotation = undef;
			} elsif(!defined($current_place)) {
				$current_place = $place;
			}
			$annotation .= '<p>' . $location->{'text'} . '</p>';
		}
		if($current_place) {
			$current_place =~ s/&rsquo;/'/g;
			if(!defined($map)) {
				# my %args = (geocoder => $geocoder, z_index => -1);
				my %args = (geocoder => $geocoder);
				if($javascript_key) {
					$args{'api_key'} = $javascript_key;
				}
				$map = $maps_module->new(%args);
				if(!$map->center($current_place)) {
					warn "Couldn't centre the map on $current_place";
				}
			}
			add_marker(person => $person, map => $map, place => HTML::Entities::decode($current_place), annotation => $annotation);
		}
		if(defined($map)) {
			# Create the values for the map_head and map_body
			#	fields in people.csv.
			# If you're using Google Maps to present the maps
			#	this is where your API key is used, which
			#	will have gone into $javascript_key
			print "Create map HTML\n" if($opts{'v'});
			# Can't put $head into the head since it's far too
			# late now!
			my ($map_head, $map_div) = $map->onload_render();
			$map_head =~ s/\n\n*/\n/g;
			$map_head =~ s/http:/https:/;
			$map_head = wide_to_html({ string => $map_head, keep_hrefs => 1, keep_apos => 1 });
			$map_head =~ s/(^|\n)[\n\s]*/$1/g;	# Remove blank lines
			if($map_div =~ /[^[:ascii:]]/) {
				# Fix the URL to not have wide characters
				my $ufinder = URI::Find::Schemeless->new(sub {
					# my($uri, $orig_uri) = @_;
					my $orig_uri = $_[1];

					$orig_uri =~ s/Ã¡/a/g;
					$orig_uri =~ s/Ã³/o/g;
					return $orig_uri;
				});
				$ufinder->find(\$map_div);
				$map_div = wide_to_html({ string => $map_div, keep_hrefs => 1, keep_apos => 1 });
			}
			# utf8::encode($map_head);
			$both_xmls->print("\n\t\t<map>\n\t\t\t<map_head>")
				->print(MIME::Base64::encode_base64url($map_head))
				->print("</map_head>\n\t\t\t<body>", MIME::Base64::encode_base64url($map_div), "</body>\n\t\t</map>");
			print $csv MIME::Base64::encode_base64url($map_head), '!', MIME::Base64::encode_base64url($map_div), '!';
			# if($opts{'m'}) {
				# # Don't include the key in the webpage.
				# $map_head =~ s/\?key=\w+?"/"/;
			# }
			print $html "$map_head<h2>Map</h2><center>$map_div</center>\n";
		} else {
			print $csv '!!';
		}
		print "Finished creating map\n" if($opts{'v'});
	} else {
		print $csv '!!';
	}

	undef %place_records;

	# Stash the birth and death dates (or years if all that is known)
	if($opts{'l'} || !$is_alive) {
		if($birth_dt) {
			print $csv $birth_dt->strftime('%Y/%m/%d');
			$both_xmls->print("\n\t\t<birth>")->print($birth_dt->strftime('%Y/%m/%d'))->print('</birth>');
		} elsif($yob) {
			print $csv $yob;
			$both_xmls->print("\n\t\t<birth>$yob</birth>");
		}
		print $csv '!';
		if($death_dt) {
			print $csv $death_dt->strftime('%Y/%m/%d');
			$both_xmls->print("\n\t\t<death>")->print($death_dt->strftime('%Y/%m/%d'))->print('</death>');
		} elsif($yod) {
			print $csv $yod;
			$both_xmls->print("\n\t\t<death>$yod</death>");
		}
	} else {
		print $csv '!';
	}

	print $csv '!';

	my $dt;
	if($ENV{'LC_TIME'}) {
		$dt = DateTime->now(locale => $ENV{'LC_TIME'});
	} else {
		$dt = DateTime->now();
	}
	print $html '<p align="right"><i>',
		'Generated by <a href="https://github.com/nigelhorne/ged2site">Ged2Site</a>. ',
		'Last updated on ',
		$dt->strftime('%x'),
		# $dt->day(), ' ', $dt->month_name(), ' ', $dt->year(),
		'</i></p>';

	if($birth_dt && ($opts{'l'} || !$is_alive) && $me && ($relationship || ($person->xref() eq $me->xref()))) {
		print $timeline_xml '<event start="', $birth_dt->year();
		if($birth_dt->month() && $birth_dt->day()) {
			printf $timeline_xml '-%02d', $birth_dt->month();
			if($birth_dt->day()) {
				printf $timeline_xml '-%02d', $birth_dt->day();
			}
		}
		print $timeline_xml '" ';

		if($death_dt) {
			print $timeline_xml 'end="', $death_dt->year();
			if($death_dt->month() && $death_dt->day()) {
				printf $timeline_xml '-%02d', $death_dt->month();
				if($death_dt->day()) {
					printf $timeline_xml '-%02d', $death_dt->day();
				}
			}
			print $timeline_xml '" ';
		}

		my $localfile;
		if($profile_thumbnail) {
			$localfile = "dynamic-site/img/thumb-$profile_thumbnail";
			$localfile =~ s/thumbs\///;
			unless(-r $localfile) {
				if($^O eq 'MSWin32') {
					copy($profile_thumbnail, $localfile);
				} else {
					link($profile_thumbnail, $localfile);
				}
			}
			$localfile =~ s/^dynamic-site\///;
			print $timeline_xml "image=\"/$localfile\" ";
			$profile_thumbnail = $localfile;
		}

		# Don't need citations here, and also some phrases are missing
		# leading to double commas
		$fullbio =~ s/<span class="citation">[\d,]+?<\/span>([\s\.;,])/$1/g;
		$fullbio =~ s/,,/,/g;
		$fullbio =~ s/href="\?page=/href="cgi-bin\/page.fcgi?page=/g;
		my $xref = $person->xref();
		my $xml_fullbio = $fullbio;
		$xml_fullbio =~ s/<\/p><p>/<br \/>/g;
		$xml_fullbio =~ s/<p>/<br \/>/g;
		print $timeline_xml 'title="', wide_to_xml($person->as_string()), '" ',
			'link="/cgi-bin/page.fcgi?page=people&amp;entry=', $xref, '"',
			'>', wide_to_xml({ string => $xml_fullbio, keep_hrefs => 1 }),
			"<\/event>\n";

		# Don't use wide_to_html, otherwise the <b> etc. will be lost
		print $visjs_html "{\ncontent: '<a href=\"cgi-bin/page.fcgi?page=people&entry=$xref\">",
			wide_to_html({ string => $person->as_string(), keep_hrefs => 1 }), "</a>',\n",
			'start: \'', $birth_dt->year();

		if($birth_dt->month() && $birth_dt->day()) {
			printf $visjs_html '-%02d', $birth_dt->month();
			if($birth_dt->day()) {
				printf $visjs_html '-%02d', $birth_dt->day();
			}
		}
		print $visjs_html "'";

		if($death_dt) {
			print $visjs_html ",\nend: '", $death_dt->year();
			if($death_dt->month() && $death_dt->day()) {
				printf $visjs_html '-%02d', $death_dt->month();
				if($death_dt->day()) {
					printf $visjs_html '-%02d', $death_dt->day();
				}
			}
			print $visjs_html "'";
		}

		print $visjs_html ",\ntitle: '";
		if($profile_thumbnail) {
			print $visjs_html "<img src=\"/$profile_thumbnail\" alt=\"", $person->as_string(), "\"><p>";
			print $csv $profile_thumbnail;
			$both_xmls->print("\n\t\t<thumbnail>$profile_thumbnail</thumbnail>");
			$all_thumbnails{$xref} = $profile_thumbnail;
		}
		$fullbio =~ s/'/\&#39;/g;
		my $b = wide_to_html($fullbio);
		print $visjs_html '<h2>', wide_to_html($person->as_string()), "</h2><hr>$b'\n},\n";
	}

	my $m;
	if($opts{'l'} || !$is_alive) {
		if(scalar(@spouses) == 1) {
			if($dateofmarriage && ($dateofmarriage =~ /\d$/)) {
				if(my $marriage_dt = date_to_datetime(date => $dateofmarriage)) {
					if($marriage_dt->month() && $marriage_dt->day()) {
						$m = $marriage_dt->strftime('%Y/%m/%d');
					}
				} elsif($dateofmarriage =~ /^\d{3,4}/) {
					$m = $dateofmarriage;
				}
			}
		} else {
			my $index;
			foreach my $spouse(@spouses) {
				my $date;
				# FIXME: if the spouse has been married more than once we'll get the wrong date
				if(my $rec = $spouse->get_record('fams marriage')) {
					$date = $rec->date();
				} elsif($rec = $spouse->get_record('marriage')) {
					$date = $rec->date();
				}
				if($date && ($date =~ /\d$/)) {
					if(my $marriage_dt = date_to_datetime(date => $date)) {
						if($marriage_dt->month() && $marriage_dt->day()) {
							$m .= '---' if($m);
							$m .= $marriage_dt->strftime('%Y/%m/%d');
						}
					} elsif($date =~ /^\d{3,4}/) {
						$m .= '---' if($m);
						$m .= $date;
					}
				}
			}
		}
	}

	if(defined($m)) {
		print $csv "!$m!$sex!";
	} else {
		print $csv "!!$sex!";
	}

	# Write the spouse information, including marriage info, to the person's XML file
	if(($opts{'l'} || !$is_alive) && scalar(@spouses)) {
		$both_xmls->print("\n\t\t<marriages>");

		my @marriages = $person->get_record('fams marriage');
		if(scalar(@marriages) == 0) {
			@marriages = $person->get_record('marriage');
		}
		my $index = 0;

		# Write the information for each marriage
		foreach my $spouse(@spouses) {
			next if((!$opts{'l'}) && is_alive($spouse));	# Don't stash if this spouse is still alive
			$both_xmls->print("\n\t\t\t<marriage>");
			if(scalar(@spouses) == 1) {
				$both_xmls->print("\n\t\t\t\t<date>$m</date>") if(defined($m));
				$both_xmls->print("\n\t\t\t\t<spouse>", $spouses[0]->xref(), '</spouse>');
			} elsif(my $marriage = $marriages[$index++]) {
				if(my $mdate = $marriage->date()) {
					$both_xmls->print("\n\t\t\t\t<date>$mdate</date>");
				}
				$both_xmls->print("\n\t\t\t\t<spouse>", $spouse->xref(), '</spouse>');
			}
			$both_xmls->print("\n\t\t\t</marriage>");
		}

		$both_xmls->print("\n\t\t</marriages>");
	};
	$both_xmls->print("\n\t\t<sex>$sex</sex>");

	if($me && $birth_dt && $death_dt) {
		# Calculate the birth and death countries of adults on both sides of the tree
		my $age_at_death = $death_dt - $birth_dt;
		if($age_at_death->years() >= 20) {
			if(defined($birth_country)) {
				if(my $mother = $me->mother()) {
					if($mother->relationship($person)) {
						$facts->{'mothers_side'}->{'birth_countries'}->{$birth_country}++;
					}
				}
				if(my $father = $me->father()) {
					if($father->relationship($person)) {
						$facts->{'fathers_side'}->{'birth_countries'}->{$birth_country}++;
					}
				}
			}
			if(defined($death_country)) {
				if(my $mother = $me->mother()) {
					if($mother->relationship($person)) {
						$facts->{'mothers_side'}->{'death_countries'}->{$death_country}++;
					}
				}
				if(my $father = $me->father()) {
					if($father->relationship($person)) {
						$facts->{'fathers_side'}->{'death_countries'}->{$death_country}++;
					}
				}
			}
		}
	}

	# TODO:  use known_locations array

	if($geocoder && ($opts{'l'} || !$is_alive) && ($placeofbirth || $placeofdeath)) {
		$both_xmls->print("\n\t\t<locations>");
		if($placeofbirth) {
			if(my $location = get_location($placeofbirth)) {
				# if(scalar(@locations) > 1) {
					# if($opts{'f'}) {
						# die $person->as_string(), ": Ambiguous birth location $placeofbirth";
					# }
					# red_warning({ person => $person, warning => "Ambiguous birth location $placeofbirth" });
				# } elsif(!defined($locations[0]->{'error'})) {
				$both_xmls->print("\n\t\t\t<birth>");
				if($birth_country) {
					$both_xmls->print("\n\t\t\t\t<country>$birth_country</country>");
				}
				print $csv $location->lat(), ',', $location->long();
				$both_xmls->print("\n\t\t\t\t<lat>")
					->print($location->lat())
					->print('</lat>')
					->print("\n\t\t\t\t<long>")
					->print($location->long())
					->print('</long>')
					->print("\n\t\t\t\t<point xmlns=\"http://www.opengis.net/gml\">")
					->print($location->long())
					->print($location->lat())
					->print('</point>')
					->print("\n\t\t\t</birth>");
				if($dateofbirth) {
					push @{$all_locations{get_year_from_date($dateofbirth)}}, {
						'record' => $birth,
						'person' => $person,
						'date' => $dateofbirth,
						'location' => $location,
						'latitude' => $location->lat(),
						'longitude' => $location->long()
					}
				};
			} else {
				complain({ person => $person, warning => "Unknown birth location $placeofbirth" });
			}
		}
		print $csv '!';
		if($placeofdeath) {
			if(my $location = get_location($placeofdeath)) {
				# if(scalar(@locations) > 1) {
					# if($opts{'f'}) {
						# die $person->as_string(), ": Ambiguous death location $placeofdeath";
					# }
					# red_warning({ person => $person, warning => "Ambiguous death location $placeofdeath" });
				# } elsif(!defined($locations[0]->{'error'})) {
				$both_xmls->print("\n\t\t\t<death>");
				if($death_country) {
					$both_xmls->print("\n\t\t\t\t<country>$death_country</country>");
				}
				print $csv $location->lat(), ',', $location->long();
				$both_xmls->print("\n\t\t\t\t<lat>")
					->print($location->lat())
					->print('</lat>')
					->print("\n\t\t\t\t<long>")
					->print($location->long())
					->print('</long>')
					->print("\n\t\t\t\t<point xmlns=\"http://www.opengis.net/gml\">")
					->print($location->long())
					->print($location->lat())
					->print('</point>')
					->print("\n\t\t\t</death>");
			} else {
				complain({ person => $person, warning => "Unknown death location $placeofdeath" });
			}
		}
		print $csv '!';
		if(scalar(@residencelist)) {
			$both_xmls->print("\n\t\t\t<residences>");
			# Print the residence list to the XML file.
			# If the residence doesn't change place from one record to the next, only print the date
			my $new_place = 1;
			my $iterator = Array::Iterator->new({ __array__ => \@residencelist });
			while(my $residence = $iterator->get_next()) {
				$both_xmls->print("\n\t\t\t\t<residence>") if($new_place);

				if(my $rdate = $residence->date()) {
					# Dates in the XML files are of the format YYYY/MM/DDD
					if(my $rdate_dt = date_to_datetime(date => $rdate)) {
						$rdate = $rdate_dt->strftime('%Y/%m/%d');
					}
					$both_xmls->print("\n\t\t\t\t\t<date>$rdate</date>");
				}

				if($new_place && (my $rplace = place({ person => $person, record => $residence, nopreposition => 1, encode => 0 }))) {
					$rplace = wide_to_xml($rplace);
					$rplace =~ s/^\s+//;
					$rplace =~ s/\xc3\xb1/&#241;/g;	# ntilde
					$rplace =~ s/Ã±/&#x0F1;/g;
					$rplace =~ s/\s&\s/ &amp; /g;

					$both_xmls->print("\n\t\t\t\t\t<location>$rplace</location>");
				}

				my $peek = $iterator->peek();
				if(defined($peek) && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
					$new_place = 0;
				} else {
					$both_xmls->print("\n\t\t\t\t</residence>");
					$new_place = 1;
				}
			}
			$both_xmls->print("\n\t\t\t</residences>");
		}

		$both_xmls->print("\n\t\t</locations>");

		my $xref = $person->xref();
		my $military_count = 0;
		foreach my $event(@events) {
			if($event->can('type') && (my $type = $event->type())) {
				if($type eq 'Military service') {
					if($military_count == 0) {
						$both_xmls->print("\n\t\t<military>");
						$all_military{$xref} = ();
					}
					$military_count++;

					$both_xmls->print("\n\t\t\t<entry>")
						->print("\n\t\t\t\t<service>", ucfirst(service($event)), '</service>');

					my $entry;
					if(my $date = year(record => $event, nopreposition => 1)) {
						$both_xmls->print("\n\t\t\t\t<date>");
						if($date =~ /^from (.+) to (.+)$/) {
							my ($from, $to) = ($1, $2);

							# Validate that the "to" date is after the "from" date
							if(datecmp($from, $to) >= 0) {
								complain({
									person => $person,
									warning => "To is before from in military service '$date'"
								});
							}
							# Will fail if we just have a year
							if(my $from_dt = date_to_datetime(date => $from)) {
								$from = $from_dt->strftime('%Y/%m/%d');
							}
							if(my $to_dt = date_to_datetime(date => $to)) {
								$to = $to_dt->strftime('%Y/%m/%d');
							}

							$entry->{'from'} = $from;
							$entry->{'to'} = $to;

							$both_xmls->print("\n\t\t\t\t\t<from>$from</from>")
								->print("\n\t\t\t\t\t<to>$to</to>");
						} else {
							my $xml_date = $date;
							$xml_date =~ s/^[on]n\s+//i;	# E.g. "in 1942" or "on 28 May 1920"
							$both_xmls->print("\n\t\t\t\t\t$xml_date");
						}
						$both_xmls->print("\n\t\t\t\t</date>");
						$entry->{'date'} = $date;
					}
					if(my $place = place({ person => $person, record => $event, nopreposition => 1 })) {
						$place =~ s/^\s+//;
						$entry->{'place'} = $place;
						$place = wide_to_xml($place);
						$both_xmls->print("\n\t\t\t\t<location>")
							->print("\n\t\t\t\t\t$place")
							->print("\n\t\t\t\t</location>");
					}
					if(my $notes = notes(record => $event, note_locations => \@note_locations)) {
						$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
						$notes =~ s/[\s\.]+$//;
						$notes =~ s/<br>/ /g;
						$notes = wide_to_xml($notes);
						$both_xmls->print("\n\t\t\t\t<notes>")
							->print("\n\t\t\t\t\t")
							->print(ucfirst($notes))
							->print("\n\t\t\t\t</notes>");
						$entry->{'notes'} = $notes;
					}
					$both_xmls->print("\n\t\t\t</entry>");
					push @{$all_military{$xref}}, $entry;
				}
			}
		}
		if($military_count > 0) {
			$both_xmls->print("\n\t\t</military>");
		}

		if(scalar(@occupations)) {
			$both_xmls->print("\n\t\t<occupations>");

			foreach my $occupation(@occupations) {
				$occupation =~ s/&/&amp;/g;
				$both_xmls->print("\n\t\t\t<occupation>$occupation</occupation>");
				push @{$all_occupations{$occupation}}, $xref;
			}

			$both_xmls->print("\n\t\t</occupations>");
		}
	} else {
		print $csv '!!';
	}

	if(!defined($birth_country)) {
		$birth_country = '';
	}
	if(!defined($death_country)) {
		$death_country = '';
	}
	print $csv "$birth_country!$death_country!";

	# Print out all of the warnings from this entry
	if($person->{'warnings'} && ($opts{'l'} || !is_alive(person => $person))) {
		print "Create warnings\n" if($opts{'v'});
		my $ufinder = URI::Find::Schemeless->new(sub {
			my($uri, $orig_uri) = @_;

			my $u = URI->new($orig_uri);
			if($u && (ref($u) ne 'URI::_generic')) {
				$uri =~ s/:$//;
				return "<a href=\"$uri\">" .
					$u->host() .
					'</a>';
			}
			return $orig_uri;
		});
		my @issues = map {
			my $s = HTML::Entities::decode($_);
			if($s =~ /<a href="/i) {
				$s
			} else {
				$ufinder->find(\$s); "<p>$s</p>"
			}
		} @{$person->{'warnings'}};

		print $html '<h2>Known Issues</h2>';
		print $csv map { wide_to_html({ string => $_, keep_hrefs => 1 }) } @issues;
		$both_xmls->print("\n\t\t<issues>");
		foreach my $issue(@issues) {
			print $html wide_to_html({ string => $issue, keep_hrefs => 1 });
			$issue =~ s/^<p>//;
			$issue =~ s/<\/p>$//;
			$issue = wide_to_xml($issue);
			$both_xmls->print("\n\t\t\t<issue>$issue</issue>");
		}
		$both_xmls->print("\n\t\t</issues>");
	}
	undef $both_xmls;	# Ensure the close below really does close person_xml

	print $html '</body></html>';
	close $html;
	print $person_xml "\n\t</person>\n</table>\n";
	close $person_xml;
	chmod 0444, File::Spec->catfile('dynamic-site', 'data', 'people', $person->xref() . '.xml');

	$printed{$person->xref()} = 1;

	if($current_people) {
		# Find this person's previous record to put changes into the blog
		my $person_in_last_run;
		my $birth_in_last_run;
		my $marriage_in_last_run;
		my $death_in_last_run;

		foreach my $p($current_people->root()->children('person')) {
			my $entry = $p->first_child('xref');
			next if($entry->first_child()->pcdata() ne $person->xref());
			if($firstname && (my $f = $p->first_child('first_name'))) {
				next if($f->first_child()->pcdata() ne $firstname);
			}
			if($surname && (my $s = $p->first_child('surname'))) {
				next if($s->first_child()->pcdata() ne $surname);
			}
			if($birth_in_last_run = $p->first_child('birth')) {
				$birth_in_last_run = $birth_in_last_run->first_child()->pcdata();
			}
			if($marriage_in_last_run = $p->first_child('marriage')) {
				$marriage_in_last_run = $marriage_in_last_run->first_child()->pcdata();
				if(($marriage_in_last_run =~ /\-\-\-/) || (scalar(@spouses) >= 2)) {
					# Married more than once
					$marriage_dt = undef;
				} elsif($spouses[0] && (!$opts{'l'}) && is_alive($spouses[0])) {
					# Spouse is still alive
					$marriage_dt = undef;
				}
			}
			if($death_in_last_run = $p->first_child('death')) {
				$death_in_last_run = $death_in_last_run->first_child()->pcdata();
			}
			$person_in_last_run = $p;
			last;
		}

		# Add entries to the changes.psv file
		if($opts{'l'} || !$is_alive) {
			if(defined($person_in_last_run)) {
				if($birth_dt && ($birth_dt =~ /\d{3,4}/)) {
					my $b = $birth_dt->strftime('%Y/%m/%d');
					my $change;
					if($birth_in_last_run) {
						if($b ne $birth_in_last_run) {
							$change = "Changed date of birth from $birth_in_last_run to $b";
						}
					} else {
						$change = "Added date of birth as $b";
					}
					if($change) {
						my $p = Class::Simple->new();
						$p->readonly_person($person);
						$p->readonly_change($change);
						push @{$changes{'changes'}}, $p;
					}
				}
				if($marriage_dt && ($marriage_dt =~ /\d{3,4}/)) {
					my $m = $marriage_dt->strftime('%Y/%m/%d');
					my $change;
					if($marriage_in_last_run) {
						if($m ne $marriage_in_last_run) {
							$change = "Changed date of marriage from $marriage_in_last_run to $m";
						}
					} else {
						$change = "Added date of marriage as $m";
					}
					if($change) {
						my $p = Class::Simple->new();
						$p->readonly_person($person);
						$p->readonly_change($change);
						push @{$changes{'changes'}}, $p;
					}
				}
				if($death_dt && ($death_dt =~ /\d{3,4}/)) {
					my $d = $death_dt->strftime('%Y/%m/%d');
					my $change;
					if($death_in_last_run) {
						if($d ne $death_in_last_run) {
							$change = "Changed date of death from $death_in_last_run to $d";
						}
					} else {
						$change = "Added date of death as $d";
					}
					if($change) {
						my $p = Class::Simple->new();
						$p->readonly_person($person);
						$p->readonly_change($change);
						push @{$changes{'changes'}}, $p;
					}
				}
			} else {
				push @{$changes{'added_people'}}, $person;
				$person_in_last_run = 1;	# Avoid adding this person to the blog twice
			}
		}
	}

	print "Done\n" if($opts{'v'});

	$all_bios{$person->xref()} = $fullbio;
}

sub all_records_have_date
{
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my @records = @{$args{'records'}};
	my $person = $args{'person'};

	foreach my $record (@records) {
		# Check if $record is an object and has a valid date method
		return 0 unless(ref($record) && $record->can('date'));

		my $date = $record->date();
		# Check if the date is valid and matches required format
		if((!defined $date) || ($date !~ /^\d/) || ($date =~ /[a-z]$/i) ||
		    ($date =~ /[\/\-]/) || ($date =~ / to /) || !date_parser_cached(date => $date)) {
			if((defined($date)) && ($date !~ / to /) && ($date !~ /[\/\-]/) && ($date !~ /^abt/i) && ($date !~ /^bet/)) {
				# Log a warning if date is invalid
				complain({
					person => $person,
					warning => "Record has an invalid date of $date"
				});
			}
			return 0;
		}
	}
	return 1;
}

# nee: Born, used to denote a woman's maiden name (e.g., Anne Gibson nee West)
sub Gedcom::Individual::as_string
{
	my $self = shift;
	my $params = Params::Get::get_params(undef, @_);

	my ($name, $suffix);

	if($params->{'use_aka'}) {
		my $n2 = $self->tag_record('NAME', 2);
		if(defined($n2) && $n2->can('type') && defined($n2->type()) && ($n2->type() eq 'AlsoKnownAs') && ($n2->value() ne $self->name())) {
			$name = $n2->value();
		} else {
			return;
		}
	} else {
		$name = $self->name();

		# See https://github.com/pjcj/Gedcom.pm/issues/28
		$suffix = get_value({ person => $self, value => 'NAME NSFX' });
	}

	$name =~ s/\///g;

	# FIXME: Correctly handle other names, relies on Lingua::EN::NameParse
	#	too much

	$name = Unicode::Diacritic::Strip::strip_diacritics($name);
	# $name =~ tr/ÄÃ¡Å/can/;
	# $name =~ s/Ä/c/g;
	# $name =~ s/Ã¡/a/g;
	# $name =~ s/Å/n/g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'} // $name_components{'initials_1'};
	my $middle_name = $name_components{'middle_name'};
	my $surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	if($name_components{'non_matching'}) {
		if($name =~ /(\w{2,})\s(\w{2,})\s(\w+)\s(\w{2,})/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			my $rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
			$surname .= $rest;

			# Remove the middle name, since it's come in from the non_matching
			$middle_name = undef;
			delete $params->{'middle_names'};
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $has_maiden_name;
	if($params->{'nee'}) {
		my $sex = get_value({ person => $self, value => 'sex' });
		if(defined($sex) && ($sex eq 'F')) {
			my @husbands = $self->husband();
			if(my $husband = pop @husbands) {
				$surname = $husband->surname();
				$has_maiden_name = 1;
			} elsif(my $spouse = $self->spouse()) {
				complain({ person => $self, warning => 'married, but no husband relationship' });
				$surname = $spouse->surname();
				$has_maiden_name = 1;
			}
		}
	}

	my $rc;

	if($params->{'title'} && $name_components{'title_1'}) {
		if($name_components{'title_1'}) {
			$rc = $name_components{'title_1'};
		} else {
			# Prefix, e.g. 'Cpl'
			$rc = get_value({ person => $self, value => 'NAME NPFX' });
		}
		if($rc) {
			$rc .= ' ';
		}
	}

	if($first_name) {
		$rc .= $first_name;
	} elsif(my $given = $self->given_names()) {
		# https://github.com/nigelhorne/ged2site/issues/120
		$rc .= $given;	# safe as it won't end a sentence
	} elsif($params->{'print_unknown'}) {
		$rc .= 'UNKNOWN';
	}

	if($params->{'middle_names'}) {
		if($middle_name) {
			$rc .= " $middle_name";
		} elsif($name =~ /\s([A-Z])\s.+/) {
			# Just an initial has been given
			$rc .= " $1";
		}
	}

	if($surname) {
		if($rc) {
			$rc .= ' ';
		}
		$rc .= normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	} elsif($params->{'print_unknown'}) {
		$rc .= ' UNKNOWN';
	}

	if($has_maiden_name && (my $surname = $self->surname())) {
		$rc .= ' (nÃ©e ' . normalize_name($surname) . ')';
	}

	if(!defined($rc)) {
		complain({ warning => "Can't parse the name of '$name'" });
		$params->{'include_years'} = 1;
		$rc = 'Unknown person';
	}

	# utf8::decode($rc) unless(utf8::is_utf8($rc));

	if($params->{'include_years'}) {
		my $dob = dateofbirth($self);

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			if($dob =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yob = "c$1";	# Get the "1951" from "Feb 1951"
				}
				$yob = "c$year";
			} else {
				$yob = $1;
			}
		} else {
			$dob = get_value({ person => $self, value => 'baptism date' });
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = dateofdeath($self);

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			if($dod =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yod = "c$1";	# Get the "1951" from "Feb 1951"
				} else {
					$yod = "c$year";
				}
			} else {
				$yod = $1;
			}
		} else {
			$dod = get_value({ person => $self, value => 'burial date' });
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		if($suffix) {
			$rc .= " $suffix";
		}

		$rc .= ' ' if($yob || $yod);

		if($yob) {
			$rc .= "$yob ";
		}

		$rc .= '-' if($yob || $yod);

		if($yod) {
			return "$rc $yod";
		}
	}

	if(!defined($rc)) {
		complain({ warning => [ "Can't determine the name for record ", $self->xref() ] });
		return '';
	}

	$rc =~ tr/"/'/;	# fix issues with Graphviz and others

	if($suffix) {
		return "$rc $suffix";
	}
	return $rc;
}

sub normalize_name
{
	my $name = shift;

	# utf8::decode($name);
	if($name =~ /[^[:ascii:]]/) {
		return $name;	# It will break encoding, so don't even try

		# my $rc;

		# foreach my $word(split(/-| |'/, lc($name))) {
			# $rc .= '-' if($rc && ($name =~ /-/));
			# $rc .= "'" if($rc && ($name =~ /'/));
			# $rc .= ' ' if($rc && ($name =~ / /));
			# $rc .= ucfirst($word);
		# }

		# return $rc;
	}

	return Lingua::EN::NameCase::nc($name);
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	if(defined(my $sex = get_value({ person => $self, value => 'sex' }))) {
		if($sex eq 'F') {
			return 'She';
		}
		if($sex eq 'M') {
			return 'He';
		}
	}
	return 'They';
}

sub Gedcom::Individual::possessive
{
	my $self = shift;

	my $rc = {
		'He' => 'His',
		'She' => 'Her',
		'They' => 'Their',
	};

	return $rc->{$self->pronoun()};
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship
{
	my ($self, $other) = @_;

	# Return undefined if both individuals are the same
	return if($other->xref() eq $self->xref());

	# Retrieve parent's xref details
	# Check if both individuals have complete parental information
	if((my $self_mother = $self->mother()) && (my $self_father = $self->father()) &&
	   (my $other_mother = $other->mother()) && (my $other_father = $other->father())) {
		my $sex = $other->sex() || get_value({ person => $other, value => 'sex' });

		# Full siblings
		if(($self_mother->xref() eq $other_mother->xref()) && ($self_father->xref() eq $other_father->xref())) {
			return $language eq 'Farsi'
				# ? ($sex eq 'M') ? 'barÄdar' : 'khÄhar';
				? ($sex eq 'M' ? "\N{U+0631}\N{U+062F}\N{U+0637}\N{U+0631}\N{U+0638}" : "\N{U+062E}\N{U+0627}\N{U+0647}\N{U+0631}")
				: i18n($sex eq 'M' ? 'brother' : 'sister');
		}

		# Half siblings
		if(($self_mother->xref() eq $other_mother->xref()) || ($self_father->xref() eq $other_father->xref())) {
			return $language eq 'Latin'
				? ($sex eq 'M' ? 'frÄter uterÄ«nus' : 'soror uterÄ«na')
				: $language eq 'German'
				? ($sex eq 'M' ? 'Halbbruder' : 'Halbschwester')
				: ($sex eq 'M' ? 'half-brother' : 'half-sister');
		}
	}

	# Fall back to relationship up or down
	return $self->relationship_down($other) || $self->relationship_up($other);
}

sub Gedcom::Individual::relationship_up
{
	my $self = shift;
	my $other = shift;
	my @ancestors;

	if($me && ($self->xref() eq $me->xref())) {
		# Cache myancestors since we call this a lot of times
		unless(@myancestors) {
			@myancestors = $me->ancestors();
		}
		return unless scalar(@myancestors);
		@ancestors = @myancestors;
	} else {
		@ancestors = $self->ancestors();
	}

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	foreach my $person1(@ancestors) {
		die $person1->as_string({ include_years => 1 }) if($person1->xref() eq $self->xref());
		if($person1->xref() eq $other->xref()) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title;

			if($language eq 'Farsi') {
				# return ($sex eq 'M') ? 'pedar' : 'mÄdar';
				return ($sex eq 'M') ? "\N{U+0631}\N{U+062F}\N{U+067E}" : "\N{U+0631}\N{U+062F}\N{U+0627}\N{U+0645}";
			} elsif($language eq 'Spanish') {
				return ($sex eq 'M') ? 'padre' : 'mother';
			} else {
				$title = i18n(($sex eq 'M') ? 'father' : 'mother');
			}

			if($steps >= 5) {
				if($language eq 'Latin') {
					if($steps == 5) {
						return ($sex eq 'M') ? 'atavus' : 'atavia';
					}
					if($steps == 6) {
						return ($sex eq 'M') ? 'tritavus' : 'tritavia';
					}
				}
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				if($language eq 'French') {
					return "grand-$title";
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'avus' : 'avia';
				} elsif($language eq 'German') {
					return ($sex eq 'M') ? "Gro\N{U+00DF}vater" : "Gro\N{U+00DF}utter";
				}
				return "grand$title";
			} elsif($steps == 3) {
				if($language eq 'French') {
					return "arri\N{U+00E8}re-grand-$title";
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'proavus' : 'proavia';
				} elsif($language eq 'German') {
					return ($sex eq 'M') ? "Urgro\N{U+00DF}vater" : "Urgro\N{U+00DF}utter";
				}
				return "great-grand$title";
			} elsif($steps == 4) {
				if($language eq 'Latin') {
					return ($sex eq 'M') ? 'abavus' : 'abavia';
				} elsif($language eq 'German') {
					return ($sex eq 'M') ? "Ur-urgro\N{U+00DF}vater" : "Ur-urgro\N{U+00DF}utter";
				}
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	foreach my $person1(@ancestors) {
		foreach my $person2(@ancestors2) {
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# TODO - apparently fixed in Github, awaiting new version on CPAN
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }

			if($person1->xref() eq $person2->xref()) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				# die $steps1 if($steps1 > 23);
				return if($steps1 > 23);
				my $steps2 = stepsabove($other, $person2, 0);
				# die $steps2 if($steps2 > 23);
				return if($steps2 > 23);

				if(defined($language) && ($language eq 'Latin')) {
					if(($steps1 == 1) && ($steps2 == 1)) {
						return ($sex eq 'M') ? 'frÄter' : 'soror';
					}
					my $myfather = $self->father();
					if(($steps1 == 2) && ($steps2 == 1)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruus';	# paternal uncle
							}
							return 'avunculus';	# maternal uncle
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'amita';	# paternal aunt
							}
							return 'mÄtereta';	# maternal aunt
						}
					} elsif(($steps1 == 3) && ($steps2 == 1)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruus mÄgnus';	# paternal great-uncle
							}
							return 'avunculus mÄgnus';	# maternal great-uncle
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'amita mÄgna';	# paternal great-aunt
							}
							return 'mÄtereta mÄgna';	# maternal great-aunt
						}
					} elsif(($steps1 == 4) && ($steps2 == 1)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruus mÄior';	# paternal great-great-uncle
							}
							return 'avunculus mÄior';	# maternal great-great-uncle
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'amita mÄior';	# paternal great-great-aunt
							}
							return 'matertera mÄior';	# maternal great-great-aunt
						}
					} elsif(($steps1 == 5) && ($steps2 == 1)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruus mÄximus';	# paternal great-great-great-uncle
							}
							return 'avunculus mÄximus';	# maternal great-great-great-uncle
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'amita mÄxima';	# paternal great-great-great-aunt
							}
							return 'matertera mÄxima';	# maternal great-great-great-aunt
						}
					} elsif(($steps1 == 2) && ($steps2 == 2)) {
						if($sex eq 'M') {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruelis';	# paternal male 1st cousin
							}
							return 'consorbrius';	# maternal male 1st cousin
						} else {
							if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
								return 'patruelis';	# paternal female 1st cousin
							}
							return 'consorbria';	# maternal female 1st cousin
						}
					} elsif(($steps1 == 1) && ($steps2 == 2)) {
						if($other->father() && isbrother($self, $other->father())) {
							if($sex eq 'M') {
								return 'fratris filius';	# nephew - brother's son
							}
							return 'fratrais filia';	# niece - brother's daughter
						} elsif($other->mother() && issister($self, $other->mother())) {
							if($sex eq 'M') {
								return 'sororis filius';	# nephew - sister's son
							}
							return 'sororis filia';	# niece - sister's daughter
						} else {
							die 'BUG: parent neither sister nor brother';
						}
					}
				}

				# TODO: It would be nice to do this as an algorithm
				my %en_male_relationships = (
					1 << 24 | 1 => 'brother',
					1 << 24 | 2 => 'nephew',
					1 << 24 | 3 => 'great-nephew',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'uncle',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					2 << 24 | 6 => 'first cousin four-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					13 << 24 | 2 => 'first cousin eleven-times-removed',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				# https://www.tfcg.ca/tableau-des-liens-de-parente
				my %fr_male_relationships = (
					1 << 24 | 1 => "fr\N{U+00E8}re",
					1 << 24 | 2 => 'neveu',
					1 << 24 | 3 => 'petit-neveu',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'oncle',
					2 << 24 | 2 => 'cousin germain',
					2 << 24 | 3 => "cousin germain \N{U+00E9}loign\N{U+00E9} au 1er degr\N{U+00E9}",
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					2 << 24 | 6 => 'first cousin four-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => "cousin germain \N{U+00E9}loign\N{U+00E9} au 1er degr\N{U+00E9}",
					3 << 24 | 3 => 'cousin issu de germain',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => "arri\N{U+00E8}re-petit-cousin \N{U+00E9}loign\N{U+00E9} au 1er degr\N{U+00E9}",
					5 << 24 | 7 => "arri\N{U+00E8}re-petit-cousin \N{U+00E9}loign\N{U+00E9} au 2e degr\N{U+00E9}",
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => "arri\N{U+00E8}re-petit-cousin \N{U+00E9}loign\N{U+00E9} au 1er degr\N{U+00E9}",
					6 << 24 | 6 => "arri\N{U+00E8}re-arri\N{U+00E8}re-petit-cousin",
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => "petit-cousin \N{U+00E9}loign\N{U+00E9} au 3e degr\N{U+00E9}",
					7 << 24 | 5 => "arri\N{U+00E8}re-petit-cousin \N{U+00E9}loign\N{U+00E9} au 2e degr\N{U+00E9}",
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => "sixi\N{U+00E8}me cousin",
					7 << 24 | 8 => "sixi\N{U+00E8}me cousin once-removed",
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					13 << 24 | 2 => 'first cousin eleven-times-removed',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				my %de_male_relationships = (
					1 << 24 | 1 => 'Brude',
					1 << 24 | 2 => 'Neffe',
					1 << 24 | 3 => 'great-nephew',
					1 << 24 | 4 => 'great-great-nephew',
					2 << 24 | 1 => 'Onkel',
					2 << 24 | 2 => 'Cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					2 << 24 | 6 => 'first cousin four-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					13 << 24 | 2 => 'first cousin eleven-times-removed',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				my %en_female_relationships = (
					1 << 24 | 1 => 'sister',
					1 << 24 | 2 => 'niece',
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'aunt',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					2 << 24 | 6 => 'first cousin four-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					13 << 24 | 2 => 'first cousin eleven-times-removed',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);
				my %fr_female_relationships = (
					1 << 24 | 1 => 'sÅur',
					1 << 24 | 2 => "ni\N{U+00E8}ce",
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'tant',
					2 << 24 | 2 => 'cousine germaine',
					2 << 24 | 3 => "cousin germain \N{U+00E9}loign\N{U+00E9} au 1er degr\N{U+00E9}",
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					2 << 24 | 6 => 'first cousin four-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => "cousin germain \N{U+00E9}loign\N{U+00E9} au 1er degr\N{U+00E9}",
					3 << 24 | 3 => 'cousine issue de germain',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => "arri\N{U+00E8}re-petite-cousine \N{U+00E9}loign\N{U+00E9}e au 1er degr\N{U+00E9}",
					5 << 24 | 7 => "arri\N{U+00E8}re-petite-cousine \N{U+00E9}loign\N{U+00E9}e au 2e degr\N{U+00E9}",
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					5 << 24 | 5 => "arri\N{U+00E8}re-petite-cousine \N{U+00E9}loign\N{U+00E9}e au 1er degr\N{U+00E9}",
					6 << 24 | 6 => "arri\N{U+00E8}re-arri\N{U+00E8}re-petite-cousine",
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => "petite-cousine \N{U+00E9}loign\N{U+00E9}e au 3e degr\N{U+00E9}",
					7 << 24 | 5 => "arri\N{U+00E8}re-petite-cousine \N{U+00E9}loign\N{U+00E9}e au 2e degr\N{U+00E9}",
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => "sixi\N{U+00E8}me cousin",
					7 << 24 | 8 => "sixi\N{U+00E8}me cousin once-removed",
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					13 << 24 | 2 => 'first cousin eleven-times-removed',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);
				my %de_female_relationships = (
					1 << 24 | 1 => 'Schwester',
					1 << 24 | 2 => 'niece',
					1 << 24 | 3 => 'great-niece',
					1 << 24 | 4 => 'great-great-niece',
					2 << 24 | 1 => 'Tante',
					2 << 24 | 2 => 'Cousine',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					2 << 24 | 6 => 'first cousin four-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					4 << 24 | 7 => 'third cousin three-times-removed',
					5 << 24 | 1 => 'three times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					5 << 24 | 7 => 'fourth cousin twice-removed',
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'five times great-aunt',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					13 << 24 | 2 => 'first cousin eleven-times-removed',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);

				my $rc;
				if(defined($language) && ($language eq 'French')) {
					$rc = ($sex eq 'M') ?
						$fr_male_relationships{($steps1 << 24) | $steps2} :
						$fr_female_relationships{($steps1 << 24) | $steps2};
				} elsif(defined($language) && ($language eq 'German')) {
					$rc = ($sex eq 'M') ?
						$de_male_relationships{($steps1 << 24) | $steps2} :
						$de_female_relationships{($steps1 << 24) | $steps2};
				} else {
					$rc = ($sex eq 'M') ?
						$en_male_relationships{($steps1 << 24) | $steps2} :
						$en_female_relationships{($steps1 << 24) | $steps2};
				}
				if(defined($rc) && ($rc =~ /cousin/)) {
					my $myfather = $self->father();
					my $mymother = $self->mother();
					if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
						if($me && ($self->xref() eq $me->xref())) {
							$rc .= i18n(" on the father's side");
						} else {
							$rc .= ' on ' .
								lcfirst($self->possessive()) .
								" father's side";
						}
					} elsif($mymother && (stepsabove($mymother, $person2, 0) > 0)) {
						if($me && ($self->xref() eq $me->xref())) {
							$rc .= i18n(" on the mother's side");
						} else {
							$rc .= ' on ' .
								lcfirst($self->possessive()) .
								" mother's side";
						}
					}
				}
				if(!defined($rc)) {
					die $other->as_string({ nee => 1, middle_names => 1, include_years => 1 }), ": $steps1, $steps2";
					complain({ person => $other, warning => "TODO: $steps1, $steps2" });
				}
				return $rc;
			}
		}
	}
}

sub Gedcom::Individual::relationship_down
{
	my $self = shift;
	my $other = shift;
	my @descendant;

	if($me && ($self->xref() eq $me->xref())) {
		# Cache mydescendants since we call this a lot of times
		unless(@mydescendants) {
			# @mydescendants = $me->descendants();
			@mydescendants = descendants($me);
		}
		return unless scalar(@mydescendants);
		@descendant = @mydescendants;
	} else {
		# @descendant = $self->descendants();
		@descendant = descendants($self);
	}

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	# print __LINE__, ': ', $self->as_string(), '/', $other->as_string(), "\n";
	# my $i = 0;
	# while((my @call_details = caller($i++))) {
		# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
	# }
	foreach my $person1(@descendant) {
		# print __LINE__, "\t", $person1->as_string(), "\n";
		die $person1->as_string() if($person1 eq $self);
		if($person1->xref() eq $other->xref()) {
			# Direct descendant
			my $steps = stepsabove($other, $self, 0);
			my $title = i18n(($sex eq 'M') ? 'son' : 'daughter');
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return 'fils';
					}
				} elsif($language eq 'Farsi') {
					# return ($sex eq 'M') ? 'pesar' : 'dokhtar';
					return ($sex eq 'M') ? "\N{U+0631}\N{U+0633}\N{U+067E}" : "\N{U+0631}\N{U+062A}\N{U+062E}\N{U+062F}";
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'fÄ«lius' : 'fÄ«lia';
				}
				return $title;
			} elsif($steps == 2) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return 'petit-fils';
					}
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'nepÅs' : 'neptis';
				}
				return "grand$title";
			} elsif($steps == 3) {
				if($language eq 'French') {
					if($sex eq 'M') {
						return "arri\N{U+00E8}re-petit-fils";
					}
				} elsif($language eq 'Latin') {
					return ($sex eq 'M') ? 'prÅnepÅs' : 'prÅneptis';
				}
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}
}

sub stepsabove
{
	my ($person, $target, $count) = @_;
	$count ||= 0; # Ensure count has a default value if not provided.

	# Validate inputs
	if((!defined $person) || !defined $target) {
		print STDERR "\n";
		my $i = 0;
		while (my @call_details = caller($i++)) {
			print STDERR "\t", colored("$call_details[2] of $call_details[1]", 'red'), "\n";
		}
		die 'Usage: stepsabove($person, $target, $count)';
	}

	# Found the target
	return $count if $person->xref() eq $target->xref();

	# Recursive calls for father and mother
	for my $parent($person->father(), $person->mother()) {
		next unless defined $parent; # Skip undefined parents
		my $rc = stepsabove($parent, $target, $count + 1);
		return $rc if $rc != -1; # Return result if found
	}

	# Target not found
	return -1;
}

# Returns a human readable string from a date variable, handles data verification
# and locales
sub year
{
	my $params = Params::Get::get_params(undef, @_);

	my $string = $params->{'string'} || $params->{'date'};

	if(!defined($string)) {
		$string = $params->{'record'};
		return unless($string);

		if(ref($string) && $string->can('date')) {
			$string = $string->date();
			return unless($string);
			$string =~ s/\s+$//;
		}
	}

	if($string =~ /^\d{3,4}$/) {
		return $string if($params->{'nopreposition'});

		if($language eq 'French') {
			return "en $string";
		}
		return "in $string";
	}
	if($string =~ /^(Abt|ca?)\.?\s*(.+)/i) {
		my $rc = $2;
		if($opts{'w'}) {
			if(my $must_postdate = $params->{'must_postdate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt < $must_postdate)) {
					complain({ person => $params->{'person'}, warning => "Something is wrong with the date $string which should be after $must_postdate" });
				}
			}
			if(my $must_predate = $params->{'must_predate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt > $must_predate)) {
					complain({ person => $params->{'person'}, warning => "Something is wrong with the date $string which should be before $must_predate" });
				}
			}
		}
		if(!defined($params->{'circa'})) {
			$params->{'circa'} //= '<i>' . (($language eq 'German') ? 'um' : 'c.') . '</i>';
		}
		if($language ne 'English') {
			my $d = $date_parser->parse(date => $rc);
			if($d && (ref($d) eq 'ARRAY')) {
				$d = $d->[0];
			}
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($ENV{'LC_TIME'}) {
				$d->set_locale($ENV{'LC_TIME'});
			} elsif($ENV{'LC_ALL'}) {
				$d->set_locale($ENV{'LC_ALL'});
			} elsif($ENV{'LANG'}) {
				$d->set_locale($ENV{'LANG'});
			}
			return i18n($params->{'circa'}) . ' ' . $d->strftime('%b %Y');
		}
		return $params->{'circa'} . " $rc";
	}

	if($string =~ /^\s*(.+\d\d)\s*\-\s*(.+\d\d)\s*$/) {
		my $start = $1;
		my $end = $2;
		if($end !~ /^\d\d\-\d\d$/) {
			complain({ warning => "Changing date '$string' to 'bet $start and $end'" });
			$string = "bet $start and $end";
		}
	}

	if(($string =~ /^bet (.+) and (.+)/i) ||
	   ($string =~ /^Fro?m (.+) to (.+)/i)) {
		my $from = year({ %{$params}, string => $1 });
		my $to = year({ %{$params}, string => $2 });

		if($language eq 'French') {
			$from =~ s/^(en|c.) //;
			$to =~ s/^(en|c.) //;
			if($from =~ /^le (.+)/) {
				$from = "du $1";
			} else {
				$from = "de $from";
			}
			if($to =~ /^le (.+)/) {
				$to = "au $1";
			} else {
				$to = "\N{U+00E0} $to";
			}
			return "$from $to";
		}
		$from =~ s/^(in|on|c.) //;
		$to =~ s/^(in|on|c.) //;
		if($language eq 'German') {
			return "von $from bis $to";
		}
		return "from $from to $to";
	}

	if($string =~ /(.+)\s(\d{4})\/\d{2}/) {
		my $year = $2 + 1;
		complain({ person => $params->{'person'}, warning => "old-style date ($string) should be in $year" });
		$string = "$1 $year";
	}

	if(($string =~ /^\d/) && ($string !~ /[a-z]$/i)) {
		# Precise date
		my $person = $params->{'person'};
		if($string =~ /^31 Nov/) {
			complain({ person => $person, warning => "$string is invalid, there are only 30 days in November" });
			return;
		}
		if(my $d = date_parser_cached(date => $string)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if(my $must_postdate = $params->{'must_postdate'}) {
				complain({
					person => $person,
					warning => [ "Something is wrong with the date $string which should be after ", $must_postdate->strftime('%x') ],
					# stack_trace => 1,
				}) if($d < $must_postdate);
			}
			if(my $must_predate = $params->{'must_predate'}) {
				complain({ person => $person, warning => "Something is wrong with the date $string which should be before " . $must_predate->strftime('%x') }) if($d > $must_predate);
			}
			if($ENV{'LC_TIME'}) {
				$d->set_locale($ENV{'LC_TIME'});
			} elsif($ENV{'LC_ALL'}) {
				$d->set_locale($ENV{'LC_ALL'});
			} elsif($ENV{'LANG'}) {
				$d->set_locale($ENV{'LANG'});
			}
			# if($language eq 'French') {
				# # FIXME: French Canadian time etc.
				# my $rc = DateTime->from_object(object => $d, locale => 'FR-fr')->strftime('%x');
				# if($rc =~ /^[AEIOU]/) {
					# return "l'$rc";
				# }
				# return "le $rc";
			# } else {
				# if(my $locale = ($ENV{'LC_TIME'} // $ENV{'LC_ALL'} // $ENV{'LANG'})) {
					# $locale =~ s/_/-/;
					# return 'on ' .
						# DateTime->from_object(object => $d, locale => $locale)->strftime('%x');
				# }
				# return 'on ' . $d->strftime('%x');
			# }
			if($language eq 'French') {
				my $year = $d->strftime('%x');
				if($year =~ /^[AEIOU]/) {
					return "l'$year";
				}
				return "le $year";
			}
			my $year;
			if($language eq 'Farsi') {	# For Tulip
				$year = HTML::Entities::decode(Lingua::FA::Number::convert($d->strftime('%Y %b %e')));
			} else {
				$year = $d->strftime('%x');
			}
			return "on $year";
		}
		if($@) {
			# RT 107354
			chomp $@;
			if($opts{'f'}) {
				if($person) {
					die $person->as_string(), ": $@";
				}
				die $@;
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => $@ });
			}
		}
		if($language eq 'French') {
			return "en $string";
		}
		return "on $string";
	}

	if($string =~ /^bef.*\s+(\d{3,4})/i) {
		if($string !~ /^bef.? (\d{3,4})/i) {
			if(my $person = $params->{'person'}) {
				complain({ person => $person, warning => "Date '$string' should start with 'Bef'" });
			} else {
				complain("Date '$string' should start with 'Bef'");
			}
		}
		return i18n({ format => 'before %s', args => $1 });
	}
	if($string =~ /^by.? (\d{3,4})/i) {
		return "by $1";
	}
	if($string =~ /^By (\d{3,4})/i) {
		if(my $person = $params->{'person'}) {
			complain({ person => $person, warning => "says 'By' instead of 'Bef'" });
		} else {
			complain("says 'By' instead of 'Bef'");
		}
		return i18n({ format => 'before %s', args => $1 });
	}
	if($string =~ /^aft.? (\d{3,4})/i) {
		return i18n({ format => 'after %s', args => $1 });
	}

	if($params->{'nopreposition'}) {
		return $string;
	}
	if($string =~ /^bef\s(.+)/i) {
		return i18n({ format => 'before %s', args => $1 });
	}
	if($string =~ /^aft\s(.+)/i) {
		if(my $d = date_parser_cached(date => $1)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($ENV{'LC_TIME'}) {
				$d->set_locale($ENV{'LC_TIME'});
			} elsif($ENV{'LC_ALL'}) {
				$d->set_locale($ENV{'LC_ALL'});
			} elsif($ENV{'LANG'}) {
				$d->set_locale($ENV{'LANG'});
			}
			return i18n({ format => 'after %s', args => $d->strftime('%x') });
		}
		return i18n({ format => 'after %s', args => $1 });
	}
	if($language eq 'French') {
		return (($string =~ /^[A-Z]/) || ($string =~ /\d$/)) ? "en $string" : "le $string";
	}
	if(defined($ENV{'LANG'}) && ($ENV{'LANG'} =~ /^en_US/)) {
		$string = ucfirst(lc($string));	# Starts with a month name so it's easily capitalised
	}
	return ($string =~ /\d$/) ? "in $string" : "on $string";
}

sub place
{
	my $params = Params::Get::get_params(undef, @_);

	my $place = $params->{'place'};
	my $address = $params->{'address'};

	if(!defined($params->{'encode'})) {
		$params->{'encode'} = 1;
	}

	if(!defined($place)) {
		$place = $params->{'record'};
		return unless($place);

		if(ref($place) eq 'Gedcom::Record') {
			my $p = $place;
			$address = $place->address();
			if(ref($address) eq 'Gedcom::Record') {
				$place = getaddress($address);
				$address = undef;
			} elsif($place = $place->place()) {
				$place = undef if($place eq '-');
			}
			if(!defined($place)) {
				if($opts{'w'} && (!$params->{'allow_empty'}) && $params->{'record'}->type() && ($params->{'record'}->type() ne 'Story')) {
					if(my $date = $p->date()) {
						if($date =~ /^bet\s*(.+)/i) {
							complain({ person => $params->{'person'}, warning => "Location for the event between $1 is empty" });
						} else {
							complain({ person => $params->{'person'}, warning => 'Location for "' . lcfirst($params->{'record'}->type()) . "\" on $date is empty" });
						}
					} else {
						complain({ person => $params->{'person'}, warning => 'Location is Empty' });
					}
				}
				return;
			}
		}
	} elsif(ref($address)) {
		$place = getaddress($address);
		$address = undef;
	}

	$place =~ s/[\.,]+$//;	# remove trailing full stops and commas
	$place =~ s/\s\s+/ /;

	return if(lc($place) eq 'unknown');

	# if((!defined($address)) &&
	   # ($place !~ /USA$/) && ($place !~ /United States$/) &&
	   # ($place =~ /(.+),\s*(.+,\s*.+,\s*.+)$/)) {
		# $address = $1;
		# $place = $2;
	# }

	# Google maps (and possibly others) sometimes works better with full names
	my $on_road;
	if($address) {
		$address =~ s/\xc3\xb1/\N{U+00F1}/g;	# Ã±
		$address =~ s/\xc3\xa9/\N{U+00E9}/g;	# Ã©
		if($address =~ /(.+)\sSt\.?$/) {
			$address = "$1 Street";
			$on_road = 1;
		} elsif($address =~ /(.+)\sAve\.?$/) {
			$address = "$1 Avenue";
			$on_road = 1;
		} elsif($address =~ /(.+)\s(Rd|Road)\.?$/) {
			$address = "$1 Road";
			$on_road = 1;
		} elsif($address =~ /(.+)\sLn\.?$/) {
			$address = "$1 Lane";
			$on_road = 1;
		} elsif($address =~ /\sLane$/) {
			$on_road = 1;
		}
		if($address =~ / Church, /) {
			$on_road = 0;
		}
	}

	my $there = $params->{'there'};

	if($there && ($place eq $there)) {
		if($address) {
			if($place =~ /^(.+?),.+,/) {
				if($params->{'nopreposition'}) {
					return " $address, $1";
				}
				if($language eq 'French') {
					return " \N{U+00E0} $address, $1";
				}
				return " at $address, $1";
			}
		} else {
			return ' there';
		}
	}

	# The more consistent the data, the fewer lookups on Geocoders and the smoother the English output
	my $rc = Lingua::String->new('en' => $place);
	my $lang = get_language_code() // 'en';
	if($lang ne 'en') {
		$rc->set({ lang => $lang, string => $place });
	}
	# $place =~ s/\xc3\xa9/Ã©/g;
	$place =~ s/\xc3\xa9/\N{U+00E9}/g;

	if(($place =~ /(.+?)\s*United States$/i) || ($place =~ /(.+?)\s*United States of America$/i)) {
		$place = "$1 USA";
		$rc->en($place);
	} elsif($place =~ /States\s.*$/) {
		complain({ person => $params->{'person'}, warning => "Unexpected text at the end of the place '$place'" });
	} elsif($place =~ /(.*)(^|,\s*)(.+),\s*Canada$/i) {
		my $town = $1;
		my $province = $3;

		$rc->en($place);

		if(defined(my $p = $ca_en->{province2code}{uc($province)} || $ca_fr->{province2code}{uc($province)})) {
			my $ca;
			if($language eq 'French') {
				$ca = $ca_fr;
			} else {
				$ca = $ca_en;
			}
			if($p eq 'QC') {
				if($language eq 'French') {
					$p = "Qu\N{U+00E9}bec";
					if($town eq 'MontrÃ©al') {
						$town = "Montr\N{U+00E9}al";
					}
					$rc->fr("$town, Qu\N{U+00E9}bec, Canada");
				} else {
					$p = 'Quebec';
					if(($town eq 'MontrÃ©al') || ($town eq "Montr\N{U+00E9}al")) {
						$town = 'Montreal';
					}
					$rc->en("$town, Quebec, Canada");
				}
			} else {
				$p = sortoutcase($ca->{code2province}{$p});
			}
			if(defined($town) && length($town)) {
				$place = "$town, $p, Canada";
			} else {
				$place = "$p, Canada";
			}
			$rc->set({ lang => $lang, string => $place });
		} elsif($province =~ /^Qu.+bec$/) {
			if($language eq 'French') {
				$province = "Qu\N{U+00E9}bec";
				$town =~ s/Ã©/\N{U+00E9}/g;
				$rc->fr("$town, Qu\N{U+00E9}bec, Canada");
			} else {
				$province = 'Quebec';
				if($town eq 'MontrÃ©al') {
					$town = 'Montreal';
				}
				$rc->en("$town, Quebec, Canada");
			}
			if(defined($town) && length($town)) {
				$place = "$town, $province, Canada";
			} else {
				$place = "$province, Canada";
			}
			$rc->set({ lang => $lang, string => $place });
		} else {
			complain({ person => $params->{'person'}, warning => "Unknown Canadian province $province" });
		}
	} elsif($place =~ /(.*)(^|,\s*.+),\s*(UK|England|Wales|Scotland)$/i) {
		# Translate the city from English
		# TODO: if language eq English, translate a city to English
		if($language ne 'English') {
			# if($language ne 'French') {
				# die "TODO: add language $language";
			# }
			# FIXME: should be table driven
			$rc->en($place);
			if(my $t = $places->translate({ place => $1, from => 'en', to => $lang })) {
				$place = "$t$2, $3";
				$place =~ s/Ã©/\N{U+00E9}/g;
				$rc->set(lang => $lang, string => $place);
			}
		}
	}

	if($params->{'person'}) {
		validate_place({ person => $params->{'person'}, place => $rc });
	}

	# utf8::decode($place);
	if($place =~ /,,/) {
		complain({ person => $params->{'person'}, warning => "Consecutive commas found in '$place'" });
		$place =~ s/,,/,/g;
		$place =~ s/,(\S)/, $1/g;
	}
	if($place =~ /,(\S)/) {
		complain({ person => $params->{'person'}, warning => "Space missing after comma in '$place'" });
		$place =~ s/,(\S)/, $1/g;
	}

	if($place =~ /^\d/) {
		if(my $places_printed = $params->{'places_printed'}) {
			$places_printed->{" at$place"} = 1;
			if($place =~ /(.+),(.+?),(.+?),(.+?),(.+?)$/) {
				if($places_printed->{" in$3,$4,$5"}) {
					$places_printed->{"at $1,$2,$3"} = 1;
					if($params->{'nopreposition'}) {
						return "$1,$2,$3";
					}
					if($language eq 'French') {
						return " \N{U+00E0} $1,$2,$3";
					}
					return " at $1,$2,$3";
				}
			}
			if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
				$places_printed->{" in$2,$3,$4"} = 1;
			}
		}
		if($params->{'nopreposition'}) {
			return " $place";
		}
		if($language eq 'French') {
			return " \N{U+00E0} $place";
		}
		return " at $place";
	}

	if($place eq 'USA') {
		if($language eq 'French') {
			if($params->{'nopreposition'}) {
				return " \N{U+00C9}tats-Unis";
			}
			return " aux \N{U+00C9}tats-Unis";
		}
		if($language eq 'German') {
			if($params->{'nopreposition'}) {
				return ' der Vereinigten Staaten';
			}
			return ' in den Vereinigten Staaten';
		}
		if($params->{'nopreposition'}) {
			return ' USA';
		}
		return ' in the USA';
	}

	if($address) {
		# utf8::decode($address);
		if($params->{'nopreposition'}) {
			$place = " $address, $place";
			$rc->en(" $address, " . $rc->en());
		} elsif($language eq 'French') {
			$place = " \N{U+00E0} $address, $place";
			$rc->fr($place);
			$rc->en("$address, " . $rc->en());
		} elsif($on_road && ($address =~ /^[a-z]+\s+.*[a-z]+$/i)) {
			if($address =~ /^The .+ Hall,/) {
				# e.g. at The Salvation Army Hall
				$place = " at $address, $place";
			} else {
				# e.g on Appleby Street
				$place = " on $address, $place";
			}
		} elsif($address =~ / Road$/) {
			$place = " on $address, $place";
			$rc->en(" on $address, " . $rc->en());
		} else {
			$place = " at $address, $place";
			$rc->en(" at $address, " . $rc->en());
		}
	} elsif($params->{'nopreposition'}) {
		$place = " $place";
	} elsif($place =~ /^Isle of /) {
		$place = " on the $place";
	} elsif(($language eq 'French') && ($place =~ /,/)) {
		$place = " \N{U+00E0} $place";
	} else {
		$place = " in $place";
	}
	$rc->set({ lang => $lang, string => $place });

	if(my $places_printed = $params->{'places_printed'}) {
		if(($language eq 'French') && ($place =~ /(.+), London, England/)) {
			$place = "$1, Londres, Angleterre";
			$rc->fr($place);
		}
		if($places_printed->{$place} && ($place =~ /^(.+?),/)) {
			# Only print the town if the location has already been printed
			$place = $1;
			$place =~ s/\.$//g;	# https://github.com/nigelhorne/ged2site/issues/112
			return $place;
		}
		if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
			my $str = "$2,$3,$4";
			if($params->{'person'} && $address) {
				validate_place({ person => $params->{'person'}, place => $place });
			}
			if($places_printed->{" in$str"}) {
				if(($4 eq ' USA') || ($4 eq ' Canada')) {
					return "$1,$3";
				}
				my $road = $1;
				my $town = $2;
				my $country = $4;
				if(($town !~ /,/) || !defined($address)) {
					if($language eq 'French') {
						return "$road \N{U+00E0}$town";
					}
					# Avoid "in in Paris"
					$road =~ s/^\s*in//;
					$road =~ s/\s+$//;
					$town =~ s/[\s\.]+$//;
					if(($road eq '') && ($town eq '')) {
						return "in$country";
					}
					return "$road in$town";
				}
				return $address;
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2";
			}
			$str = "$3,$4";
			if($places_printed->{" in$str"} || $places_printed->{" at$str"}) {
				if($params->{'encode'}) {
					return wide_to_html("$1,$2,$3");
				}
				return "$1,$2,$3";
			}
			$places_printed->{" in$str"} = 1;
			$places_printed->{" in$2,$3,$4"} = 1;
		} elsif($place =~ /(.+),(.+),(.+)$/) {
			# e.g. Southwark, London, England
			if($places_printed->{" in$2,$3"}) {
				# We did place, county, country before, so just
				# return place, county
				my($city, $state, $country) = ($1, $2, $3);
				$city =~ s/^ in//;

				if("$state,$country" eq ' London, England') {
					if($params->{'nopreposition'}) {
						$rc->fr("$city, Londres");
						$rc->en("$city, London");
					} else {
						$rc->fr(" \N{U+00E0}$city, Londres");
						$rc->en(" in$city, London");
					}
				} elsif($params->{'nopreposition'}) {
					$rc->fr("$city,$state");
					$rc->en("$city,$state");
				} else {
					$rc->fr(" \N{U+00E0}$city,$state");
					$rc->en(" in$city,$state");
				}
				if($params->{'encode'}) {
					$rc->encode();
				}
				return $rc;
			}
			$places_printed->{" in$2,$3"} = 1;
		}
		$places_printed->{$place} = 1;
	}

	if($lcm) {
		$rc->set({ lang => $lang, string => $place });
		if($place =~ /(.*),\s+([A-Z\s]+)$/i) {
			my $c = $2;
			if($c eq 'USA' || ($c eq 'US')) {
				$c = 'United States';
			}
			if(($language eq 'French') && ($c eq 'England')) {
				$rc->fr("$1, Angleterre");
			} elsif(($language eq 'French') && ($c eq 'France')) {
				$place =~ s/Normandy,/Normandie,/;
				$rc->fr($place);
			} elsif(($language eq 'English') && ($c eq 'France')) {
				$place =~ s/Normandie,/Normandy,/;
				$rc->en($place);
			} elsif(($language eq 'French') && ($c eq 'Scotland')) {
				$rc->fr("$1, Ecosse");
			} elsif(($language eq 'French') && ($c eq 'Wales')) {
				$rc->fr("$1, Pays de Galles");
			} elsif(($language eq 'Welsh') && ($c eq 'Wales')) {
				my $town = $1;
				$town =~ s/Swansea$/Abertawe/;
				$rc->cy("$town, Cymru");
			} elsif(my $code = $lcm->country2code($c, 'LOCALE_CODE_ALPHA_2', 'en')) {
				# Translate the name of the country into the current locale
				$c = $lcm->code2country($code, $lang);
				if($c ne 'United States') {
					# utf8::decode($c);
					my $place = $1;
					$c =~ s/Ã/\N{U+00C9}/g;
					$rc->set({ lang => $lang, string => "$place, $c" });
				}
			}
		} elsif($place !~ /,/ && ($language ne 'English')) {
			$rc->en($place);
			my $en = $place;
			$en =~ s/^ in //;
			if(my $code = $lcm->country2code($en, 'LOCALE_CODE_ALPHA_2', 'en')) {
				$place = $lcm->code2country($code, $lang);
				if(!$params->{'nopreposition'}) {
					if($language eq 'French') {
						my $preposition;
						if($place =~ /e$/) {
							# TODO: others https://yolainebodin.com/the-language-nook/french/gender-of-countries-in-french
							if($place eq 'Mexique') {
								$preposition = 'au';
							} else {
								$preposition = 'en';
							}
						} else {
							if($place =~ /^[aeiou]/) {
								$preposition = 'en';
							} else {
								$preposition = 'au';
							}
						}
						# utf8::decode($place);
						$place = " $preposition $place";
					}
				}
				$rc->set({ lang => $lang, string => $place });
			}
		}
	}

	$rc =~ s/\.$//;

	if($params->{'encode'}) {
		$rc->encode();
	}

	return $rc;
}

sub getaddress
{
	my $address = shift;

	# Concatenate non-empty values with ', ' as the separator
	my $rc = join(', ', grep { $_ } $address->city(), $address->state(), $address->country());

	return $rc;
}

# paragraph => 0: ignore spacing and put it all into one paragraph
# You may wish to apply this patch to Gedcom::Item
#	https://github.com/pjcj/Gedcom.pm/compare/main...jhannah:Gedcom.pm:master
sub notes
{
	my $params = Params::Get::get_params('record', @_);

	my $record = $params->{'record'};

	if(!$record) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'Usage: notes(record => $record)';
	}

	my $person = $params->{'person'};
	my $paragraph = $params->{'paragraph'};
	my @notes = $record->get_record('note');
	my $note_locations = $params->{note_locations};
	my $encode = $params->{'encode'} // 0;

	# my @deathnotes = get_value({ person => $person, value => 'death note' });
	my $rc = $record->get_value();
	$rc .= '.' if($rc && !scalar(@notes));
	$rc = undef if(defined($rc) && (lc($rc) eq 'was recorded at this address'));

	foreach my $note(@notes) {
		if($note) {
			if(ref($note) eq 'Gedcom::Record') {
				$note = $note->full_value();	# Include CONC records

				# Handle linked notes
				# https://github.com/nigelhorne/ged2site/issues/114
				if(my $n = $ged->resolve_xref($note)) {
					$note = $n->full_value();
				}
			# } else {
				# complain("Note record is just description ($note), information may have been lost");
			}
			$note =~ s/\r//g;
			next if($note =~ /^\s*$/);
			$note =~ s/ \n/\n/g;
			if($paragraph) {
				$note =~ s/\n+/<\/p><p>/g;
			} else {
				$note =~ s/\n+/; /g;
			}
			$note =~ s/\s\s+/ /g;
			$note =~ s/\s+$//g;
			$note =~ s/\.$//;

			if($note =~ /\.\s\s/) {
				$note =~ s/Dr\.\s\s/Dr. /g;
				$note =~ s/Mr\.\s\s/Mr. /g;
				$note =~ s/Mrs\.\s\s/Mrs. /g;
				$note =~ s/Rev\.\s\s/Rev. /g;
				$note =~ s/St\.\s\s/St. /g;
				$note =~ s/([A-Z]\.\s)\s/$1/g;
			}

			# FIXME: a lot of duplicated code here
			if(defined($rc)) {
				if($rc ne $note) {
					$rc =~ s/\s$//g;
					if($paragraph) {
						if($encode) {
							$rc .= '<p>' . HTML::Entities::encode($note) . '.</p>';
							$rc =~ s/\n+/<\/p><p>/g;
						} else {
							$rc .= "<p>$note.</p>";
						}
					} else {
						if($rc) {
							$rc .= ' ';
						}
						if($encode) {
							$rc .= HTML::Entities::encode($note);
						} else {
							$rc .= $note;
						}
						$rc .= '.' if($note !~ /(\."?|<\/p>)$/);
					}
				} else {
					# complain("Note record ($note) is the same as the description");
				}
			} else {
				if($paragraph) {
					if($encode) {
						$rc = '<p>' . HTML::Entities::encode($note) . '.</p>';
						$rc =~ s/\n+/<\/p><p>/g;
					} else {
						$rc = "<p>$note.</p>";
					}
				} else {
					if($encode) {
						$rc = HTML::Entities::encode($note);
					} else {
						$rc = $note;
					}
				}
			}
		} else {
			complain('Notes field is empty');
		}
	}
	if((!defined($rc)) || (length($rc) == 0)) {
		return;
	}
	$rc =~ s/([\.:]); /$1 /g;
	$rc =~ s/&lt;\/p&gt;&lt;p&gt;/<\/p><p>/g;	# avoid double encoding

	my @matches;

	if(defined($note_locations)) {
		my $region;

		if($record) {
			$region = $record->place();
		}
		if(!$region && $person) {
			$region = get_value({ person => $person, value => 'birth place' });
			if(!$region) {
				$region = get_value({ person => $person, value => 'death place' });
			}
		}
		if($region && ($region =~ /^.+,\s([[a-z\s]+)$/i)) {
			if($1 =~ /(England|United Kingdom)/i) {
				$region = 'GB';
			} elsif($1 =~ /(USA|US|United States)/i) {
				$region = 'US';
			} elsif(lc($1) eq 'Canada') {
				$region = 'CA';
			} elsif(lc($1) eq 'Australia') {
				$region = 'AU';
			} else {
				$region = undef;
			}
		}

		# Scan the notes for locations to include in the map
		if($freegeocoder) {
			my @ignore_words = ('church', 'dale', 'law', 'middle', 'back', 'hill', 'british', 'street');
			if($person) {
				# Don't find places that match the person's name
				push @ignore_words, split(/\s/, given_names($person)), $person->surname();
			}
			@matches = $freegeocoder->geocode(scantext => $rc, region => $region, ignore_words => \@ignore_words);
		} elsif($textgeocoder && ($rc =~ /[\s,]/)) {
			@matches = $textgeocoder->geocode(scantext => $rc, region => $region);
		}

		foreach my $hr(@matches) {
			if(!ref($hr)) {
				next;
			}
			if(ref($hr) eq 'HASH') {
				if($hr->{'error'}) {
					if($hr->{'error'}->{'description'} =~ /^We currently throttle/) {
						$textgeocoder = undef;
						last;
					}
					# die "$rc: ", $hr->{'error'}->{'description'};
				} else {
					my $matches = $hr;
					if($matches->{'match'}) {
						$matches = $matches->{'match'};
						warn '(DEBUG) ', Data::Dumper->new([$matches])->Dump();
					}
					if(ref($matches) eq 'ARRAY') {
						my $text;
						if(length($rc) > 15) {
							$text = substr($rc, 0, 32) . '...';
						} else {
							$text = $rc;
						}
						foreach my $match(@{$matches}) {
							# print Data::Dumper->new([$match])->Dump();
							# my $place = $match->{'location'};
							# print "$place\n";
							$match->{'text'} = wide_to_html($text);
							warn '(DEBUG) ', Data::Dumper->new([$match])->Dump();
							push @{$note_locations}, $match;
						}
					} elsif(ref($matches) eq 'HASH') {
						my $match = $matches;
						if($match->{'country'} && (uc($match->{'country'}) eq $region)) {
							# my $place = $match->{'location'};
							if(length($rc) > 15) {
								$match->{'text'} = wide_to_html(substr($rc, 0, 32)) . '...';
							} else {
								$match->{'text'} = $rc;
							}
							warn "(DEBUG)\n\t$rc\n\t", Data::Dumper->new([$match])->Dump();
							push @{$note_locations}, $match;
						}
					}
				}
			} elsif(ref($hr) eq 'ARRAY') {
				warn 'TODO: ', Data::Dumper->new([$hr])->Dump();
			} elsif($hr->can('lat') && defined($region) && $hr->country() && ($hr->country() eq $region)) {
				# Geo::Location::Point
				warn '(DEBUG): ', Data::Dumper->new([$hr])->Dump(), "\n\t", ref($hr), "\n\t", $hr->as_string();
				push @{$note_locations}, {
					confidence => $hr->confidence(),
					location => $hr->location(),
					text => (length($rc) > 15) ? substr($rc, 0, 24) . '...' : $rc,
					latitude => $hr->lat(),
					longitude => $hr->long()
				}
			}
		}
	}

	if($paragraph) {
		$rc =~ s/\n{2,}/<\/p><p>/g;
	} else {
		$rc =~ s/\s\s+/ /g;
	}
	$rc =~ s/\n/<br>/g;
	$rc =~ s/ $//;
	$rc =~ s/!/\&excl;/g;	# ! is the sep_char

	my $ufinder = URI::Find::Schemeless->new(sub {
		my($uri, $orig_uri) = @_;

		if($orig_uri =~ /(.+):$/) {
			$orig_uri = $1;
		}
		my $u = URI->new($orig_uri);
		if($u && (ref($u) ne 'URI::_generic')) {
			# Some sites give 404 on HEAD but work on GET
			if((!LWP::Simple::WithCache::head($orig_uri)) && !LWP::Simple::WithCache::get($orig_uri)) {
				complain({ person => $person, warning => "$orig_uri: in notes is not found" });
			}
			$uri =~ s/:$//;
			if($uri =~ /^mailto:/) {
				$uri = $u->path();
				$uri =~ s/\@/ AT /;
				return $uri;
			}
			return "<a href=\"$uri\">" .
				$u->host() .
				'</a>';
		}
		return $orig_uri;
	});

	$ufinder->find(\$rc);

	if($language eq 'English') {
		if($ENV{'LANG'} =~ /^en_US/) {
			return Lingua::EN::ABC::b2a($rc);
		} elsif($ENV{'LANG'} =~ /^en_CA/) {
			return Lingua::EN::ABC::b2c($rc);
		} else {
			return Lingua::EN::ABC::a2b($rc);
		}
	}
	return $rc;
}

sub validate_place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	if(!$place) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'place is not optional';
	}

	$place =~ s/^\s+//;
	if($language eq 'French') {
		$place =~ s/^\N{U+00E0}\s+//;
	} else {
		$place =~ s/^at\s+//;
	}
	if(defined($places{$place})) {
		return $places{$place};
	}

	# US and Canada are more logical, using city,county,state,country, than other countries
	if($opts{'w'} && (($place !~ /,.*,.*,.*/) || ($place =~ /USA|Canada/i))) {
		if($place =~ /(.*),\s*Independent Cities\s*(.*)/i) {
			$place = "$1$2";
		}
		$place =~ s/^(in|at)\s//;
		if(defined($places{$place})) {
			return $places{$place};
		}
		# my $ap;
		# my $p = $place;
		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# $ap = Lingua::EN::AddressParse->new(country => 'US', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
		# } elsif($place =~ /England$/) {
			# $ap = Lingua::EN::AddressParse->new(country => 'GB', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
			# $p .= ', United Kingdom';
		# }
		# if($ap) {
			# my $error = $ap->parse("$address, $p");
			# print $ap->report();
		# }

		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# if(my $href = Geo::StreetAddress::US->parse_location($place)) {
				# if($href->{'state'} && !$us->{code2state}{$href->{'state'}} && !$us->{state2code}{$href->{'state'}) {
				# die $href->{'state'};
					# complain({ person => $params{'person'}, warning => "Unknown state in $place" });
				# }
			# }
		# }
		if((($place =~ /USA$/) || ($place =~ /United States$/) || ($place =~ /U\.S\.A\./)) &&
		    ($place =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
			my $state = uc($1);
			if((!$us->{code2state}{$state}) && !$us->{state2code}{$state}) {
				complain({ person => $params{'person'}, warning => "Unknown state '$state' in $place" });
			} elsif($place =~ /\sWard \d+,/) {
				complain({ person => $params{'person'}, warning => "Census ward number left in location '$place'" });
			}
		}

		print "Look up location $place\n", if($opts{'v'});
		if($opts{'w'}) {
			# Strange locations in censuses
			if($place =~ /Royal Navy/) {
				return 0;
			}
			# Force wantarray for improved caching in
			# G:C:L
			if(($place eq 'England') || ($place eq 'Scotland')) {
				$place = 'United Kingdom';
			} elsif($place eq 'U.S.A.') {
				$place = 'USA';
			}
			# my @locations = $geocoder->geocode($place);
			my @locations = get_location($place);
			if(scalar(@locations) == 0) {
				# Don't die because there are many
				# false positives as locations
				# may no longer exist
				if(my $person = $params{'person'}) {
					warn colored($person->as_string({ include_years => 1 }) . ": unknown location $place", 'red');
				} else {
					warn colored("Unknown location $place", 'red');
				}
				$places{$place} = 0;
				return 0;
			} elsif(($place !~ /,/) && !Locale::Country::country2code($place)) {
				if(my $person = $params{'person'}) {
					complain({ person => $person, warning => "Country not included in country, or misspelt country '$place'" });
				} else {
					complain("Country not included in country, or misspelt country '$place'");
				}
				$places{$place} = 0;
				return 0;
			}
		}
	}
	$places{$place} = 1;
	return 1;
}

sub person_line_html
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	if($opts{'l'} || !is_alive(%params)) {
		if(my $dob = dateofbirth($person)) {
			return '<a href="' . make_filename_from_person(person => $person) . '">' .
				wide_to_html(given_names($person)) .
				'</a> was born ' .
				year({ person => $person, date => $dob });
		} elsif(my $bd = get_value({ person => $person, value => 'baptism date' })) {
			return '<a href="' . make_filename_from_person(person => $person) . '">' .
				wide_to_html(given_names($person)) . "</a> was born c. $bd";
		}
		return '';
	}
	return '<a href="' . make_filename_from_person(person => $person) . '">' .
		wide_to_html(given_names($person)) .
		'</a>';
}

sub person_line_csv
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	if($opts{'l'} || !is_alive(%params)) {
		if(my $dob = dateofbirth($person)) {
			return '<a href="?page=people&amp;entry=' . $person->xref() . '">' .
				wide_to_html(given_names($person)) .
				'</a> was born ' .
				year({ person => $person, date => $dob });
		} elsif(my $bd = get_value({ person => $person, value => 'baptism date' })) {
			return '<a href="?page=people&amp;entry=' . $person->xref() . '">' .
				wide_to_html(given_names($person)) . "</a> was born c. $bd";
		}
		return '';
	}
	# return '<a href="?page=people&entry=' . $person->xref() . '">' .
		# $person->given_names() .
		# '</a>';
	return wide_to_html(given_names($person));
}

# Are two places the same? exact => 1 means must be equal, otherwise use fuzzy logic
sub places_are_the_same
{
	my $params = Params::Get::get_params(undef, @_);

	my $record1 = $params->{'first'};
	my $record2 = $params->{'second'};

	die 'first is not optional' unless $record1;
	die 'second is not optional' unless $record2;

	if((!ref($record1)) && (!ref($record2))) {
		return $record1 eq $record2;
	}

	my $place1 = $record1->place();
	return 0 unless(defined($place1));
	my $place2 = $record2->place();
	return 0 unless(defined($place2));

	my $person = $params->{'person'};
	if($person) {
		validate_place({ person => $person, place => $place1 });
		validate_place({ person => $person, place => $place2 }) unless(lc($place1) eq lc($place2));
	}

	if($place1 =~ /(.+?)\s*United States$/i) {
		$place1 = "$1 USA";
	}
	if(my $address = $record1->address()) {
		$place1 = $abbr->normalize($address) . ", $place1";
	}
	if(my $address = $record2->address()) {
		$place2 = $abbr->normalize($address) . ", $place2";
	}
	if($place2 =~ /(.+?)\s*United States$/i) {
		if($person) {
			complain({ person => $person, warning => "Changing 'United States' to 'USA' in $place2" });
		} else {
			complain("Changing 'United States' to 'USA' in $place2");
		}
		$place2 = "$1 USA";
	}
	# if($place2 =~ /(.+)\sSt\.?$/) {
		# if($person) {
			# complain({ person => $person, warning => "Changing 'St' to 'Street' in $place2" });
		# } else {
			# complain("Changing 'St' to 'Street' in $place2");
		# }
		# $place2 = "$1 Street";
	# } elsif($place2 =~ /(.+)\sAve\.?$/) {
		# if($person) {
			# complain({ person => $person, warning => "Changing 'Ave' to 'Avenue' in $place2" });
		# } else {
			# complain("Changing 'Ave' to 'Avenue' in $place2");
		# }
		# $place2 = "$1 Avenue";
	# } elsif($place2 =~ /(.+)\sRd\.?$/) {
		# if($person) {
			# complain({ person => $person, warning => "Changing 'Rd' to 'Road' in $place2" });
		# } else {
			# complain("Changing 'Rd' to 'Road' in $place2");
		# }
		# $place2 = "$1 Road";
	# }
	return 1 if(lc($place1) eq lc($place2));
	return 1 if(place(record => $record1, nopreposition => 1) eq place(record => $record2, nopreposition => 1));
	return 0 if($params->{'exact'});
	if(compare($place1, $place2) > 0.5) {
		if($person) {
			complain({ person => $person, warning => "The places '$place1' and '$place2' seem similar; is there a typo?" });
		} else {
			complain("The places '$place1' and '$place2' seem similar; is there a typo?");
		}
	}
	return 0;
}

sub sibling_baptism_string
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $siblings = $params{'siblings'};
	my $date = $params{'date'};
	my $birthdate = $params{'birthdate'};

	return '' if(scalar(@{$siblings}) == 0);

	my @onsameday;
	foreach my $sibling(@{$siblings}) {
		my $dateofsiblingbaptism = get_value({ person => $sibling, value => 'baptism date' });
		if($dateofsiblingbaptism && ($dateofsiblingbaptism eq $date)) {
			push @onsameday, $sibling;
		}
	}
	return '' if(scalar(@onsameday) == 0);

	my $allsamesex = 1;
	if(scalar(@onsameday) > 1) {
		foreach my $sibling(@onsameday) {
			if($sibling->sex() ne $person->sex()) {
				$allsamesex = 0;
				last;
			}
		}
		if($allsamesex) {
			foreach my $sibling(@onsameday) {
				my $dateofsiblingbirth = dateofbirth($sibling);
				if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
					$allsamesex = 0;	# Fudge to force special twin handler
				}
			}
		}
	} else {
		$allsamesex = 0;
	}

	if($allsamesex) {
		return ', ' . i18n('the same day as ') . lcfirst($person->possessive()) . ' ' .
			i18n(($onsameday[0]->sex() eq 'M' ? 'brothers ' : 'sisters ')) .
			conjunction(map {
				if($opts{'l'} || !is_alive($_)) {
					'<a href="?page=people&entry=' . $_->xref() . '">' . given_names($_) . '</a>'
				} else {
					given_names($_)
				}
			} @onsameday);
	}

	my @baptisms;
	foreach my $sibling(@onsameday) {
		my $baptism;

		if($language eq 'French') {
			$baptism = ($sibling->sex() eq 'F') ? 'sa ' : 'son ';
		} else {
			$baptism = lcfirst($person->possessive()) . ' ';
		}

		my $dateofsiblingbirth = dateofbirth($sibling);
		if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
			if($language eq 'French') {
				$baptism .= ($sibling->sex() eq 'F') ? 'jumelle ' : 'jumeau ';
			} else {
				$baptism .= 'twin ';
			}
		}
		$baptism .= i18n(($sibling->sex() eq 'M' ? 'brother ' : 'sister ')) .
			given_names($sibling);
		push @baptisms, $baptism;
	}
	return ', ' . i18n('the same day as ') . conjunction(@baptisms);
}

sub complain
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'warning'} = shift;
	}

	if(!defined($params{'warning'})) {
		if(defined($params{'message'})) {
			$params{'warning'} = $params{'message'};
		} else {
			my @call_details = caller(0);
			die "What do you want to say on line $call_details[2]?";
		}
	}

	# Support warning being a ref to an array
	if(ref($params{'warning'}) eq 'ARRAY') {
		$params{'warning'} = join('', @{$params{'warning'}});
	}
	if($opts{'f'}) {
		my @call_details = caller(0);
		if($params{'person'}) {
			die $params{'person'}->as_string(), ': ', ucfirst($params{'warning'}), ' at line ', $call_details[2];
		}
		die ucfirst($params{'warning'}), ' at line ', $call_details[2];
	}

	if($opts{'w'}) {
		$params{'caller'} = 1;
		red_warning(%params);
	}
}

sub red_warning
{
	return unless($opts{'w'});

	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	die 'What do you want to say?' unless($params{'warning'});

	my $warning = HTML::Entities::decode($params{'warning'});
	my @call_details = caller($params{'caller'} || 0);
	if($params{'person'}) {
		warn colored(['red'], $params{'person'}->as_string(middle_names => 1), ": $warning at line ", $call_details[2]);
		push @{$params{'person'}->{'warnings'}}, $warning;
	} else {
		if($opts{'W'}) {
			print STDERR $params{'warning'}, "\n";
		} else {
			warn colored(['red'], $params{'warning'}, ' at line ', $call_details[2]);
		}
	}
	if($params{'stack_trace'}) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", colored($call_details[1] . ':' . $call_details[2] . ' calling function ' . $call_details[3], 'red'), "\n";
		}
	}
}

# Cache gedcom values
sub get_value
{
	my $params = Params::Get::get_params(undef, @_);

	# if($fetcher) {
		# my $args = {
			# object => $params{'person'},
			# message => 'get_value',
			# arg => $params{'value'}
		# };

		# # Doesn't use the prefetching feature, but will automatically cache which is nice
		# # $fetcher->prime($args);
		# return $fetcher->get($args);
	# }
	my $person = $params->{'person'};
	if(!defined($person)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: person argument is mandatory';
	}
	if(!ref($person)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die "BUG: person argument isn't an object";
	}
	return $params->{'person'}->get_value($params->{'value'});
}

sub get_source
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;
	my $source = $params{'source'};

	# my $args = {
		# object => $params{'gedcom'},
		# message => 'get_source',
		# arg => $params{'source'}
	# };

	# # Doesn't use the prefetching feature, but will automatically cache which is nice
	# # $fetcher->prime($args);
	# return $fetcher->get($args);
	if(ref($source)) {
		if($source->title()) {
			return $source;
		}
		return;
	}
	return $params{'gedcom'}->get_source($source);
}

# Inspired by Tree::Family.  That module doesn't quite do what I want, so
# I've mercilessly re-used the ideas of what to do from it.
sub print_graphviz
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $colour = $params{'colour'};
	my $profile_image = $params{'profile_image'};

	if(!defined($colour)) {
		my $gender = get_value({ person => $person, value => 'sex' }) || $person->sex();
		if(defined($gender)) {
			$gender = $gender;
		} else {
			complain({ person => $person, warning => 'unknown sex' });
			$gender = 'M';	# Avoid "Use of uninitialized value" in Tree::Family
		}
		$colour = ($gender eq 'M' ? '#093AB5' : '#C666B8');
	}

	print $fout $person->xref(), ' [shape=box,fontsize="10",',
		"color=\"$colour\",";

	my $is_alive = is_alive(person => $person);

	if(!$is_alive || $opts{'l'}) {
		if($params{'format'} eq 'dynamic') {
			print $fout 'href="?page=people&amp;entry=', $person->xref(), '",';
		} else {
			print $fout 'href="', make_filename_from_person(person => $person), '",';
		}
	}

	my $label;
	my $dob;
	my $dod;
	if($is_alive && !$opts{'l'}) {
		$label = 'Living';
	} else {
		# We're using UTF-8 for the graphviz encoding

		# https://github.com/nigelhorne/ged2site/issues/117
		# $label = wide_to_html($person->as_string());
		$label = HTML::Entities::decode($person->as_string());

		# Fields which HTML::Entities doesn't decode
		$label =~ s/\N{U+00E4}/Ã¤/g;
		$label =~ s/\xc3\xa4/Ã¤/g;
		$label =~ s/\N{U+010D}/Ä/g;
		$label =~ s/\xc4\x8d/Ä/g;
		$label =~ s/\N{U+0160}/Å /g;
		$label =~ s/\xc5\xa0/Å /g;
		$label =~ s/\N{U+0161}/Å¡/g;
		$label =~ s/\xc5\xa1/Å¡/g;
		$label =~ s/\xc5\xbe/Å¾/g;
		$label =~ s/\N{U+017E}/Å¾/g;
		$label =~ s/\xc3\xa7/Ã§/g;
		$label =~ s/\N{U+00E7}/Ã§/g;

		$dob = dateofbirth($person);
		$dod = dateofdeath($person);
	}

	my $thumbnail;

	# If you get 'Warning: No loadimage plugin for "jpeg:cairo"', do this
	# instead:
	# if(0) {
	if($profile_image && (!$is_alive || $opts{'l'})) {
		if(!-r $profile_image) {
			die $person->as_string(), ": can't read $profile_image";
		}
		if(defined($dob)) {
			$dob .= "<TR><TD>b. $dob</TD></TR>";
		} else {
			$dob = '';
		}
		if(defined($dod)) {
			$dod .= "<TR><TD>d. $dod</TD></TR>";
		} else {
			$dod = '';
		}
		# Create a thumbnail
		my $image = Image::Magick->new();
		$image->read($profile_image);
		my ($thumb, $x, $y) = Image::Magick::Thumbnail::create($image, 100);
		my @thumbname = File::Basename::fileparse($profile_image);
		# use PNG to try to avoid
		#	'Warning: No loadimage plugin for "jpeg:cairo"'
		$thumbname[0] =~ s/\.jpg$/.png/i;
		$thumbnail = "thumbs/$thumbname[0]";
		$thumb->Write($thumbnail);

		# FIXME: TABLE isn't supported by Graphviz
		# Can't include width and height, get this error:
		# Warning: Illegal attribute width in <IMG> - ignored^
		# Warning: Illegal attribute height in <IMG>
		# print $fout "label=<<TABLE border=\"0\" cellborder=\"0\"><TR><TD><IMG SRC=\"thumbs/$thumbname[0]\" scale=\"true\" width=\"$x\" height=\"$y\"/></TD></TR><TR><TD>$label</TD></TR>$dob$dod</TABLE>>",
			# ",labelloc=b";
		print $fout "label=<<TABLE border=\"0\" cellborder=\"0\"><TR><TD><IMG SRC=\"thumbs/$thumbname[0]\" scale=\"true\"/></TD></TR><TR><TD>$label</TD></TR>$dob$dod</TABLE>>",
			",labelloc=b";

		# print $fout ",image=\"$profile_image\",labelloc=b";

		chmod 0444, $thumbnail;
	} elsif(!$is_alive || $opts{'l'}) {
		if(defined($dob)) {
			$label .= "\\nb. $dob";
		}
		if(defined($dod)) {
			$label .= "\\nd. $dod";
		}
		print $fout "label=\"$label\"";
	} else {
		print $fout "label=\"$label\"";
	}

	print $fout "];\n";

	return $thumbnail;
}

sub must_predate
{
	return unless($opts{'w'});

	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $date = $params{'date'};
	my $predate = $params{'predate'};

	return unless($params{'predate'} && $params{'date'});

	my $d1 = $dfn->parse_datetime($date);
	my $d2 = $dfn->parse_datetime($predate);

	if($d1->year() > $d2->year()) {
		complain({
			person => $person,
			warning => "Something is wrong with the date $date which should be before $predate"
		});
	}
}

# Determine whether a person is likely to be alive based on various factors,
# including records of death or burial, date of birth, past residence events,
# and clues derived from their childrenâs and parent's records.
sub is_alive
{
	my $params = Params::Get::get_params('person', @_);
	my $person = $params->{'person'};

	# Validate input parameters
	if(!defined($person)) {
		die 'is_alive(): person parameter is required';
	}

	# Early exit for death or burial records
	return 0 if($person->get_record('death') || dateofdeath($person));
	return 0 if($person->get_record('burial'));

	# Determine date of birth
	my $dob = dateofbirth($person);

	my $current_year = (localtime)[5] + 1900;

	if(!defined($dob)) {
		# Use residence events to infer death if no DOB is available
		foreach my $event (get_all_residences($person)) {
			if(my $edate = $event->date()) {
				if(my $eyear = get_year_from_date($edate)) {
					if($eyear <= 1900) {
						complain(person => $person, warning => "Was alive in $eyear but can't find death information");
						return 0;
					}
				}
			}
		}

		# Look at children's records for lifespan clues
		# my @children = $person->children();
		my @children = map { $_->children() } $person->fams();
		foreach my $child (@children) {
			if(my $child_dob = dateofbirth($child)) {
				if(my $cyob = get_year_from_date($child_dob)) {
					if($cyob <= 1900) {
						complain(person => $person, warning => "Assuming not alive based on child born in $child_dob");
						return 0;
					}
				}
			}
		}

		# Look at a parent's records for further clues
		if(my $parent = $person->father() || $person->mother()) {
			if(my $parent_dob = dateofbirth($parent)) {
				if(my $pyob = get_year_from_date($parent_dob)) {
					if($pyob <= 1900) {
						complain(person => $person, warning => "Assuming not alive based on parent born in $parent_dob");
						return 0;
					}
				}
			}
		}
		return 1;	# Assume alive if no DOB or heuristic data
	}

	# Check age based on year of birth
	if(($dob =~ /^\d{3,4}$/) && ($dob < ($current_year - ASSUME_NOT_LIVING))) {
		return 0;
	}

	# Just get the year
	if($dob =~ /\s*(\d{3,4})$/i) {
		$dob = $1;
	}

	# Parse and check full dates
	if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
		if(my $parsed_date = eval { date_parser_cached(date => $dob) }) {
			if(my $canonical_date = eval { $dfn->parse_datetime($parsed_date->{'canonical'}) }) {
				if($canonical_date->strftime('%Y') < ($current_year - ASSUME_NOT_LIVING)) {
					return 0;
				}
			} else {
				complain(person => $person, warning => "is_alive(): Failed to parse canonical date for DOB: $dob");
			}
		} else {
			complain(person => $person, warning => "is_alive(): Failed to parse DOB: $dob");
		}
	}

	return 1;	# Default to alive if no conditions matched
}

sub make_filename_from_person
{
	my $params = Params::Get::get_params('person', @_);

	my $person = $params->{'person'};

	die if(!defined($person));

	return $person->xref() . '.html';

	# OLD CODE
	my $args = { middle_names => 1 };
	if(!is_alive(person => $person)) {
		$args->{'include_years'} = 1;
	}

	my $rc = $person->as_string($args);
	if(!defined($rc)) {
		$rc = $person->as_string($args);
		if(defined($rc)) {
			complain({ person => $person, warning => 'BUG: caching not working on as_string' });
		}
	}
	if($rc eq '') {
		return $person->xref() . '.html';
	}

	$rc =~ tr/ /-/s;
	$rc =~ tr/ /-/s;
	$rc =~ tr/"/'/s;
	$rc =~ tr/\//-/s;
	$rc =~ s/--+/-/g;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	utf8::decode($rc);
	$rc = Unicode::Diacritic::Strip::strip_diacritics($rc);
	$rc =~ tr/[ÃÃ°]/th/;
	$rc =~ s/Ã¸/oe/g;
	$rc =~ tr/Ã©/e/;
	$rc =~ s/\xc3\xa9/e/g;
	$rc =~ tr/[ÄÃ§]/c/;
	$rc =~ s/\xc4\x8d/c/g;
	$rc =~ s/\xc3\xa7/c/g;
	$rc =~ tr/[Å¡Å ]/s/;
	$rc =~ s/\xc5\xa0/s/g;
	$rc =~ s/\xc5\xa1/s/g;
	$rc =~ tr/[Ã¢Ã¤]/a/;
	$rc =~ s/\xc3\xa2/a/g;
	$rc =~ s/\xc3\xa4/a/g;
	$rc =~ tr/â/"/s;
	$rc =~ tr/â/"/s;

	if($rc =~ /[^[:ascii:]]/) {
		die "$rc.html";
	}

	return "$rc.html";
}

sub make_filename_from_object
{
	my $params = Params::Get::get_params('object', @_);

	my $object = $params->{'object'};

	my $rc = $object->title();
	if(!$rc) {
		return $object->xref();
	}
	$rc =~ tr/ /-/s;
	$rc =~ tr/'/-/s;
	$rc =~ tr/\//-/s;
	$rc =~ s/--+/-/g;
	$rc =~ tr/\(/-/s;
	$rc =~ tr/\)/-/s;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	utf8::decode($rc);
	if($object->xref()) {
		return Unicode::Diacritic::Strip::strip_diacritics($object->xref() . "-$rc");
	}
	# Why would an object not have an xref?
	return String::Random->new()->randpattern('ssssss') . "-$rc";
}

# Parse Gedcom format dates
# Genealogy::Gedcom::Date is expensive, so cache results
sub date_parser_cached
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	my $date = $params{'date'};

	if($date =~ /^([A-Z]{3})\s+(\d{1,2}),\s+(\d{3,4})$/i) {
		complain(warning => "Changing US format date '$date' to Gedcom format '$2 $1 $3'");
		$date = "$2 $1 $3";
	}
	if($date =~ /(.+?\d{3,4})\s(.+)$/) {
		if(my $person = $params{'person'}) {
			complain({ person => $person, warning => "'$date': removing trailing text" });
		} else {
			complain("'$date': removing trailing text");
		}
		$date = $1;
	}

	if($all_dates{$date}) {
		print "$date is already known\n" if($opts{'v'});
		return $all_dates{$date};
	}
	if($date !~ /\d$/) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die "BUG: date_parser_cached($date) illegal date should have been trapped by now";
	}
	print "Parse date $date\n" if($opts{'v'});
	my $d;
	eval {
		$d = $date_parser->parse(date => $date);
	};
	if($d && (ref($d) eq 'ARRAY')) {
		$d = $d->[0];
		$all_dates{$date} = $d;
	}
	return $d;
}

# Try hard to convert a Gedcom date to a DateTime object.
sub date_to_datetime
{
	my $params = Params::Get::get_params('date', @_);

	if(my $date = $params->{'date'}) {
		# if($date !~ /^(bef|abt|aft).?\s/i) {
		if(($date !~ /^(bef|abt|aft)/i) && ($date !~ /\sor\s/)) {
			$params->{'quiet'} = 1 if(!$opts{'w'});
			return $dfg->parse_datetime(%{$params});
		}
	}
	return;	# undef
}

sub descendants
{
	my $person = shift;

	my @list;
	if(my $l = shift) {
		@list = @{$l};
	}

	# my @children = $person->children();
	my @children = map { $_->children() } $person->fams();
	if(scalar(@children)) {
		foreach my $child(@children) {
			push @list, $child;
			# my @spouses = $child->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendants($child, \@list);
		}
	}

	return @list;
}

sub add_marker
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $map = $params{'map'};	# HTML::GoogleMaps::V3 object
	my $place = $params{'place'};

	$place =~ s/\s\s+/ /g;
	if($place =~ /\d/) {	# We have the address, so no need to include the name of the building in the search
		# FIXME: changes Silver Spring, MD 20910, USA to 20910, USA
		$place =~ s/^\D+(.+)/$1/;
	}

	$place =~ s/'//g;
	$place =~ s/&quot;//g;
	$place =~ s/ & / and /g;

	# OSM isn't that clever with fuzzy matching
	while(my($key, $value) = each %location_mappings) {
		if($place =~ /(.*)$key(.*)/) {
			$place = "$1$value$2";
			last;
		}
	}
	my $place_link = $place;
	$place_link =~ tr/ /+/;
	# https://www.google.com/maps/place/81+Keightly+Rd,+Greencastle,+Putnam,+IN,+USA
	# TODO: If BMAP_KEY is set, use Bing maps instead
	#	If GMAP_GEOCODING_KEY is not set, use OpenStreetMaps
	if($maps_module eq 'HTML::GoogleMaps::V3') {
		$place_link = "<a href=\"https://www.google.com/maps/place/$place_link\">$place</a>";
	} else {
		$place_link = "<a href=\"https://nominatim.openstreetmap.org/ui/search.html?q=$place_link\">$place</a>";
	}

	if(my $annotation = $params{'annotation'}) {
		$place =~ s/Ã©/&eacute;/g;
		$place_link =~ s/Ã©/e/g;
		$annotation =~ s/Ã©/&eacute;/g;
		if($map->add_marker(point => $place, html => "$place_link<br>$annotation")) {
			return;
		}
		red_warning({ person => $person, warning => "$place isn't found", stack_trace => 1 });
		if($place =~ /,?(.+?),(.+?),(.+?),(.+?)$/) {
			$place = "$1, $2, $3, $4";
			if($map->add_marker(point => $place, html => "$place<br>$annotation")) {
				return;
			}
			$place = "$2, $3, $4";
			$place =~ s/^\s+//;
			$map->add_marker(point => $place, html => "$place<br>$annotation");
		}
	} else {
		if($map->add_marker(point => $place, html => $place_link)) {
			return;
		}
		red_warning({ person => $person, warning => "$place isn't found", stack_trace => 1 });
		if($place =~ /,?(.+?),(.+?),(.+?),(.+?)$/) {
			$place = "$1, $2, $3, $4";
			if($map->add_marker(point => $place, html => $place)) {
				return;
			}
			$place = "$2, $3, $4";
			$map->add_marker(point => $place, html => $place);
		}
	}
}

sub cite
{
	# my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	return '' unless($opts{'c'});

	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif((scalar(@_) % 2 == 0) && defined($_[0]) && ($_[0] !~ /^\d+$/)) {
		%params = @_;
	} else {
		$params{'citations'} = \@_;
	}

	return '' unless($params{'citations'});
	my @citations = @{$params{'citations'}};
	return '' unless($citations[0]);
	return '' unless(scalar(@citations));
	return '<span class="citation">' . $citations[0] . '</span>' if(scalar(@citations) == 1);

	if(!defined($citations[1])) {
		print STDERR "BUG: cite() called with undefined citation\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die Data::Dumper->new([\@citations])->Dump();
	}

	return '<span class="citation">' . join(',', List::Util::uniq(sort { $a <=> $b } (@citations))) . '</span>';
}

sub get_all_residences
{
	my $params = Params::Get::get_params('person', @_);
	my $person = $params->{'person'};

	die 'Usage: get_all_residences($person)' unless($person);

	# Cache the records to save repeated expensive lookups
	if($all_residences{$person->xref()}) {
		return @{$all_residences{$person->xref()}};
	}

	my @rc;
	my $index = 0;

	for my $residence ($person->residence()) {
		$index++;

		# Attempt to resolve non-object residence to a Gedcom::Record object
		unless (ref $residence) {
			my $r = $person->tag_record('RESI', $index);
			$residence = $r if $r->isa('Gedcom::Record');
		}

		# Add valid Gedcom::Record residences to the results array
		push @rc, $residence if $residence->isa('Gedcom::Record');
	}

	my @events = $person->event();
	$index = 0;
	foreach my $event(@events) {
		$index++;
		if(!ref($event)) {
			my $e = $person->tag_record('EVEN', $index);
			if(ref($e) eq 'Gedcom::Record') {
				$event = $e;
			}
		}
		next if(!($event->can('type')) && !$event->isa('Class::Simple::Readonly::Cached'));
		my $type = $event->type();
		next if(!defined($type));
		# if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation')) {
		if(($type =~ /Census/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation') || ($type eq 'Story')) {
			push @rc, $event;
		}
	}

	my @censuses = $person->census();
	$index = 0;
	foreach my $census(@censuses) {
		$index++;
		if(!ref($census)) {
			my $c = $person->tag_record('CENS', $index);
			if(ref($c) eq 'Gedcom::Record') {
				$census = $c;
			}
		}
		if(ref($census) eq 'Gedcom::Record') {
			push @rc, $census;
		}
	}

	# TODO: Can't do this as so many things check ref($record) eq 'Gedcom::Record'
	# @rc = map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @rc;

	if($opts{'w'}) {
		# Warn if the address was 33 Foo St in 1900, and Foo St in 1910.
		# Don't warn about earlier years if the year was before 1900
		#	as less information was kept so it can't be verified
		my $all_residences_have_date = 1;
		my $year = (localtime)[5];
		$year += 1900 if($year < 1900);
		foreach my $residence(@rc) {
			if(my $date = $residence->date()) {
				if(get_year_from_date($date) > $year) {
					complain({ person => $person, warning => 'Residence date is in the future' });
				}
			} else {
				complain({ person => $person, warning => 'Residence missing a date' });
				$all_residences_have_date = 0;
				last;
			}
		}
		if($all_residences_have_date) {
			my $prev_year;
			my $prev_place;

			@rc = Sort::Key::keysort { get_year_from_date($_->date()) } @rc;

			foreach my $residence(@rc) {
				my $date = $residence->date();
				next unless($date);

				if(my $place = place({ person => $person, record => $residence, nopreposition => 1 })) {
					$year = get_year_from_date($date);
					$place =~ s/^\s+//;
					if($prev_year && $prev_place) {
						if(($year >= 1900) && ($year >= $prev_year)) {
							next unless($place);
							next if($place =~ /^\d/);
							if($prev_place =~ /^\d/) {
								$prev_place =~ /^(\d+)\s+(.+)/;
								if($2 eq $place) {
									complain({ person => $person, warning => "Missing house number ($1) in $year that was known in $prev_year" });
								}
							}
						}
					} elsif($place && ($place =~ /^\d/)) {
						$prev_place = $place;
						$prev_year = $year;
					}
				}
			}
			if(scalar(@rc) >= 3) {
				# Warn if people appear to move away and back again,
				# there could be a wrong record
				my $iterator = Array::Iterator->new({ __array__ => \@rc });
				while(1) {
					my $current = $iterator->get_next();
					my $nextnext = $iterator->peek(2);

					last if(!defined($nextnext));

					my $place = place({ person => $person, record => $current, nopreposition => 1 });

					next if(!defined($place));

					my $next = $iterator->peek();
					my $nextplace = place({ person => $person, record => $next, nopreposition => 1 });
					my $nextnextplace = place({ person => $person, record => $nextnext, nopreposition => 1 });

					if(defined($nextnextplace) && ($nextnextplace eq $place) && ($nextplace ne $place)) {
						my @locations = get_location($place);

						if(my $location = shift @locations) {
							my @nextlocations = get_location($nextplace);

							if($location->isa('Geo::Location::Point') && (my $nextlocation = shift @nextlocations)) {
								if($nextlocation->isa('Geo::Location::Point')) {
									if($location->distance($nextlocation)->mile() >= 30.0) {
										complain({ person => $person, warning => "Moved from$place to$nextplace and back again - check for incorrect entry" });
										last;
									}
								}
							}
						}
					}
				}
			}
		}
	}

	$all_residences{$person->xref()} = \@rc;
	return @rc;
}

# TODO: railway/railroad = le chemin de fer
sub get_all_occupations
{
	my $params = Params::Get::get_params('person', @_);
	my $person = $params->{'person'};

	die 'Usage: get_all_occupations($person)' unless($person);

	my @occupations = get_value({ person => $person, value => 'occupation' });

	if((scalar(@occupations) == 1) && !defined($occupations[0])) {
		return;
	}

	while($occupations[0] && ($occupations[0] =~ /^scho(ol|lar)/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /wife$/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /unemployed/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /seeking work/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /domestic duties/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /home duties/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] =~ /house\s?hold duties/i)) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] eq 'Retired')) {
		shift @occupations;
	}
	while($occupations[0] && ($occupations[0] eq 'At School')) {
		shift @occupations;
	}

	while(scalar(@occupations) > 1) {
		if(($occupations[0] =~ /^labou?rer/i) && ($occupations[1] =~ /^labou?rer/i)) {
			shift @occupations;
		} elsif(lc($occupations[0]) eq lc($occupations[1])) {
			shift @occupations;
		} else {
			last;
		}
	}

	# TODO: sort out case
	my @rc;

	while(my $occupation = shift @occupations) {
		$occupation =~ tr/\r//;
		$occupation =~ tr/\n/ /;
		$occupation =~ s/\.+$//;
		$occupation =~ s/[\(\)]//g;
		$occupation =~ s/\s\s/ /g;
		$occupation =~ s/\./;/g;

		$occupation =~ s/\s+Own Account//i;
		$occupation =~ s/^Formerly //i;
		$occupation =~ s/\sretired$//i;
		$occupation =~ s/Labor/Labour/i;

		if(($occupation =~ /(.+)\sdomestic$/i) ||
		   ($occupation =~ /(.+)\sdom$/i)) {
			$occupation = "Domestic $1";
		}

		if($occupation =~ /works? on (.+)/i) {
			$occupation = "$1 worker";
		} elsif(($occupation eq 'Ag Lab') ||
			($occupation eq 'Ag Labourer') ||
			($occupation eq 'Ag Labourer Pauper') ||
			($occupation eq 'Agric Labourer') ||
			($occupation eq 'Ag Lab Pauper') ||
			($occupation eq 'Farm Labourer') ||
			($occupation eq 'Agricultural Farm Labourer') ||
			($occupation eq 'Ordinary Agricultural Labourer') ||
			($occupation eq 'work on farm') ||
			($occupation eq 'Agricultural Lab') ||
			($occupation eq 'Agril Labourer') ||
			($occupation eq 'Labourer Ag') ||
			($occupation eq 'Labourer (Ag)')) {
			$occupation = 'Agricultural Labourer';
		} elsif($occupation eq 'Poultry Farming') {
			if($language eq 'French') {
				$occupation = (($person->sex() eq 'M') ? 'Agriculteur de poulet' : 'Agricultrice de poulet');
			} else {
				$occupation = 'Poultry Farmer';
			}
		} elsif($occupation eq 'Platelayer Railway') {
			$occupation = 'Railway Platelayer';
		} elsif(($occupation eq 'General Servant Domestic') ||
			($occupation =~ /^General serv.+dom/i) ||
			($occupation =~ /^Domestic servant$/i)) {
			if($language eq 'French') {
				$occupation = 'Domestique';
			} else {
				$occupation = 'Domestic servant';
			}
		} elsif($occupation =~ /(.+)\sserv$/i) {
			$occupation = "$1 servant";
		} elsif($occupation eq 'Lorry Driver Heavy Worker') {
			$occupation = 'Lorry Driver';
		} elsif($occupation =~ /^Shop Assistant (.*)/) {
			$occupation = "$1's Shop Assistant";
		} elsif($occupation =~ /(.*) Assistant$/i) {
			if($1 eq 'Bakers') {
				$occupation = "Baker's Assistant";
			} elsif($1 eq 'Butchers') {
				$occupation = "Butcher's Assistant";
			} elsif($1 ne 'Shop') {
				$occupation = "$1's Assistant" unless($1 =~ /'s$/);
			}
		} elsif($occupation =~ /^Clerk (.*)/) {
			$occupation = "$1 Clerk";
		} elsif($occupation =~ /^Salesman (.*)/i) {
			$occupation = "$1 Salesman";
		} elsif($occupation =~ /Foreman (.*)/i) {
			$occupation = "$1 Foreman";
			$occupation =~ s/^of the //i;
		} elsif($occupation =~ /Labourer Gas Stoker/) {
			$occupation = 'Gas Stoker';
		} elsif(($occupation eq 'Under Gardener Domestic') ||
			($occupation eq 'Domestic Under Gardner')) {	# sic
			$occupation = 'Domestic Gardener';
		} elsif($occupation eq 'Market gardener') {
			$occupation = 'Market Gardener';
		} elsif($occupation eq "Brewer's Labourer") {
			$occupation = 'Brewery Labourer';
		} elsif($occupation eq "Labourer Builders") {
			$occupation = "Builder's labourer";
		} elsif(($occupation eq 'Gardener domestic') ||
			($occupation eq 'Gardner and domestic servant')) {
			$occupation = 'Gardener and Domestic';
		} elsif($occupation =~ /(.+)\sserv$/i) {
			$occupation = "$1 servant";
		} elsif($occupation =~ /^(.+) on farm/i) {
			$occupation = ($language eq 'French') ? "$1 en un ferme" : "$1 on a farm";
		} elsif($occupation eq 'Plate Glass Cutter') {
		} elsif($occupation =~ /police$/i) {
			$occupation .= ' officer';
		} elsif(($occupation eq 'Nurse') && ($language eq 'French')) {
			$occupation = ($person->sex() eq 'M') ? 'infirmier' : "infirmi\N{U+00E8}re";
		} elsif($occupation =~ /teaching/i) {
			if($language eq 'French') {
				$occupation = 'professeur';
			} elsif($language eq 'German') {
				$occupation = ($person->sex() eq 'M') ? 'Lehrer' : 'Lehrerin';
			} else {
				$occupation = 'teacher';
			}
		} elsif(($occupation !~ /gas works/i) && ($occupation =~ /(.+)([a-z])s\s+([a-z]+)$/i)) {
			# Don't change Bus Driver to Bu's Driver
			$occupation = "$1$2's $3" unless(("$1$2" eq 'Bu') || ("$1$2" eq 'Harnes'));
		} elsif($occupation eq 'Laundry Man') {
			$occupation = 'Laundryman';
		} elsif(($occupation =~ /Manager (.*)/i) &&
			($occupation !~ /^Manager of /i) &&
			($occupation !~ /Manager & /i)) {
			$occupation = "$1 Manager";
		}

		if($language eq 'German') {
			if($occupation eq 'Bus driver') {
				$occupation = ($person->sex() eq 'M') ? 'Busfahrer' : 'Busfahrerin';
			}
		}

		if($occupation) {
			if($language eq 'English') {
				if($ENV{'LANG'} =~ /^en_US/) {
					$occupation = Lingua::EN::ABC::b2a(lc($occupation));
					$occupation =~ s/labour/labor/;
					$occupation =~ s/Labour/Labor/;
				} elsif($ENV{'LANG'} =~ /^en_CA/) {
					$occupation = Lingua::EN::ABC::b2c(lc($occupation));
				} else {
					$occupation = Lingua::EN::ABC::a2b(lc($occupation));
				}
			} elsif($language eq 'French') {
				if($occupation eq 'Postman') {
					$occupation = (($person->sex() eq 'M') ? 'Facteur' : 'Factrisse');
				} elsif($occupation =~ /(.+)\sFarmer/) {
					$occupation = (($person->sex() eq 'M') ? "Agriculteur $1" : "Agricultrice $1");
				} elsif($occupation eq 'Farmer') {
					$occupation = (($person->sex() eq 'M') ? 'Agriculteur' : 'Agricultrice');
				} elsif($occupation eq 'Teacher') {
					$occupation = 'Professeur';
				}
				$occupation =~ s/retired/\N{U+00E0} la retrainte/i;
			} elsif($language eq 'German') {
				if($occupation eq 'Teacher') {
					$occupation = (($person->sex() eq 'M') ? 'Lehrer' : 'Lehrerin');
				} elsif($occupation =~ /(.+)\sFarmer/) {
					$occupation = (($person->sex() eq 'M') ? 'Landwirt' : 'Landwirtin');
				} elsif($occupation eq 'Farmer') {
					$occupation = (($person->sex() eq 'M') ? 'Bauer' : 'Bauerin');
				}
				$occupation =~ s/retired/im ruhestand/i;
				$occupation =~ s/self-employed/slbststa\N{U+00E4}ndig/;
			}
			if($occupation =~ /works? (on|for) (.+)/i) {
				$occupation = "$2 worker";
			} elsif($occupation =~ /^Cleaner\s+(.+)/i) {
				$occupation = "$1 cleaner";
			}
			$occupation = ucfirst($occupation);
			$occupation =~ s/\s+heavy worker$//i;
			$occupation =~ s/\s+own business$//i;

			push @rc, $occupation;
		} else {
			complain({
				person => $person,
				warning => 'Occupation is empty'
			});
		}
	}

	return @rc;
}

# Return the arrival record of the given person, or undef if none or more than one
sub arrival
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	my @events = $person->event();
	my $rc;

	foreach my $event(@events) {
		if(($event->can('type') || $event->isa('Class::Simple::Readonly::Cached')) && ($event->type() eq 'Arrival')) {
			return if($rc);
			$rc = $event;
		}
	}
	return $rc
}

# Document a complete journey when both a departure and an arrival record exist
sub journey
{
	my $params = Params::Get::get_params(undef, \@_);

	my $person = $params->{'person'};
	my $arrival = $params->{'arrival'};
	my $departure = $params->{'departure'};
	my $parse_tree = $params->{'parse_tree'};
	my @spouses;
	my @children;
	my $yod;
	my $yoa;
	my $dod = $departure->date();
	my $doa = $arrival->date();
	my $only_have_departure_year;
	my $journey;	# For parse_tree

	@spouses = @{$params->{'spouses'}} if($params->{'spouses'});
	@children = @{$params->{'children'}} if($params->{'children'});

	if($doa) {
		$journey->{'arrival'}->{'date'} = $doa;
	}
	if($dod) {
		$journey->{'departure'}->{'date'} = $dod;
	}

	# my $i = 0;
	# while((my @call_details = (caller($i++)))) {
		# print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
	# }

	if($doa && ($doa =~ /\d{3,4}$/)) {
		$yoa = get_year_from_date($doa);
		$journey->{'arrival'}->{'year'} = $yoa;
		$doa =~ s/\s+?\d{3,4}//;
		if($dod && ($dod =~ /(\d{3,4})$/)) {
			$yod = $1;
			$journey->{'departure'}->{'year'} = $yod;
			$dod =~ s/\s?\d{3,4}//;
			if($dod =~ /^\d/) {
				$dod = "on $dod";
			} elsif(length($dod) && ($dod !~ /^abt\.?$/)) {
				$dod = i18n({ format => 'during %s', args => $dod });
			} else {
				# $dod = i18n({ format => 'during %s', args => $yod });
				$only_have_departure_year = 1;
			}
			if($doa =~ /^\d/) {
				$doa = "on $doa";
			} elsif($yoa == $yod) {
				$doa = i18n('later that same year');
			} elsif(length($doa)) {
				$doa = i18n({ format => 'during %s', args => $doa });
			} else {
				$doa = i18n({ format => 'during %s', args => $yoa });
			}
		}
	}

	my $rc = ucfirst(i18n($person->pronoun()));
	if($yoa || $yod) {
		my $year = $yoa // $yod;
		if($language eq 'French') {
			$rc = "En $year " . lc($rc);
		} else {
			$rc = "In $year " . lc($rc);
		}
		if($year eq $doa) {
			# Nothing more to print, avoid "In 1914 he arrived in 1914"
			# But keep "In 1914 he arrived on 1 Jul"
			undef $doa;
		}
	} else {
		die 'TODO: ', $person->as_string(), ': handle departure only record';
		# $yod = year({ person => $person, record => $departure });
		# $yoa = year({ person => $person, record => $arrival });
	}

	if($language eq 'French') {
		$rc .= " a voyag\N{U+00E9}";
	} elsif($ENV{'LANG'} =~ /^en_US/) {
		$rc .= ' traveled';
	} else {
		$rc .= ' travelled';
	}

	my $dnotes;

	if(defined($departure->place())) {
		$journey->{'departure'}->{'place'} = place({ record => $departure, nopreposition => 1 });
		$rc .= i18n(' from') . place({ person => $person, record => $departure, nopreposition => 1 });
		if($dnotes = notes(record => $departure)) {
			$dnotes = lcfirst($dnotes) unless($dnotes =~ /^[A-Z]{2}/);
			$dnotes =~ s/\.$//;
			$rc .= " ($dnotes)";
			$journey->{'departure'}->{'notes'} = $dnotes;
		}
	} else {
		complain({ person => $person, warning => 'Departure record has no location' });
	}
	if(defined($arrival->place())) {
		if($language eq 'French') {
			$rc .= " \N{U+00E0}";
		} elsif($language eq 'German') {
			$rc .= ' nach';
		} else {
			$rc .= ' to';
		}
		$journey->{'arrival'}->{'place'} = place({ record => $arrival, nopreposition => 1 });
		$rc .= place({ person => $person, record => $arrival, nopreposition => 1 });
		if(my $notes = notes(record => $arrival)) {
			if((!defined($dnotes)) || ($notes !~ qr/$dnotes/i)) {
				$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
				$notes =~ s/\.$//;
				$rc .= " ($notes)";
				$journey->{'arrival'}->{'notes'} = $notes;
			}
		}
	} else {
		complain({ person => $person, warning => 'Arrival record has no location' });
	}

	if(defined($dod) && !$only_have_departure_year) {
		if($language eq 'French') {
			$rc .= ", partant $dod";
		} else {
			$rc .= ", departing $dod";
		}
	}

	if(defined($doa)) {
		$rc .= ", arriving $doa";
	}

	if($arrival->date()) {
		my $with_spouse;
		if($spouses[0] && ($opts{'l'} || !is_alive(person => $spouses[0])) &&
		   (my $sarrival = arrival({ person => $spouses[0] }))) {
			if($sarrival->date() eq $arrival->date()) {
				$rc .= i18n(' with ') .
					lcfirst($person->possessive()) . ' ' .
					((get_value({ person => $person, value => 'sex' }) eq 'M') ? 'wife' : 'husband') .
					', ' . given_names($spouses[0]);
				$with_spouse++;
				push @{$journey->{'arrival'}->{'with'}}, {
					'name' => given_names($spouses[0]),
					'relationship' => ((get_value({ person => $person, value => 'sex' }) eq 'M') ? 'wife' : 'husband')
				};
			}
		}
		my @childnames;
		foreach my $child(@children) {
			if(($opts{'l'} || !is_alive(person => $child))) {
				push(@childnames, given_names($child));
			}
		}
		if(scalar(@childnames)) {
			$rc .= (i18n(($with_spouse) ? ' and ' : ' with '));
			if(scalar(@childnames) == scalar(@children)) {
				$rc .= 'all of ' .
					lcfirst($person->possessive()) .
					i18n(' children');
				$journey->{'with_all_children'} = 1;
			} elsif(scalar(@childnames) == 1) {
				$rc .= lcfirst($person->possessive()) .
					i18n(' child ') .
					$childnames[0];
			} elsif(scalar(@childnames) > 1) {
				$rc .= lcfirst($person->possessive()) .
					i18n(' children') .
					': ' . conjunction(@childnames);
			}
			foreach my $name(@childnames) {
				push @{$journey->{'arrival'}->{'with'}}, {
					name => $name,
					relationship => 'child'
				}
			}
		}
	}
	push @{$parse_tree->{'journies'}}, $journey if(defined($parse_tree));
	return $rc
}

# Compare two dates.
sub datecmp($$)
{
	my ($left, $right) = @_;

	return Date::Cmp::datecmp($left, $right, \&complain);
}

sub chronicling_america
{
	my ($person, $chronicling_params) = @_;

	return unless($opts{'w'});

	if(!defined($chronicling_params->{'firstname'})) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die $person->as_string(), ': BUG: no first name given';
	}
	if(length($chronicling_params->{'state'}) <= 2) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die $person->as_string(), ': BUG: state "', $chronicling_params->{'state'}, '" too short';
	}

	return;	# FIXME: Too many false positives for now

	print Data::Dumper->new([$chronicling_params])->Dump() if($opts{'v'});

	if(my $loc = Genealogy::ChroniclingAmerica->new($chronicling_params)) {
		while(my $url = $loc->get_next_entry()) {
			complain({ person => $person, warning => ucfirst(i18n('check out %s', $url)) });
		}
	}

	print "Leaving chronicling_america\n" if($opts{'v'});
}

sub obituaries
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: no arguments given';
	}

	$Data::Dumper::Maxdepth = 2;
	print "obituaries:\n\t", Data::Dumper->new([\%params])->Dump() if($opts{'v'});

	my $yob = delete $params{'yob'};
	my $yod = delete $params{'yod'};
	my $person = delete $params{'person'};
	my @obituaries = $obituaries->search(\%params);

	print scalar(@obituaries), " obituaries found\n" if($opts{'v'});

	if(scalar(@obituaries)) {
		foreach my $obituary(@obituaries) {
			if(my $date = $obituary->{'date'}) {
				if($date =~ /^(\d+)\-\d+\-\d+$/) {
					my $year = $1;
					if($yod) {
						if(abs($year - $yod) <= 1) {
							if($yob && $obituary->{'age'}) {
								if(abs($year - ($yob + $obituary->{'age'})) <= 1) {
									complain({ person => $person, warning => ucfirst(i18n('check out %s', $obituary->{'url'})) });
								}
							} else {
								complain({ person => $person, warning => ucfirst(i18n('check out %s', $obituary->{'url'})) });
							}
						}
					} elsif($yob && $obituary->{'age'}) {
						if(abs($year - ($yob + $obituary->{'age'})) <= 1) {
							complain({ person => $person, warning => ucfirst(i18n('check out %s', $obituary->{'url'})) });
						}
					}
				}
			}
		}
	}

	return @obituaries;
}

sub wills
{
	my %params;

	return if(!defined($wills));

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: no arguments given';
	}

	$Data::Dumper::Maxdepth = 2;
	print Data::Dumper->new([\%params])->Dump() if($opts{'v'});

	my $person = delete $params{'person'};
	my @wills = $wills->search(\%params);

	print scalar(@wills), " wills found\n" if($opts{'v'});

	foreach my $will(@wills) {
		complain({ person => $person, warning => ucfirst(i18n('check out %s', $will->{'url'})) });
	}

	return @wills;
}

# Overridden HTML::GoogleMaps::V3::_text_to_point
sub ged2site_text_to_point
{
    my ( $self,$point_text ) = @_;

    # IE, already a long/lat pair
	return [ reverse @$point_text ] if ref( $point_text ) eq 'ARRAY';

    if( my @loc = $self->{geocoder}->geocode( location => $point_text ) ) {
	if( my $location = $loc[0] ) {
		##################################################
		# ADDITION:
		if(ref($location) eq 'Geo::Location::Point') {
			if((!defined($location->lat())) || !defined($location->long())) {
				return 0;
			}
			return [ $location->lat(), $location->long() ];
		}
		# END OF ADDITION
		##################################################

	    if( ref( $location ) ne 'HASH' ) {
		warn "$point_text didn't return a HASH ref as first element from ->geocode";
		return 0;
	    }

	    if(defined($location->{geometry}{location}{lat}) && defined($location->{geometry}{location}{lng})) {
		return [
		    $location->{geometry}{location}{lat},
		    $location->{geometry}{location}{lng},
		];
	    }
	}
    }

    # Unknown
    return 0;
}

# FIXME: once RT127603 has been fixed
sub Geo::Coder::PlaceFinder::ua
{
	my $self = shift;

	if(my $ua = shift) {
		return $self->{_ua} = $ua;
	}

	return $self->{_ua};
}

# See https://github.com/OpenCageData/perl-Geo-Coder-OpenCage/issues/8
sub Geo::Coder::OpenCage::ua {
	my $self = shift;

	# if(my $ua = shift) {
		# $self->{ua} = $ua;
	# }
	return $self->{ua};
}

sub dateofbirth {
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	my @d = get_value({ person => $person, value => 'birth date' });
	my $dateofbirth;

	if((scalar(@d) == 2) && ($d[0] ne $d[1])) {
		my ($year1, $year2);

		if($d[0] =~ /(\d{3,4})/) {
			$year1 = $1;
		}
		if($d[1] =~ /(\d{3,4})/) {
			$year2 = $1;
		}

		if((defined($year1) && defined($year2)) && (abs($year1 - $year2) > 30)) {
			complain({ person => $person, warning => 'More than one date of birth separated by many years' });
		}

		# Get the primary date.
		# TODO: Is there a proper way to do this with the Gedcom module?
		# FIXME: limited to 2 dates
		my @b = $person->birth();

		for my $i(0..1) {
			if(ref($b[$i])) {
				foreach my $item(@{$b[$i]->{'items'}}) {
					if(($item->tag() eq '_PRIM') && ($item->value() eq 'Y')) {
						$dateofbirth = $b[$i]->date();
						last;
					}
				}
			} else {
				my @r = $person->get_record('birth');
				foreach my $item(@{$r[$i]->{'items'}}) {
					if(($item->tag() eq '_PRIM') && ($item->value() eq 'Y')) {
						$dateofbirth = $r[$i]->date();
						last;
					}
				}
				# TODO:  This is in more for debugging
				#	to make sure that the record's value
				#	is included in the bio
				complain({ person => $person, warning => [ $b[$i], ' is not a ref' ] });
			}
		}

		if(!defined($dateofbirth)) {
			complain({ person => $person, warning => "Two dates of birth ($d[0]/$d[1]), neither of which is marked primary" });
			$dateofbirth = $d[0];
		}
	} elsif(scalar(@d) == 1) {
		$dateofbirth = $d[0];
	} elsif(scalar(@d)) {
		# More than one date - are they all the same?
		while(defined($d[1]) && ($d[1] !~ /\sor\s/) && ($d[1] !~ /^About/) && (datecmp($d[0], $d[1]) == 0)) {
			shift @d;
		}
		if(scalar(@d) == 1) {
			complain({ person => $person, warning => "Removed duplicate dates of birth ($d[0])" });
			return parse_date({ date => $d[0], type => 'Birth', person => $person });
		}
		complain({ person => $person, warning => [ 'TODO: handle more than 2 dates of birth: ', conjunction(map { year(date => $_) } @d) ] });
		# die "TODO: handle more than 2 dates of birth ($d[0]/$d[1])";
		return;
	}

	if((!defined($dateofbirth)) && (my $birth = $person->get_record('birth'))) {
		$dateofbirth = $birth->date();
	}
	if((!defined($dateofbirth)) && (my $birth = $person->get_record('birt'))) {
		$dateofbirth = $birth->date();
	}
	if(defined($dateofbirth)) {
		if($dateofbirth eq '?') {
			return undef;
		}
		if($dateofbirth =~ /\s$/) {
			complain({ person => $person, warning => "Removing trailing spaces from date of birth '$dateofbirth'" });
			$dateofbirth =~ s/\s+$//;
		}
		if($dateofbirth =~ /^0\d{3}/) {
			complain({ person => $person, warning => "Removing leading zeroes from date of birth '$dateofbirth'" });
			$dateofbirth =~ s/^0+//;
		}
		return parse_date({ date => $dateofbirth, type => 'Birth', person => $person });
	}
	return;	# return undef
}

# Try hard to get the marriage record
sub get_marriage
{
	my $params = Params::Get::get_params('person', @_);
	my $person = $params->{'person'};

	my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage');
	if(!defined($marriage)) {
		# Don't do this, because it generates false positives when
		# a spouse has marriage records to a different person
		# my @spouses = $person->spouse();
		# if(scalar(@spouses)) {
			# # FIXME: only looks at the first spouse
			# $marriage = $spouses[0]->get_record('marriage') || $spouses[0]->get_record('fams marriage');
			# return $marriage if(defined($marriage));
		# }

		my @events = $person->event();
		if(scalar(@events) == 1) {
			my $event = $person->event();
			if(!ref($event)) {
				my $e = $person->tag_record('EVEN');
				if($e->isa('Gedcom::Record')) {
					$event = $e;
				}
			}
			if(ref($event) && $event->can('type') && defined($event->type()) &&
			  ($event->type() eq 'Custom Marriage')) {
				# FindMyPast
				return $event;
			}
		} else {
			foreach my $event(@events) {
				if((ref($event) eq 'Gedcom::Record') &&
				  ($event->type() eq 'Custom Marriage')) {
					# FindMyPast
					return $event;
				}
			}
		}
	}
	return $marriage;
}

sub dateofmarriage
{
	my $params = Params::Get::get_params('person', @_);

	my $person = $params->{'person'};

	# my $dateofmarriage = get_value({ person => $person, value => 'marriage date' });
	# if((!defined($dateofmarriage)) && (my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage'))) {
		# $dateofmarriage = $marriage->date();
	# }

	# return parse_date({ date => $dateofmarriage, type => 'Marriage', person => $person });

	my @d = get_value({ person => $person, value => 'marriage date' });
	my $dateofmarriage;

	if((scalar(@d) == 0) && (my $marriage = get_marriage($person))) {
		@d = $marriage->date();
	}

	if((scalar(@d) == 2) && (datecmp($d[0], $d[1]) == 0)) {
		complain({ person => $person, warning => "Two dates of marriage, both of which are the same: $d[0]" });
		pop(@d);
	}

	if(scalar(@d) == 2) {
		my ($year1, $year2);

		if($d[0] =~ /(\d{3,4})/) {
			$year1 = $1;
		}
		if($d[1] =~ /(\d{3,4})/) {
			$year2 = $1;
		}
		if(defined($year1) && defined($year2)) {
			if(abs($year1 - $year2) > 30) {
				complain({ person => $person, warning => 'More than one date of marriage separated by many years' });
			}
		}

		# Get the primary date.
		# TODO: Is there a proper way to do this with the Gedcom module?
		# FIXME: limited to 2 dates
		my @b = $person->marriage();

		for my $i(0..1) {
			foreach my $item(@{$b[$i]->{'items'}}) {
				if(($item->tag() eq '_PRIM') && ($item->value() eq 'Y')) {
					$dateofmarriage = $b[$i]->date();
					last;
				}
			}
		}
		if(!defined($dateofmarriage)) {
			complain({ person => $person, warning => 'two dates of marriage, neither of which is marked primary' });
			$dateofmarriage = $d[0];
		}
	} elsif(scalar(@d) == 1) {
		$dateofmarriage = $d[0];
	} elsif(scalar(@d)) {
		complain({ person => $person, warning => [ 'TODO: handle more than 2 dates of marriage: ', conjunction(map { year(date => $_) } @d) ] });
		# die 'TODO: handle more than 2 dates of marriage';
		return;
	}

	if((!defined($dateofmarriage)) && (my $marriage = get_marriage($person))) {
		$dateofmarriage = $marriage->date();
	}
	if(defined($dateofmarriage)) {
		if($dateofmarriage =~ /\s$/) {
			complain({ person => $person, warning => "Removing trailing spaces from date of marriage '$dateofmarriage'" });
			$dateofmarriage =~ s/\s+$//;
		}
		if($dateofmarriage =~ /^About[:\s](.+)/i) {
			$dateofmarriage = "ABT $1";
		}
		if($opts{'w'} && ($dateofmarriage =~ /\d{3,4}$/) && (my $dateofbirth = dateofbirth($person))) {
			if(($dateofbirth =~ /\d{3,4}$/) && (datecmp($dateofmarriage, $dateofbirth) <= 0)) {
				complain({ person => $person, warning => "Date of marriage ($dateofmarriage) is before date of birth ($dateofbirth)" });
			}
		}
		if($dateofmarriage =~ /\d/) {
			return parse_date({ date => $dateofmarriage, type => 'Marriage', person => $person });
		}
		complain({ person => $person, warning => "'$dateofmarriage' is not a valid date of marriage" });
	}
	return;	# return undef
}

sub dateofdeath
{
	my $params = Params::Get::get_params('person', @_);
	my $person = $params->{'person'};

	my $dateofdeath = get_value({ person => $person, value => 'death date' });
	if((!defined($dateofdeath)) && (my $death = $person->get_record('death'))) {
		$dateofdeath = $death->date();
	}
	if(defined($dateofdeath)) {
		if($dateofdeath =~ /died at birth/i) {
			complain({ person => $person, warning => 'Getting date of death from date of birth' });
			return dateofbirth($params);
		}
		if($dateofdeath =~ /\s$/) {
			complain({ person => $person, warning => "Removing trailing spaces from date of death '$dateofdeath'" });
			$dateofdeath =~ s/\s+$//;
		}
		if($dateofdeath =~ /\d+[\/\-]\d+[\/\-]\d+/) {
			complain({ person => $person, warning => "Invalid date format for date of death '$dateofdeath'" });
		} else {
			if(($dateofdeath =~ /^[a-z]/) && ($dateofdeath !~ /^(bef|abt|aft|bet)/i)) {
				complain({ person => $person, warning => "Capitalizing month in date of death '$dateofdeath'" });
				$dateofdeath = ucfirst($dateofdeath);
			}
			if(uc($dateofdeath) ne 'DATE UNKNOWN') {
				return parse_date({ date => $dateofdeath, type => 'Death', person => $person });
			}
		}
	}
	return;	# undef
}

# Dig the date out of a field and return in a valid gedcom format
sub parse_date
{
	my $params = Params::Get::get_params('date', @_);

	if(my $date = $params->{'date'}) {
		if(ref($date)) {
			# Caused by empty value, e.g.:
			#	1 BIRT
			#	2 DATE
			#	2 PLAC VERMONT

			# $Data::Dumper::Maxdepth = 2;
			# print STDERR Data::Dumper->new([$dateofbirth])->Dump();
			# die 'BUG: date() should return a scalar, got a ', ref($dateofbirth);
			return;
		}
		if(lc($date) eq 'unknown') {
			return;
		}
		if(length($date) == 0) {
			return;
		}

		# In a Gedcom, DJULIAN refers to a date in the Julian calendar format, using the @#DJULIAN@ escape to indicate it.
		$date =~ s/^@#DJULIAN@\s//;

		my $type = $params->{'type'};
		my $person = $params->{'person'};
		my $after;
		my $before;
		my $about;

		if($date =~ /^After\s+(.+)/i) {
			complain({ person => $person, warning => "$type date says 'After' instead of 'Aft'" });
			$date = $1;
			$after = 1;
		} elsif($date =~ /^Before\s+(.+)/i) {
			complain({ person => $person, warning => "$type date says 'Before' instead of 'Bef'" });
			$date = $1;
			$before = 1;
		} elsif($date =~ /^aft\s(.+)/i) {
			$date = $1;
			$after = 1;
		} elsif($date =~ /^bef\s(.+)/i) {
			$date = $1;
			$before = 1;
		} elsif($date =~ /^abt\s+(.+)/i) {
			$date = $1;
			$about = 1;
		} elsif($date =~ /^About:(\d.+)/) {
			# About:1907-00-00
			$date = $1;
			$about = 1;
			if($date =~ /^(\d+)\-00\-00$/) {
				$date = $1
			}
		} elsif($date =~ /^about\s?(\d.+)/) {
			# FMP adds "about " instead of "abt " when you check "a guess"
			# about1883
			$date = $1;
			$about = 1;
			if($date =~ /^(\d+)\-00\-00$/) {
				$date = $1
			}
		} elsif($date =~ /^about\s?([A-Z]{3})\s(\d{3,4})/i) {
			# about Feb 1877
			$date = "$1 $2";
			$about = 1;
		}

		if($date =~ /[A-Z]{4,}/i) {
			if($date =~ /^(\d{1,2})\s([A-Z]{3,})(\d{3,4})/i) {
				# 22 October1996
				complain({ person => $person, warning => "Changing date '$date' to '$1 $2 $3'" });
				return $1 . ucfirst(lc(substr($2, 0, 3))) . " $3";
			} else {
				complain({ person => $person, warning => "$type month '$date' should be 3 letters" });
			}
			if($date =~ /from (.+) to (.+)/i) {
				return "bet $1 and $2";
			}
			if($date =~ /^(\d{3,4})\s([A-Z]{3,})\s(\d{1,2})$/i) {
				# 1942 June 9
				my $rc = "$3 " . ucfirst(lc(substr($2, 0, 3))) . " $1";
				complain({ person => $person, warning => "$date changed to $rc" });
				return $rc;
			}
			if($date =~ /(.*\d{4})\s+(.+)/) {
				complain({ person => $person, warning => "$type date: removing trailing text '$2'" });
				$date = $1;
			}
			if($date =~ /^([\d\s]*)([A-Z]{4,})\.?\s+([\d\/]+)$/i) {
				if(lc($2) eq 'about') {
					return "abt $3";
				}
				# FIXME: assumes the months are in English
				return $1 . ucfirst(lc(substr($2, 0, 3))) . " $3";
			}
			if($date =~ /^([A-Z]{3,})\s+(\d+),?\s*([\d\/]+)$/i) {	# U.S. format - Jul 4 instead of 4 Jul
				# FIXME: assumes the months are in English
				my $rc = "$2 " . ucfirst(lc(substr($1, 0, 3))) . " $3";
				complain({ person => $person, warning => "$date changed to $rc" });
				return $rc;
			}
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			die $ARGV[0], ': BUG: parse_date(): handle "', $params->{'date'}, '" on ', $person->as_string(), " parsed so far as '$date'";
		}
		if($about) {
			$date = "abt $date";
		}
		if($after) {
			return "aft $date";
		} elsif($before) {
			return "bef $date";
		}
		return $date;
	}
}

# Given a place return its latitude and longitude
sub get_location($)
{
	return unless(defined($geocoder));

	my $place = shift;

	if(!defined($place)) {
		print "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: place argument not given';
	}

	print "get_location: $place\n" if($opts{'v'});

	# Translate to English so that Geo::Coder::List can choose the right geocoder
	if(ref($place) eq 'Lingua::String') {
		$place = $place->en();
		print "English translation: $place\n" if($opts{'v'});
	} elsif($lcm && ($place =~ /(.+),\s*(.+)$/)) {
		if($2 ne 'England') {
			my $c = $2;
			# utf8::encode($c);
			if(($language eq 'French') && ($c eq 'Angleterre')) {
				$place = "$1, England";
			} elsif(my $code = $lcm->country2code($c, 'LOCALE_CODE_ALPHA_2', get_language_code())) {
				$c = $lcm->code2country($code, 'en');
				if($c eq 'United States') {
					$c = 'USA';
				}
				$place = "$1, $c";
			}
			print "English translation: $place\n" if($opts{'v'});
		}
	}

	$place =~ s/^\s+//;
	if($language eq 'French') {
		$place =~ s/^\N{U+00E0}\s+//;
	} else {
		$place =~ s/^at\s+//;
		$place =~ s/^on\s+//;
	}

	my @locations = $geocoder->geocode($place);	# Use array to improve caching

	if(my $location = shift @locations) {
		if(ref($location) eq 'Geo::Location::Point') {
			return $location;
		}
		if(defined($location->{geometry}{location}{lat}) && defined($location->{geometry}{location}{lng})) {
			# my $rc = Class::Simple->new();
			# $rc->long($location->{geometry}{location}{lng});
			# $rc->longitude($location->{geometry}{location}{lng});
			# $rc->lat($location->{geometry}{location}{lat});
			# $rc->latitude($location->{geometry}{location}{lat});
			# return $rc;
			return Geo::Location::Point->new({ latitude => $location->{geometry}{location}{lat}, longitude => $location->{geometry}{location}{lng} });
		}
		dump_geocoder_log();

		$Data::Dumper::Maxdepth = 0;
		print Data::Dumper->new([\$location])->Dump();
		print Data::Dumper->new([\@locations])->Dump();
		complain({ warning => "Probable bug in Geo::Coder::List with '$place'" });
	}
}

sub dump_geocoder_log
{
	return unless($opts{'v'});
	return unless(defined($geocoder));

	my $log = $geocoder->log();
	$geocoder->flush();
	print Data::Dumper->new([$log])->Dump() if($log);

	foreach my $l(@{$log}) {
		if($l->{'line'}) {
			print 'Line ', $l->{'line'}, ': ';
		}
		if($l->{'error'}) {
			print $l->{'error'}, ', ';
		}
		if($l->{geocoder}) {
			if($l->{error}) {
				print $l->{location}, ': ', $l->{timetaken}, 's with ', $l->{geocoder}, '(', $l->{error}, ")\n";
			} else {
				print $l->{location}, ': ', $l->{timetaken}, 's with ', $l->{geocoder}, "\n";
			}
		} else {
			print $l->{location}, ": cached\n";
		}
	}
}

# Capitalise the first character of each word
sub sortoutcase {
	my $field = lc(shift);

	my $ret = '';

	foreach my $word (split(/\s/, $field)) {
		if($ret ne '') {
			$ret .= ' ';
		}
		my @list = split(/-/, $word);
		if(scalar(@list) > 1) {
			foreach (@list) {
				if($ret ne '') {
					$ret .= '-';
				}
				$ret .= ucfirst($_);
			}
		} else {
			$ret .= ucfirst($word);
		}
	}

	return $ret;
}

sub isbrother
{
	my $person = shift;
	my $other = shift;

	return unless($other);

	my $other_xref = $other->xref();

	my @siblings = $person->siblings();
	foreach my $sibling(@siblings) {
		if(($sibling->sex() eq 'M') && ($sibling->xref() eq $other_xref)) {
			return 1;
		}
	}
	return 0;
}

sub issister
{
	my $person = shift;
	my $other = shift;

	return unless($other);

	my $other_xref = $other->xref();

	my @siblings = $person->siblings();
	foreach my $sibling(@siblings) {
		if(($sibling->sex() eq 'F') && ($sibling->xref() eq $other_xref)) {
			return 1;
		}
	}
	return 0;
}

# See also https://github.com/SBECK-github/Date-Manip/issues/34
sub get_year_from_date($)
{
	my $string = shift;
	if($string =~ /(\d{3,4})\s*$/) {
		return $1;
	}
	if($string =~ /(.+)\s(\d{4})\/\d{1,2}/) {
		my $year = $2 + 1;
		complain("old-style string ($string) should be in $year");
		return $year;
	}
	if(my $year = UnixDate(ParseDate($string), '%Y')) {	# Date::Manip
		$year =~ s/^0+//;	# Strip leading zeros
		return $year;
	}
	if($string =~ /(\d{4})/) {
		return $1;
	}
	complain("get_year_from_date(): can't parse string '$string'");
}

# https://www.gnu.org/software/gettext/manual/html_node/Locale-Environment-Variables.html
# https://www.gnu.org/software/gettext/manual/html_node/The-LANGUAGE-variable.html
sub get_language
{
	my %langs = (
		'br' => 'Breton',
		'de' => 'German',
		'en' => 'English',
		'fr' => 'French',
		'fa' => 'Farsi',
		'la' => 'Latin',
	);

	# Check the LANGUAGE environment variable
	if($ENV{'LANGUAGE'}) {
		for my $language(split /:/, $ENV{'LANGUAGE'}) {
			return $langs{$language} if(exists($langs{$language}));
		}
	}

	# Check other environment variables
	for my $variable('LC_ALL', 'LC_MESSAGES', 'LANG') {
		if(my $val = $ENV{$variable}) {
			if(my ($prefix) = $val =~ /^(\w{2})/) {
				return $langs{$prefix} if(exists($langs{$prefix}));
			}
		}
	}

	# Fallback
	complain("Can't determine the language, falling back to English");
	return 'English';
}

sub get_language_code
{
	if($ENV{'LANGUAGE'} && ($ENV{'LANGUAGE'} =~ /^([a-z]{2})/i)) {
		return lc($1);
	}

	foreach my $variable('LC_ALL', 'LC_MESSAGES', 'LANG') {
		my $val = $ENV{$variable};
		next unless(defined($val));

		if($val =~ /^([a-z]{2})/i) {
			return lc($1);
		}
	}
	if(defined($ENV{'LANG'}) && (($ENV{'LANG'} =~ /^C\./) || ($ENV{'LANG'} eq 'C'))) {
		return 'en';
	}
	return;	# undef
}

# TODO:	format containing ':'
# FIXME: German nouns start with a capital letter
# TODO: investigate Lingua::Translate
# TODO: investigate Locale::Maketext (though I find that overly complex to get started with)
sub i18n
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(((scalar(@_) % 2) == 0) && ref($_[1])) {
		%params = @_;
	} else {
		$params{'format'} = lc(shift);
		$params{'args'} = \@_;
	}

	my $format = $params{'format'};
	if(!defined($format)) {
		my $i = 0;
		print "\n";
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: format argument not given';
	}

	my $prepend_space;
	if($format =~ /^\s(.+)$/) {
		$format = $1;
		$prepend_space = 1;
	}
	my $append_space;
	if($format =~ /^(.+)\s$/) {
		$format = $1;
		$append_space = 1;
	}
	my $append_comma;
	if($format =~ /^(.+),$/) {
		$format = $1;
		$append_comma = 1;
	}

	if($i18n) {
		my $translation;
		my $person = $params{'person'};
		$translation = $i18n->{$format};
		if(ref($translation) eq 'HASH') {
			if(!defined($person)) {
				print STDERR "\n";
				my $i = 0;
				while((my @call_details = caller($i++))) {
					print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
				}
				die "BUG: '$format' requires the person argument to determine gender";
			}
			$translation = $translation->{$person->sex()};
		}

		if($translation) {
			if($translation =~ /%/) {	# TODO: %%
				if(ref($params{'args'}) eq 'ARRAY') {
					$translation = sprintf($translation, @{$params{'args'}});
				} elsif(ref($params{'args'})) {
					$translation = sprintf($translation, $params{'args'}->as_string());
				} elsif(length($params{'args'}) == 0) {
					print STDERR "\n";
					my $i = 0;
					while((my @call_details = caller($i++))) {
						print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
					}
					die "BUG: '$format' requires non-empty argument";
				} else {
					my $arg = $params{'args'};
					utf8::encode($arg);
					$translation = sprintf($translation, $arg);
				}
			}
			utf8::decode($translation);
			$translation .= ',' if($append_comma);
			$translation .= ' ' if($append_space);
			if($prepend_space) {
				return " $translation";
			}
			return $translation;
		}

		my $i = 0;
		print "\n";
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die $format;
	}
	if($format =~ /%/) {	# TODO: %%
		if(ref($params{'args'}) eq 'ARRAY') {
			$format = sprintf($format, @{$params{'args'}});
		} else {
			$format = sprintf($format, $params{'args'});
		}
	}
	utf8::decode($format);
	$format .= ' ' if($append_space);
	if($prepend_space) {
		return " $format";
	}
	return $format;
}

sub between
{
	if(my $phrase = shift) {
		if($phrase =~ /^fro?m (.+) to (.+)/i) {
			return i18n('between ') . conjunction($1, $2);
		}
		return $phrase;
	}
}

# Create an array that will allow fast access to each element
sub cache_array
{
	if(ref($_[0]) && (ref($_[0]) eq 'ARRAY')) {
		return map { Class::Simple::Readonly::Cached->new({ object => $_, cache => {} }) } @_;
	}
	return @_;
}

# Parse obituary text and extract structured family relationship data, including details about children, parents, spouse, siblings, grandchildren, and other relatives.
# The routine processes the obituary content to identify and organize relevant family information into a clear, structured hash.

# FIXME:  add more general code, e.g. where it looks for father, also look for mother

# It returns a hash reference containing structured family information,
# with each family member's data organized into distinct categories such as children, spouse, parents, siblings, etc.

# Test data:
# Helen Mae (McBeath) Girvan, age 89 years passed away at the Kenneth E. Spencer Memorial Home on Friday December 12th, 2008.  Born in Peters Mills, Kent Co.  on April 9th, 1919 she was the daughter of the late Richmond and Lilly (Peters) McBeath, and the wife of the late Ian Stuart Girvan (1987).  An adherent of Gunningsville Baptist church, Helen was an organist in both the United and Presbyterian churches in Rexton where she also taught school on a local license.  Following her marriage she became a Sunday school teacher and was a Life Time member of the Hillsborough UCW and the Womens Institute.  Later in life she was involved as a volunteer at the Lakeview Salvation Army Nursing Home and was the membership chairman of the Salvation Army Home League.  She is survived by her children Gwen Steeves (Leslie) of Riverview, NB, Ian (Terry) Girvan of Surrey, BC, and Carol Girvan of Dartmouth, NS; grandchildren Stacey and Tara Steeves; as well as several nieces and nephews.  Besides her husband she is predeceased by her sisters Dorothy Knowles, and Audrey Little; and brothers Stanley and Harold McBeath.  By personal request there will be no visitation at the funeral home

# And https://funeral-notices.co.uk/notice/adams/5244000

sub extract_family_info
{
	my $text = shift;

	return Genealogy::Obituary::Parser::parse_obituary($text);
}

# Get the weather for the day
sub weather
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	}

	# my $person = $params{'person'};
	my $record = $params{'record'};	# death record
	my $meteo = $params{'meteo'};

	if(!$record) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'Usage: weather(person, record, meteo)';
	}

	my $date = $record->date();

	return unless($date);
	return if($date !~ /^\d/);

	if((my $d = $dfg->parse_datetime(date => $date)) &&
	   $record->place() &&
	   (my $location = get_location($record->place()))) {
		my $weather = $meteo->weather($location, $d->strftime('%F'));

		return unless(defined($weather));

		my $temperature = $weather->{'daily'}->{'temperature_2m_max'}[0];
		my $wmo = $weather->{'daily'}->{'weathercode'}[0];

		if($wmo == 0) {
			if($temperature <= 16) {
				return 'a mild and sunny day';
			}
			if($temperature <= 5) {
				return 'a cold and sunny day';
			}
			return 'a warm, sunny day';
		} elsif($wmo == 2) {
			return 'a partly cloudy day';
		} elsif($wmo == 3) {
			if($temperature <= 5) {
				return 'a cold and overcast day';
			}
			return 'an overcast day';
		} elsif(($wmo == 51) || ($wmo == 53) || ($wmo == 55)) {
			if($temperature >= 22) {
				return 'a warm but drizzly day';
			}
			return 'a drizzly day';
		} elsif($wmo == 61) {
			return 'a day with light rain';
		} elsif($wmo == 63) {
			return 'a rainy day';
		} elsif($wmo == 71) {
			return 'a day with light snow';
		} elsif($wmo == 73) {
			if($temperature <= 5) {
				return 'a cold day with snow';
			}
			return 'a day with snow';
		} elsif($temperature < 5) {
			return 'a cold day';
		} elsif($wmo == 1) {
			if($temperature >= 21) {
				return 'a warm and sunny day';
			}
			if($temperature >= 30) {
				return 'a hot and sunny day';
			}
			if($temperature <= 5) {
				return 'a hot but sunny day';
			}
			return 'a sunny day';
		} else {
			die "TODO: parse weather (wmo = $wmo, temperature = $temperature)";
		}
	}
}

# Given an array of siblings and my date of birth, return an array of which of them are my twins
# Allow for a twin being born a day before or after this person
sub twins
{
	my $params = Params::Get::get_params(undef, @_);
	my $birth_dt = $params->{'birth_dt'};
	my $siblings = $params->{'siblings'};
	my @twins;

	foreach my $sibling (@$siblings) {
		my $dob = dateofbirth($sibling) or next;

		# Skip if DOB format is incorrect
		next unless $dob =~ /^\d/ && $dob !~ /[a-z]$/i;

		# Attempt to parse the DOB
		my $d;
		eval {
			$d = $date_parser->parse(date => $dob);
		};
		next unless $d && ($d = $d->[0]);

		# Convert date to canonical format
		$d = $dfn->parse_datetime($d->{'canonical'});

		# Check if the sibling is a twin
		if($d == $birth_dt || $d == ($birth_dt - $oneday) || $d == ($birth_dt + $oneday)) {
			push @twins, { sibling => $sibling, dob => $d };
		}
	}

	return @twins;
}


sub person_in_residence_record
{
	my $params = Params::Get::get_params(undef, @_);

	my $person = $params->{'person'};
	my $date = $params->{'date'};

	foreach my $event(get_all_residences($person)) {
		my $edate = $event->date();

		# Skip if $edate is undefined, contains "bet", or contains a comma or dash
		next unless $edate && $edate !~ /^bet\s/i && $edate !~ /[,\-]/;

		# Return 1 if dates match
		return 1 if datecmp($edate, $date) == 0;
	}

	return 0;
}

# Encode to HTML whatever the non-ascii encoding scheme has been chosen
# Can't use HTML:Entities::encode since that doesn't seem to cope with
#	all encodings and misses some characters
#
# See https://www.compart.com/en/unicode/U+0161 etc.
#	https://www.compart.com/en/unicode/U+00EB
#
# keep_hrefs => 1 means ensure hyperlinks still work
# keep_apos => 1 means keep apostrophes, useful within <script>
# TODO: don't transform anything within <script>...</script>
# TODO: a lot of this should be table driven
sub wide_to_html
{
	my $params = Params::Get::get_params('string', @_);

	return Encode::Wide::wide_to_html({ complain => \&complain, %{$params} });

	my $string = $params->{'string'};

	if(!defined($string)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: wide_to_html() string not set';
	}

	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";
	# my $i = 0;
	# while((my @call_details = caller($i++))) {
		# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
	# }

	$string = HTML::Entities::decode($string);
	# $string =~ s/ & / &amp; /g;
	$string =~ s/&ccaron;/Ä/g;	# I don't think HTML::Entities does this
	$string =~ s/&zcaron;/Å¾/g;	# I don't think HTML::Entities does this
	$string =~ s/&Scaron;/Å /g;	# I don't think HTML::Entities does this

	# Escape only if it's not already part of an entity
	$string =~ s/&(?![A-Za-z#0-9]+;)/&amp;/g;

	unless($params->{'keep_hrefs'}) {
		$string =~ s/</&lt;/g;
		$string =~ s/>/&gt;/g;
		$string =~ s/"/&quot;/g;
		$string =~ s/â/&quot;/g;	# U+201C
		$string =~ s/â/&quot;/g;	# U+201D
	}

	# $string =~ s/&db=/&amp;db=/g;
	# $string =~ s/&id=/&amp;id=/g;

	unless($params->{'keep_apos'}) {
		# $string =~ s/'/&apos;/g;
		# $string =~ s/â/&apos;/g;
		# $string =~ s/â/&apos;/g;
		# $string =~ s/â/&apos;/g;
		# $string =~ s/\x98/&apos;/g;
		$string =~ s/['âââ\x98]/&apos;/g;
	}

	if($string !~ /[^[:ascii:]]/) {
		return $string;
	}

	$string =~ s/\xc2\xa0/ /g;	# Non breaking space
	$string =~ s/\xc2\xa3/&pound;/g;
	$string =~ s/\xc2\xa9/&copy;/g;
	$string =~ s/\xc2\xaa/&ordf;/g;	# Âª
	$string =~ s/\xc2\xab/&quot;/g;	# Â«
	$string =~ s/\xc2\xae/&reg;/g;
	$string =~ s/\xc2\xbb/&quot;/g;	# Â»
	$string =~ s/\xc3\x81/&Aacute;/g;	# Ã
	$string =~ s/\xc3\x83/&Icirc;/g;	# Ã
	$string =~ s/\xc3\x9e/&THORN;/g;	# Ã
	$string =~ s/\xc3\xa1/&aacute;/g;	# Ã¡
	$string =~ s/\xc3\xa2/&acirc;/g;
	$string =~ s/\xc3\xa4/&auml;/g;
	$string =~ s/\xc3\xa9/&eacute;/g;
	$string =~ s/\xc3\xad/&iacute;/g;	# Ã­
	$string =~ s/\xc3\xb0/&eth;/g;	# Ã°
	$string =~ s/\xc3\xba/&uacute;/g;	# Ãº
	$string =~ s/\xc3\xb4/&ocirc;/g;	# Ã´
	$string =~ s/\xc3\xb6/&ouml;/g;
	$string =~ s/\xc3\xb8/&oslash;/g;	# Ã¸
	$string =~ s/\xc5\xa1/&scaron;/g;
	$string =~ s/\xc4\x8d/&ccaron;/g;
	$string =~ s/\xc5\xbe/&zcaron;/g;
	$string =~ s/\xc3\xa5/&aring;/g;	# Ã¥
	$string =~ s/\xc3\xa7/&ccedil;/g;
	$string =~ s/\xc3\xaf/&iuml;/g;	# Ã¯
	$string =~ s/\xc3\xb3/&oacute;/g;
	$string =~ s/\xc3\x96/&Ouml;/g; # Ã
	$string =~ s/\xc3\xa8/&egrave;/g;
	$string =~ s/\xc3\x89/&Eacute;/g;
	$string =~ s/\xc3\x9f/&szlig;/g;
	$string =~ s/\xc3\xaa/&ecirc;/g;
	$string =~ s/\xc3\xab/&euml;/g;
	$string =~ s/\xc3\xae/&icirc;/g;
	$string =~ s/\xc3\xbb/&ucirc;/g;
	$string =~ s/\xc3\xbc/&uuml;/g; # Ã¼
	$string =~ s/\xc3\xbe/&thorn;/g;	# Ã¾
	$string =~ s/\xc5\x9b/&sacute;/g;
	$string =~ s/\xc5\xa0/&Scaron;/g;
	$string =~ s/\xe2\x80\x93/&ndash;/g;
	$string =~ s/\xe2\x80\x94/&mdash;/g;
	$string =~ s/\xc3\xb1/&ntilde;/g;	# Ã±
	$string =~ s/\xe2\x80\x9c/&quot;/g;
	$string =~ s/\xe2\x80\x9d/&quot;/g;
	$string =~ s/\xe2\x80\xa6/.../g;
	$string =~ s/\xe2\x97\x8f/&#x25CF;/g;	# â

	$string =~ s/\N{U+00A0}/ /g;
	$string =~ s/\N{U+00A3}/&pound;/g;
	$string =~ s/\N{U+00A9}/&copy;/g;
	$string =~ s/\N{U+00AA}/&ordf;/g;	# Âª
	$string =~ s/\N{U+00AB}/&quot;/g;	# Â«
	$string =~ s/\N{U+00AE}/&reg;/g;
	$string =~ s/\N{U+00BB}/&quot;/g;	# Â»
	$string =~ s/\N{U+00CE}/&Icirc;/g;	# Ã
	$string =~ s/\N{U+00DE}/&THORN;/g;	# Ã
	$string =~ s/\N{U+0161}/&scaron;/g;
	$string =~ s/\N{U+010D}/&ccaron;/g;
	$string =~ s/\N{U+017E}/&zcaron;/g;
	$string =~ s/\N{U+00C9}/&Eacute;/g;
	$string =~ s/\N{U+00D6}/&Ouml;/g;	# Ã
	$string =~ s/\N{U+00DF}/&szlig;/g;	# Ã
	$string =~ s/\N{U+00E1}/&aacute;/g;	# Ã¡
	$string =~ s/\N{U+00E2}/&acirc;/g;
	$string =~ s/\N{U+00E4}/&auml;/g;
	$string =~ s/\N{U+00E5}/&aring;/g;	# Ã¥
	$string =~ s/\N{U+00E7}/&ccedil;/g;	# Ã§
	$string =~ s/\N{U+00E8}/&egrave;/g;
	$string =~ s/\N{U+00E9}/&eacute;/g;
	$string =~ s/\N{U+00ED}/&iacute;/g;	# Ã­
	$string =~ s/\N{U+00EE}/&icirc;/g;
	$string =~ s/\N{U+00EF}/&iuml;/g;	# Ã¯
	$string =~ s/\N{U+00F0}/&eth;/g;	# Ã°
	$string =~ s/\N{U+00F1}/&ntilde;/g;	# Ã±
	$string =~ s/\N{U+00F4}/&ocirc;/g;	# Ã´
	$string =~ s/\N{U+00F6}/&ouml;/g;
	$string =~ s/\N{U+00F8}/&oslash;/g;	# Ã¸
	$string =~ s/\N{U+00FA}/&uacute;/g;	# Ãº
	$string =~ s/\N{U+00FC}/&uuml;/g;	# Ã¼
	$string =~ s/\N{U+00FE}/&thorn;/g;	# Ã¾
	$string =~ s/\N{U+00C1}/&Aacute;/g;	# Ã
	$string =~ s/\N{U+00C9}/&Eacute;/g;
	$string =~ s/\N{U+00CA}/&ecirc;/g;
	$string =~ s/\N{U+00EB}/&euml;/g;
	$string =~ s/\N{U+00F3}/&oacute;/g;
	$string =~ s/\N{U+015B}/&sacute;/g;
	$string =~ s/\N{U+00FB}/&ucirc;/g;
	$string =~ s/\N{U+0160}/&Scaron;/g;
	$string =~ s/\N{U+2013}/&ndash;/g;
	$string =~ s/\N{U+2014}/&mdash;/g;
	$string =~ s/\N{U+201C}/&quot;/g;
	$string =~ s/\N{U+201D}/&quot;/g;
	$string =~ s/\N{U+2026}/.../g;	# â¦
	$string =~ s/\N{U+25CF}/&#x25CF;/g;	# â

	# utf8::encode($string);
	# $string =~ s/Å¡/&scaron;/g;
	# $string =~ s/Ä/&ccaron;/g;
	# $string =~ s/Å¾/&zcaron;/g;
	# $string =~ s/Ã©/&eacute;/g;
	# $string =~ s/Ã§/&ccedil;/g;
	# $string =~ s/\N{U+0161}/&scaron;/g;
	# $string =~ s/\N{U+010D}/&ccaron;/g;
	# $string =~ s/\N{U+017E}/&zcaron;/g;
	# $string =~ s/\N{U+00E9}/&eacute;/g;
	# $string =~ s/\N{U+00D6}/&Ouml;/g;	# Ã
	# $string =~ s/\N{U+00E7}/&ccedil;/g;	# Ã§
	# $string =~ s/\N{U+00E8}/&egrave;/g;
	# $string =~ s/\N{U+00E9}/&Eacute;/g;

	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";

	# utf8::decode($string);

	# print STDERR __LINE__, ": ($string)";
	# # print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";

	# $string =~ s/\xe4\x8d/&ccaron;/g;	# ? ACOM strangeness
	# $string =~ s/\N{U+0161}/&scaron;/g;
	# $string =~ s/\N{U+010D}/&ccaron;/g;
	# $string =~ s/\N{U+00A9}/&copy;/g;
	# $string =~ s/\N{U+00AE}/&reg;/g;
	# $string =~ s/\N{U+00E2}/&acirc;/g;
	# $string =~ s/\N{U+00E4}/&auml;/g;
	# $string =~ s/\N{U+00E8}/&egrave;/g;
	# $string =~ s/\N{U+00E9}/&eacute;/g;
	# $string =~ s/\N{U+00EB}/&euml;/g;
	# $string =~ s/\N{U+00F3}/&oacute;/g;
	# $string =~ s/\N{U+00FB}/&ucirc;/g;
	# $string =~ s/\N{U+017E}/&zcaron;/g;
	# $string =~ s/\N{U+00D6}/&Ouml;/g;	# Ã
	# $string =~ s/\N{U+00E7}/&ccedil;/g;	# Ã§
	# $string =~ s/\N{U+00C9}/&Eacute;/g;
	# $string =~ s/\N{U+00CA}/&ecirc;/g;
	# $string =~ s/\N{U+0160}/&Scaron;/g;	# FIXME: also above
	# $string =~ s/\N{U+2013}/-/g;

	$string =~ s/Ã/&Aacute;/g;
	$string =~ s/Ã¥/&aring;/g;
	$string =~ s/Âª/&ordf;/g;
	$string =~ s/Å¡/&scaron;/g;
	$string =~ s/Å /&Scaron;/g;
	$string =~ s/Ä/&ccaron;/g;
	$string =~ s/Å¾/&zcaron;/g;
	$string =~ s/Ã¡/&aacute;/g;
	$string =~ s/Ã¢/&acirc;/g;
	$string =~ s/Ã©/&eacute;/g;
	$string =~ s/Ã¨/&egrave;/g;
	$string =~ s/Ã§/&ccedil;/g;
	$string =~ s/Ãª/&ecirc;/g;
	$string =~ s/Ã«/&euml;/g;
	$string =~ s/Ã°/&eth;/g;
	$string =~ s/Ã­/&iacute;/g;
	$string =~ s/Ã¯/&iuml;/g;
	$string =~ s/Ã/&Iicrc;/g;
	$string =~ s/Â©/&copy;/g;
	$string =~ s/Â®/&reg;/g;
	$string =~ s/Ã³/&oacute;/g;
	$string =~ s/Ã´/&ocirc;/g;
	$string =~ s/Ã¶/&ouml;/g;
	$string =~ s/Ã¸/&oslash;/g;
	$string =~ s/Å/&sacute;/g;
	$string =~ s/Ã/&THORN;/g;
	$string =~ s/Ã¾/&thorn;/g;
	$string =~ s/Ã»/&ucirc;/g;
	$string =~ s/Ã¼/&uuml;/g;
	$string =~ s/Ãº/&uacute;/g;
	$string =~ s/Â£/&pound;/g;
	$string =~ s/Ã/&szlig;/g;
	$string =~ s/â/&ndash;/g;
	$string =~ s/â/&mdash;/g;
	$string =~ s/Ã±/&ntilde;/g;
	$string =~ s/[ââÂ«Â»]/&quot;/g;
	$string =~ s/â¦/.../g;
	$string =~ s/â/&#x25CF;/g;
	$string =~ tr/\x80/ /;

	# if($string =~ /^Maria\(/) {
		# # print STDERR (unpack 'H*', $string);
		# print STDERR __LINE__, ': ';
		# print STDERR (sprintf '%v02X', $string);
		# print STDERR "\n";
		# my $i = 0;
		# while((my @call_details = caller($i++))) {
			# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		# }
		# # die $string;
	# }

	# print STDERR __LINE__, ": ($string)\n";
	if($string =~ /[^[:ascii:]]/) {
		$string = HTML::Entities::encode($string);
		if($string =~ /[^[:ascii:]]/) {
			print STDERR (unpack 'H*', $string);
			print STDERR __LINE__, ': ';
			print STDERR (sprintf '%v02X', $string), "\n";
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			complain("TODO: wide_to_html($string)");
			warn "TODO: wide_to_html($string)";
			$string =~ s/[^[:ascii:]]/XXXXX/g;
			die "BUG: wide_to_html($string)";
		}
	}

	return $string;
}

# See https://www.compart.com/en/unicode/U+0161 etc.
#	https://www.compart.com/en/unicode/U+00EB
sub wide_to_xml
{
	my $params = Params::Get::get_params('string', @_);

	return Encode::Wide::wide_to_xml({ complain => \&complain, %{$params} });

	my $string = $params->{'string'};

	if(!defined($string)) {
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'BUG: string not set';
	}

	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";

	# my $i = 0;
	# while((my @call_details = caller($i++))) {
		# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
	# }

	$string = HTML::Entities::decode($string);
	# print STDERR __LINE__, ": ($string)\n";

	# $string =~ s/&amp;/&/g;
	$string =~ s/&ccaron;/Ä/g;	# I don't think HTML::Entities does this
	$string =~ s/&zcaron;/Å¾/g;	# I don't think HTML::Entities does this
	$string =~ s/&Scaron;/Å /g;	# I don't think HTML::Entities does this

	# Escape only if it's not already part of an entity
	$string =~ s/&(?![A-Za-z#0-9]+;)/&amp;/g;

	unless($params->{'keep_hrefs'}) {
		# $string =~ s/</&lt;/g;
		# $string =~ s/>/&gt;/g;
		# $string =~ s/"/&quot;/g;
		# $string =~ s/â/&quot;/g;	# U+201C
		# $string =~ s/â/&quot;/g;	# U+201D

		my %replacements = (
			'<' => '&lt;',
			'>' => '&gt;',
			'"' => '&quot;',
			'â' => '&quot;',	# U+201C
			'â' => '&quot;',	# U+201D
		);

		$string =~ s/([<>ââ"])/$replacements{$1} || $1/eg;
	}

	# $string =~ s/â/&apos;/g;
	# $string =~ s/â/&apos;/g;
	# $string =~ s/â/&apos;/g;
	# $string =~ s/â/&apos;/g;
	# $string =~ s/\x98/&apos;/g;
	$string =~ s/['âââ\x98]/&apos;/g;

	$string =~ s/&Aacute;/&#x0C1;/g;	# Ã
	$string =~ s/&aring;/&#x0E5;/g;	# Ã¥
	$string =~ s/&ccaron;/&#x10D;/g;
	$string =~ s/&aacute;/&#x0E1;/g;	# Ã¡
	$string =~ s/&acirc;/&#x0E2;/g;		# Ã¢
	$string =~ s/&auml;/&#x0E4;/g;		# Ã¤
	$string =~ s/&ccedil;/&#x0E7;/g;	# Ã§
	$string =~ s/&egrave;/&#x0E8;/g;
	$string =~ s/&eacute;/&#x0E9;/g;
	$string =~ s/&ecirc;/&#x0EA;/g;
	$string =~ s/&euml;/&#x0EB;/g;	# euml
	$string =~ s/&Icirc;/&#x0CE;/g;	# Ã
	$string =~ s/&Eacute;/&#x0C9;/g;
	$string =~ s/&szlig;/&#x0DF;/g;	# Ã
	$string =~ s/&iacute;/&#xED;/g;	# Ã­
	$string =~ s/&icirc;/&#x0EE;/g;
	$string =~ s/&iuml;/&#x0EF;/g;	# Ã¯
	$string =~ s/&eth;/&#x0F0;/g;	# Ã°
	$string =~ s/&uacute;/&#0FA;/g;	# Ãº
	$string =~ s/&uuml;/&#x0FC;/g;
	$string =~ s/&scaron;/&#x161;/g;
	$string =~ s/&oacute;/&#x0F3;/g;	# Ã³
	$string =~ s/&ucirc;/&#x0F4;/g;
	$string =~ s/&ouml;/&#x0F6;/g;
	$string =~ s/&ordf;/&#x0AA;/g;	# Âª
	$string =~ s/&oslash;/&#x0F8;/g;	# Ã¸
	$string =~ s/&zcaron;/&#x17E;/g;
	$string =~ s/&Scaron;/&#x160;/g;
	$string =~ s/&THORN;/&#x0DE;/g;	# Ã
	$string =~ s/&thorn;/&#x0FE;/g;	# Ã¾
	$string =~ s/&copy;/&#x0A9;/g;
	$string =~ s/&reg;/&#x0AE;/g;
	$string =~ s/&pound;/&#163;/g;
	$string =~ s/&ntilde;/&#x0F1;/g;
	$string =~ s/&mdash;/-/g;
	$string =~ s/&ndash;/-/g;

	if($string !~ /[^[:ascii:]]/) {
		return $string;
	}

	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";

	$string =~ s/\xc2\xa0/ /g;	# Non breaking space
	$string =~ s/\xc2\xa3/&#x0A3;/g;	# Â£
	$string =~ s/\xc2\xa9/&#x0A9;/g;
	$string =~ s/\xc2\xaa/&#x0AA;/g;	# Âª
	$string =~ s/\xc2\xab/&quot;/g;	# Â«
	$string =~ s/\xc2\xae/&#x0AE;/g;
	$string =~ s/\xc3\x81/&#x0C1;/g;	# Ã
	$string =~ s/\xc3\x8e/&#x0CE;/g;	# Ã
	$string =~ s/\xc3\xa1/&#x0E1;/g;	# Ã¡
	$string =~ s/\xc3\xa5/&#x0E5;/g;	# Ã¥
	$string =~ s/\xc3\xa9/&#x0E9;/g;
	$string =~ s/\xc3\xaf/&#x0EF;/g;	# Ã¯
	$string =~ s/\xc3\xb1/&#x0F1;/g;	# ntilde Ã±
	$string =~ s/\xc5\xa1/&#x161;/g;
	$string =~ s/\xc4\x8d/&#x10D;/g;
	$string =~ s/\xc5\xbe/&#x17E;/g;	# Å¾
	$string =~ s/\xc3\x96/&#x0D6;/g;	# Ã
	$string =~ s/\xc3\x9e/&#x0DE;/g;	# Ã
	$string =~ s/\xc3\x9f/&#x0DF;/g;	# Ã
	$string =~ s/\xc3\xa2/&#x0E2;/g;	# Ã¢
	$string =~ s/\xc3\xad/&#x0ED;/g;	# Ã­
	$string =~ s/\xc3\xa4/&#x0E4;/g;	# Ã¤
	$string =~ s/\xc3\xa7/&#x0E7;/g;	# Ã§
	$string =~ s/\xc3\xb0/&#x0F0;/g;	# Ã°
	$string =~ s/\xc3\xb3/&#x0F3;/g;	# Ã³
	$string =~ s/\xc3\xb8/&#x0F8;/g;	# Ã¸
	$string =~ s/\xc3\xbc/&#x0FC;/g;	# Ã¼
	$string =~ s/\xc3\xbe/&#x0FE;/g;	# Ã¾
	$string =~ s/\xc3\xa8/&#x0E8;/g;	# Ã¨
	$string =~ s/\xc3\xee/&#x0EE;/g;
	$string =~ s/\xc3\xb4/&#x0F4;/g;	# Ã´
	$string =~ s/\xc3\xb6/&#x0F6;/g;	# Ã¶
	$string =~ s/\xc3\x89/&#x0C9;/g;
	$string =~ s/\xc3\xaa/&#x0EA;/g;
	$string =~ s/\xc3\xab/&#x0EB;/g;	# eumlaut
	$string =~ s/\xc3\xba/&#x0FA;/g;	# Ãº
	$string =~ s/\xc3\xbb/&#x0BB;/g;	# Ã» - ucirc
	$string =~ s/\xc5\x9b/&#x15B;/g;	# Å - sacute
	$string =~ s/\xc5\xa0/&#x160;/g;
	$string =~ s/\xe2\x80\x93/-/g;
	$string =~ s/\xe2\x80\x94/-/g;
	$string =~ s/\xe2\x80\x9c/&quot;/g;
	$string =~ s/\xe2\x80\x9d/&quot;/g;
	$string =~ s/\xe2\x80\xa6/.../g;
	$string =~ s/\xe2\x97\x8f/&#x25CF;/g;	# â
	$string =~ s/\xe3\xb1/&#x0F1;/g;	# ntilde Ã± - what's this one?
	# $string =~ s/\xe4\x8d/&#x10D;/g;	# ? ACOM strangeness
	# $string =~ s/\N{U+0161}/&#x161;/g;
	# $string =~ s/\N{U+010D}/&#x10D;/g;
	# $string =~ s/\N{U+00E9}/&#x0E9;/g;
	# $string =~ s/\N{U+017E}/&#x17E;/g;

	$string =~ s/\N{U+00A0}/ /g;
	$string =~ s/\N{U+010D}/&#x10D;/g;
	$string =~ s/\N{U+00AB}/&quot;/g;	# Â«
	$string =~ s/\N{U+00AE}/&#x0AE;/g;	# Â®
	$string =~ s/\N{U+00C1}/&#x0C1;/g;	# Ã
	$string =~ s/\N{U+00CE}/&#x0CE;/g;	# Ã
	$string =~ s/\N{U+00DE}/&#x0DE;/g;	# Ã
	$string =~ s/\N{U+00E4}/&#x0E4;/g;	# Ã¤
	$string =~ s/\N{U+00E5}/&#x0E5;/g;	# Ã¥
	$string =~ s/\N{U+00EA}/&#x0EA;/g;
	$string =~ s/\N{U+00ED}/&#x0ED;/g;
	$string =~ s/\N{U+00EE}/&#x0EE;/g;
	$string =~ s/\N{U+00FE}/&#x0FE;/g;	# Ã¾
	$string =~ s/\N{U+00C9}/&#x0C9;/g;
	$string =~ s/\N{U+017E}/&#x17E;/g;	# Å¾
	$string =~ s/\N{U+00D6}/&#x0D6;/g;	# Ã
	$string =~ s/\N{U+00DF}/&#x0DF;/g;	# Ã
	$string =~ s/\N{U+00E1}/&#x0E1;/g;	# Ã¡ - aacute
	$string =~ s/\N{U+00E2}/&#x0E2;/g;
	$string =~ s/\N{U+00E8}/&#x0E8;/g;	# Ã¨
	$string =~ s/\N{U+00EF}/&#x0EF;/g;	# Ã¯
	$string =~ s/\N{U+00F0}/&#x0F0;/g;	# Ã°
	$string =~ s/\N{U+00F1}/&#x0F1;/g;	# Ã±
	$string =~ s/\N{U+00F3}/&#x0F3;/g;	# Ã³
	$string =~ s/\N{U+00F4}/&#x0F4;/g;	# Ã´
	$string =~ s/\N{U+00F6}/&#x0F6;/g;	# Ã¶
	$string =~ s/\N{U+00F8}/&#x0F8;/g;	# Ã¸
	$string =~ s/\N{U+00FA}/&#x0FA;/g;	# Ãº
	$string =~ s/\N{U+00FC}/&#x0FC;/g;	# Ã¼
	$string =~ s/\N{U+015B}/&#x15B;/g;	# Å
	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";
	$string =~ s/\N{U+00E9}/&#x0E9;/g;
	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";
	$string =~ s/\N{U+00E7}/&#x0E7;/g;	# Ã§
	$string =~ s/\N{U+00EB}/&#x0EB;/g;	# Ã«
	$string =~ s/\N{U+00FB}/&#x0FB;/g;	# Ã»
	$string =~ s/\N{U+0160}/&#x160;/g;
	$string =~ s/\N{U+0161}/&#x161;/g;
	$string =~ s/\N{U+00A9}/&#x0A9;/g;	# Â©
	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";
	$string =~ s/\N{U+2013}/-/g;
	$string =~ s/\N{U+2014}/-/g;
	$string =~ s/\N{U+201C}/&quot;/g;
	$string =~ s/\N{U+201D}/&quot;/g;
	$string =~ s/\N{U+2026}/.../g;	# â¦
	$string =~ s/\N{U+25CF}/&#x25CF;/g;	# â

	# utf8::encode($string);
	# $string =~ s/Å¡/&s#x161;/g;
	# $string =~ s/Ä/&#x10D;/g;
	# $string =~ s/Å¾/&z#x17E;/g;
	# $string =~ s/Ã©/&#x0E9;/g;
	# $string =~ s/Ã/&#x0D6;/g;
	# $string =~ s/Ã§/&#x0E7;/g;
	# $string =~ s/\N{U+0161}/&#x161;/g;
	# $string =~ s/\N{U+010D}/&#x10D;/g;
	# $string =~ s/\N{U+017E}/&#x17E;/g;
	# $string =~ s/\N{U+00E9}/&#x0E9;/g;
	# $string =~ s/\N{U+00D6}/&#x0D6;/g;	# Ã
	# $string =~ s/\N{U+00E7}/&#x0E7;/g;	# Ã§

	# print STDERR __LINE__, ": ($string)";
	# print STDERR (sprintf '%v02X', $string);
	# print STDERR "\n";

	# utf8::decode($string);

	$string =~ s/['\x98]/&#039;/g;
	$string =~ s/Â©/&#x0A9;/g;
	$string =~ s/Âª/&#x0AA;/g;
	$string =~ s/Â®/&#x0AE;/g;
	$string =~ s/Ã¥/&#x0E5;/g;
	$string =~ s/Å¡/&#x161;/g;
	$string =~ s/Ä/&#x10D;/g;
	$string =~ s/Å¾/&#x17E;/g;
	$string =~ s/Â£/&#x0A3;/g;
	$string =~ s/Ã¡/&#x0E1;/g;	# Ã¡
	$string =~ s/Ã¢/&#x0E2;/g;
	$string =~ s/Ã¤/&#x0E4;/g;	# Ã¤
	$string =~ s/Ã/&#x0C1;/g;	# Ã
	$string =~ s/Ã/&#x0D6;/g;
	$string =~ s/Ã/&#x0DF;/g;
	$string =~ s/Ã§/&#x0E7;/g;
	$string =~ s/Ã¨/&#x0E8;/g;
	$string =~ s/Ã©/&#x0E9;/g;
	$string =~ s/Ãª/&#x0EA;/g;
	$string =~ s/Ã«/&#x0EB;/g;
	$string =~ s/Ã­/&#x0ED;/g;
	$string =~ s/Ã¯/&#x0EF;/g;
	$string =~ s/Ã/&#x0CE;/g;	# Ã
	$string =~ s/Ã/&#x0DE;/g;	# Ã
	$string =~ s/Ã°/&#x0F0;/g;	# Ã°
	$string =~ s/Ã¸/&#x0F8;/g;	# Ã¸
	$string =~ s/Ã»/&#x0FB;/g;
	$string =~ s/Ã±/&#x0F1;/g;
	$string =~ s/Ãº/&#x0FA;/g;
	$string =~ s/Ã¼/&#x0FC;/g;
	$string =~ s/Ã¾/&#x0FE;/g;	# Ã¾
	$string =~ s/[ââÂ«Â»]/&quot;/g;
	$string =~ s/â/-/g;
	$string =~ s/â¦/.../g;
	$string =~ s/â/&#x25CF;/g;
	$string =~ tr/\x80/ /;

	# if($string =~ /^Maria\(/) {
		# print STDERR (unpack 'H*', $string);
		# print STDERR __LINE__, ': ';
		# print STDERR (sprintf '%v02X', $string);
		# print STDERR "\n";
		# my $i = 0;
		# while((my @call_details = caller($i++))) {
			# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		# }
		# die $string;
	# }

	# print STDERR __LINE__, ": ($string)\n";
	if($string =~ /[^[:ascii:]]/) {
		print STDERR (unpack 'H*', $string);
		print STDERR __LINE__, ': ';
		print STDERR (sprintf '%v02X', $string);
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		warn "TODO: wide_to_xml($string)";
		$string =~ s/[^[:ascii:]]/XXXXX/g;
		die "BUG: wide_to_xml($string)";
	}
	return $string;
}

# Lookup entry in dbpedia.
# TODO: Look up maiden name and married name(s)
# Experimental code with false positives at the moment
sub dbpedia
{
	return;	# TODO

	my $params = Params::Get::get_params(undef, @_);

	my $person = $params->{'person'};
	my $birth_dt = $params->{'birth_dt'};
	my $yob = $params->{'yob'};

	if(defined($birth_dt)) {
		if(!ref($birth_dt)) {
			print STDERR "\n";
			my $i = 0;
			while((my @call_details = caller($i++))) {
				print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			}
			die "birth_dt ($birth_dt) is not a ref";
		}
		$yob = $birth_dt->year();
	}

	# Get the full name of the person and sanitize by removing slashes
	my $name = $person->name();
	$name =~ s/\///g;

	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	my $firstname = $name_components{'given_name_1'} // $person->given_names() // $name_components{'initials_1'};
	if($firstname) {
		$firstname =~ s/\'/\\\'/g;
		$firstname = Unicode::Diacritic::Strip::strip_diacritics($firstname);
	} else {
		$firstname = 'NULL';
	}
	# my $surname = $name_components{'surname_1'};
	my $surname = ucfirst(lc($person->surname()));
	if($surname) {
		$surname =~ s/\'/\\\'/g;
		$surname = Unicode::Diacritic::Strip::strip_diacritics($surname);
	} else {
		$surname = 'NULL';
	}

	my $url = "https://lookup.dbpedia.org/api/search?query=$firstname%20$surname";
	print "$url\n" if($opts{'v'});
	if(($firstname ne '?') && (my $resp = $cached_browser->get($url))) {
		if($resp->is_success()) {
			if(my $arrayofresults = XML::Hash->new()->fromXMLStringtoHash($resp->decoded_content())->{'ArrayOfResults'}) {
				my $yod = $params->{'yod'};
				my $birth_country = $params->{'birth_country'};
				my $dbpedia = Class::Simple->new();

				RESULT: foreach my $result(@{$arrayofresults->{'Result'}}) {
					if($result->{'Classes'}->{'Class'} &&
					   (ref($result->{'Classes'}->{'Class'}) eq 'ARRAY')) {
						my @classes = @{$result->{'Classes'}->{'Class'}};
						foreach my $class(@classes) {
							if(($class->{'Label'}->{'text'} eq 'Place') ||
							   ($class->{'Label'}->{'text'} eq 'School') ||
							   ($class->{'Label'}->{'text'} eq 'Work') ||
							   ($class->{'Label'}->{'text'} eq 'Event') ||
							   ($class->{'Label'}->{'text'} eq 'Holiday') ||
							   ($class->{'Label'}->{'text'} eq 'Plant') ||
							   ($class->{'Label'}->{'text'} eq 'Organisation') ||
							   ($class->{'Label'}->{'text'} eq 'Artwork')) {
								next RESULT;
							}
						}
					}
					if($result->{'Label'}->{'text'} &&
					   ($result->{'Label'}->{'text'} =~ /$firstname([a-z\s]+)$surname/i) &&
					   (my $description = $result->{'Description'})) {
						if(my $t = $description->{'text'}) {
							next if($t !~ /$firstname([a-z\s]+)$surname\s/i);
							if($t =~ /\(died\s.*?(\d{4})\)/) {
								my $d = $1;
								if(defined($yob) && ($yob > $d)) {
									# Born after dbpedia person died
									next;
								}
							} elsif(($t =~ /\(born\s.*?(\d{4})\D*?\)/) ||
								($t =~ /\((\d{4})\x{2013}\d{4}\)/)) {
								my $b = $1;
								if(defined($yod) && ($yod < $b)) {
									# Died before the dbpedia person was born
									next;
								}
								if(defined($yob) && ($yob != $b)) {
									# Born different year from the dbpedia person was born
									next;
								}
							} elsif($t =~ /\(c\. \d{4} \x{2013} (\d{4})\)/) {
								my $d = $1;
								if(defined($yob) && ($yob > $d)) {
									# Born after the dbpedia person died
									next;
								}
							} elsif($t =~ /may refer to:$/) {
								# TODO: recursive checking
								complain('TODO: also check ' . $result->{'URI'}->{'text'});
								next;
							}
							my @dts = DateTime::Format::Text->parse_datetime($t);
							if((scalar(@dts) == 1) && (defined(my $dt = $dts[0]))) {
								if($birth_dt && ($dt < $birth_dt)) {
									$dt = $dt->delta_days($birth_dt);
									if(($dt->{'days'} / 356) > 2) {
										# Born more than 2 years after
										# the dbpedia event
										next;
									}
								# } elsif(defined($yob) && ($yob != $dt->year())) {
									# next;
								}
							}
							if(scalar(@dts) == 2) {
								if(defined($yob) && (($yob != $dts[0]->year()) || ($yob > $dts[1]->year()))) {
									next;
								}
								if(defined($yod)) {
									if($yod < $dts[0]->year()) {
										next;
									}
									if($yod < ($dts[1]->year() - 40)) {
										# Died more than 40 years before the
										# dbpedia person
										next;
									}
								}
							} elsif($result->{'Categories'}->{'Category'}) {
								# Try to guess other info
								my @categories;
								if(ref($result->{'Categories'}->{'Category'}) eq 'ARRAY') {
									@categories = @{$result->{'Categories'}->{'Category'}};
								} else {
									@categories = ( $result->{'Categories'}->{'Category'} );
								}
								foreach my $category(@categories) {
									my $label = $category->{'Label'}->{'text'};
									if($label =~ /^Companies based in/) {
										next RESULT;
									}

									my $uri = $category->{'URI'}->{'text'};
									if(($uri =~ /Category:Teaching_hospitals/) ||
									   ($uri =~ /Category:Public_housing/) ||
									   ($uri =~ /Category:Defunct_companies/) ||
									   ($uri =~ /Category:Songs_/) ||
									   ($uri =~ /Category:Fictional/) ||
									   ($uri =~ /Category:Public_holidays/) ||
									   ($uri =~ /Category:Types_of_national_holidays/) ||
									   ($uri =~ /Category:Events_in_/) ||
									   ($uri =~ /Category:.+Parades$/) ||
									   ($uri =~ /Category:Geology_of_/) ||
									   ($uri =~ /Category:Hematology/) ||
									   ($uri =~ /Category:Seismological_observatories/)) {
										next RESULT;
									}
									if(defined($birth_country)) {
										if($uri =~ /of_Switzerland$/) {
											next RESULT if($birth_country ne 'Switzerland');
										}
									}
									if(defined($yod)) {
										if($uri =~ /Living_people$/) {
											# dbpedia person is alive, ours is not
											next RESULT;
										}
										if($uri =~ /Category:(\d{4})_deaths$/) {
											my $d = $1;
											if($yod != $d) {
												# Died different year from the dbpedia person died
												next RESULT;
											}
										} elsif($uri =~ /(\d\d)th-century_/) {
											my $c = ($1 + 1) * 100;
											if(defined($yob) && ($yob > $c)) {
												# Born after dbpedia event
												next RESULT;
											}
										}
									}
									if(defined($yob)) {
										if($uri =~ /Category:(\d{4})_births$/) {
											my $b = $1;
											if(defined($yod) && ($yod < $b)) {
												# Died before the dbpedia person was born
												next RESULT;
											}
											if($yob != $b) {
												# Born different year from the dbpedia person was born
												next RESULT;
											}
											$dbpedia->birth($b);
										} elsif(($uri =~ /(\d{3,4})s_deaths/)) {
											if($yob > ($1 + 20)) {
												# Born after the end of the decade this person died
												next RESULT;
											}
										} elsif(($uri =~ /(\d{3,4})s_births/)) {
											if($yob < ($1 - 20)) {
												# Born sometime before the start of the decade this person was born
												next RESULT;
											}
										} elsif($uri =~ /(\d\d)th-century_deaths/) {
											my $c = ($1 + 1) * 100;
											if($yob > $c) {
												# Born after dbpedia person died
												next RESULT;
											}
										} elsif($uri =~ /Category:(\d{4})_deaths$/) {
											my $d = $1;
											if($yob > $d) {
												# Born after this person died
												next RESULT;
											}
											$dbpedia->death($d);
										}
									}
									warn ">>>>>>>>>> dbpedia allowing possibility $uri" if($opts{'w'});
								}
							}
							$Data::Dumper::Maxdepth = 0;
							print STDERR Data::Dumper->new([\$result])->Dump();
							if(defined($yob) && (my $b = $dbpedia->birth()) && ($dbpedia->birth() != $yob)) {
								complain({ person => $person, warning => "Year of birth may be inaccurate: ($yob != $b)" });
							}
							if(defined($yod) && (my $d = $dbpedia->death()) && ($dbpedia->death() != $yod)) {
								complain({ person => $person, warning => "Year of death may be inaccurate: ($yod != $d)" });
							}
							if($opts{'c'}) {
								$t =~ s/\.$//;
								return "$t ($url).";
							}
							return $t;
						}
					}
				}
			}
		} else {
			complain({ person => $person, warning => "$url: $firstname $surname failed: " . $resp->status_line() });
		}
	}
}

# Parse a Newspaper event from FindMyPast records
sub newspaper
{
	my $params = Params::Get::get_params('event', @_);
	my $event = $params->{'event'};

	# Initialize the return object
	my $rc = Class::Simple->new();

	# Set the event date, if available
	if(my $date = $event->date()) {
		$date =~ s/^0//;	# Remove leading zeros
		$rc->date($date);
	}

	# my $source = $event->source();
	if(ref(my $source = $event->source())) {
		# If source is an object, extract URL
		$rc->url($source->tag_record('REF')->value());
		# $rc->title('a newspaper');
	} else {
		# Process source as a string or scalar
		$source = get_source({ source => $source, %{$params} });
		if(my $title = $source->title()) {
			$title =~ s/\.$//;	# Remove trailing fullstop
			$rc->title($title);
		}

		# Retrieve the detailed source record
		$source = $event->tag_record('SOUR');
		if(my $ref = $source->tag_record('REF')) {
			$rc->url($ref->value());
		}

		# Extract page number, if available
		if(my $page = $source->tag_record('PAGE')) {
			$page = $page->value();
			$page =~ s/^0//;	# Remove leading zeros
			$rc->page($page);
		}

		# my @items = $source->items();
		# $Data::Dumper::Maxdepth = 2;
		# die Data::Dumper->new([\@items])->Dump();
	}

	# Return the constructed object
	return $rc;
}

# Avoid end of sentences such as "with his twin sister Jane E.."
sub given_names
{
	my $params = Params::Get::get_params('person', @_);

	if(my $given = $params->{'person'}->given_names()) {
		$given =~ s/\.$//;
		return $given;
	}
}

# Which service did this person serve in?
sub service
{
	my $params = Params::Get::get_params('event', @_);

	if(my $notes = notes(record => $params->{'event'})) {
		return 'navy' if($notes =~ /Navy/i);
		return 'RAF' if($notes =~ /\sRAF/);
		return i18n('army') if($notes =~ /\b(?:army\.?|regiment|soldier)\b/i);
	}
	return 'military';
}

# Recursive ancestor traversal
sub individual_to_hash
{
	my $person = shift;
	my $xref = $person->xref();
	my $hash = {
		id    => $xref,
		xref  => $xref,
		name  => $person->as_string({ nee => 1 }),
		# birth => ($person->get_value('birth', 'date') // ''),
		# death => ($person->get_value('death', 'date') // ''),
		parents => []
	};

	if(($opts{'l'} || !is_alive(person => $person)) && exists($all_bios{$xref})) {
		if(my $birth = dateofbirth($person)) {
			$hash->{'birth'} = $birth;
		}
		if(my $death = dateofdeath($person)) {
			$hash->{'death'} = $death;
		}
		my $bio = $all_bios{$xref};
		# fullbio is full of static link refs, change to the dynamic site
		$bio =~ s{href="([^"/]+)\.html"}{href="/cgi-bin/page.fcgi?page=people&entry=$1"}g;
		$hash->{'bio'} = $bio;
		if(my $thumbnail = $all_thumbnails{$xref}) {
			$hash->{'img'} = $thumbnail;
		}
	}

	for my $parent ($person->father(), $person->mother()) {
		if($parent) {
			push @{$hash->{parents}}, individual_to_hash($parent);
		}
	}
	if(scalar @{$hash->{'parents'}} == 0) {
		delete $hash->{'parents'};
	}

	return $hash;
}

# Must all be in lower case
__DATA__
@@ English
a %s::a %s
a day before::a day before
after %s::after %s
all with %s::all with %s
also::also
also%s::also%s
an %s::an %s
and::and
army::army
around::around
arrived::arrived
at::at
aunt::aunt
aunts::aunts
before %s::before %s
between::between
birthplace::birthplace
both with %s::both with %s
brother::brother
brother-in-law::brother-in-law
brothers::brothers
c.::c.
check out %s::check out %s
child::child
children::children
cousin::cousin
cousins::cousins
daughter::daughter
daughters::daughters
died::died
during %s::during %s
during %s life::during %s life
eldest::eldest
father::father
following the death of::following the death of
from::from
funeral::funeral
grandchildren::grandchildren
grandfather::grandfather
grandmother::grandmother
great-grandchildren::great-grandchildren
had::had
had been::had been
has been married::has been married
has had::has had
has lived::has lived
has lived at %s::has lived at %s
has lived in %s::has lived in %s
he::he
husband::husband
is::is
is buried::is buried
is married to::is married to
later that same year::later that same year
lived::lived
lived in several places::lived in several places
living::living
living person::living person
married::married
mother::mother
nephew::nephew
nephews::nephews
of::of
of %d children::of %d children
older::older
on the same day::on the same day
on the father's side::on the father's side
on the mother's side::on the mother's side
parents::parents
she::she
sister::sister
sister-in-law::sister-in-law
sisters::sisters
son::son
sons::sons
the same day as::the same day as
the husband::the husband
the wife::the wife
they::they
times::times
to::to
today::today
tomorrow::tomorrow
twice::twice
twin of::twin of
uncle::uncle
was::was
was buried::was buried
was born::was born
was living::was living
was married to::was married to
when::when
wife::wife
with::with
with %s::with %s
your::your
@@ Breton
and::ha
son::mab
@@ French
a %s:M:un %s
a %s:F:une %s
a day before::la veille
after %s::aprÃ¨s le %s
all with %s::tout avec %s
also::aussi
also%s::aussi%s
an %s:M:un %s
an %s:F:une %s
and::et
around::environ
arrived:M:est arrivÃ©
arrived:F:est arrivÃ©e
army::armÃ©e
at::Ã 
before %s::avant le %s
between::entre
birthplace::ville natal
both with %s::tous les deux avec %s
brother::frÃ¨re
brother-in-law::beau-frÃ¨re
c.::environ
check out %s::visitez %s
child::enfant
children::enfants
cousin:M:cousin germain
cousin:F:cousine germaine
daughter::fille
died:M:est mort
died:F:est morte
during %s::en %s
during %s life::au cours de sa vie
eldest:M:aÃ®nÃ©
eldest:F:aÃ®nÃ©e
father::pÃ¨re
following the death of::suite au mort de
from::de
had::a eu
had been::avait Ã©tÃ©
has been married:M:a Ã©tÃ© marriÃ©
has been married:F:a Ã©tÃ© marriÃ©e
has had::a eu
has lived::a habitÃ©
has lived at %s::a habitÃ© Ã  %s
has lived in %s::a habitÃ© en %s
he::il
husband::marie
is::est
is buried:M:est inhumÃ©
is buried:F:est inhumÃ©e
is married to:M:est mariÃ© Ã 
is married to:F:est mariÃ©e Ã 
later that same year::plus tard la mÃªme annÃ©e
lived::habitait
lived in several places::habitait dans plusieurs lieux
living::vÃ©cu
living person::vivant
married::a mariÃ©
mother::mÃ¨re
of::de
of %d children::de %d enfants
older:M:aÃ®nÃ©
older:F:aÃ®nÃ©e
on the same day::sur la mÃªme jour
on the father's side::du cÃ´tÃ© paternel
on the mother's side::du cÃ´tÃ© de la mÃ¨re
parents::parents
she::elle
sister::sÅur
sister-in-law::belle-sÅur
sisters::sÅurs
son::fils
the same day as::le mÃªme jour comme
the husband::le marie
the wife::la femme
they:M:ils
they:F:elles
times::temps
to::Ã 
today::aujourd'hui
tomorrow::demain
twice::deux fois
twin of:F:jumelle de
twin of:M:jumeau de
was::Ã©tait
was buried:M:a Ã©tÃ© inhumÃ©
was buried:F:a Ã©tÃ© inhumÃ©e
was born:M:est nÃ©
was born:F:est nÃ©e
was living::habitait
was married to:M:a Ã©tÃ© mariÃ© Ã 
was married to:F:a Ã©tÃ© mariÃ©e Ã 
when::lorsque
wife::femme
with::avec
with %s::avec %s
your::votre
@@ German
a %s:M:ein %s
a %s:F:eine %s
a %s:N:ein %s
an %s:M:ein %s
an %s:F:eine %s
an %s:N:ein %s
a day before::einen Tag vorher
after %s::nach %s
all with %s::alles mit %s
also::auch
also%s::auch%s
and::und
army::Armee
around::circa
arrived::kam
at::in der
before %s::vor %s
between::zwischen
birthplace::Geburtsort
both with %s::beide mit %s
brother::Bruder
brother-in-law::Schwager
brothers::BrÃ¼der
c.::circa
check out %s::Schau mal bei %s
child::Kind
children::Kinder
cousin:M:Cousin
cousin:F:Cousine
daughter::Tochter
died::starb
during %s life:M:wÃ¤hrend seines Lebens
during %s life:F:wÃ¤hrend ihres Lebens
eldest::Ã¤lteste
father::Vater
following the death of::Nach dem Tod von
from::von
funeral::Beerdigung
grandchildren::Enkelkinder
great-grandchildren::Urenkelkinder
has had::hatte
had::hatte
has lived in %s::hat in %s gelebt
he::er
husband::Mann
is::ist
is buried::ist begraben
is married to::ist verheiratet
later that same year::spÃ¤ter im gleichen Jahr
lived in several places::lebte an einige Orten
married::verheiratet
mother::Mutter
of::von
of %d children::von %d Kindern
on the father's side::vÃ¤terlicherseits
on the mother's side::mÃ¼tterlicherseits
parents::Eltern
she::sie
sister::Schwester
sister-in-law::SchwÃ¤gerin
sisters::Schwestern
son::Sohn
sons::SÃ¶hne
the head of household::der Haushaltsvorstand
the same day as::die gleichen Tag als
times::fache
the husband::der Mann
the wife::die Frau
they::Sie
to::nach
today::heute
twice::zweimal
was::war
was born::wurde geboren
was married to %s::war mit %s verheiratet
when::wenn
wife::Frau
with::mit
with %s::mit %s
youngest::jÃ¼ngsten
your::Ihr
@@ Danish
brother::bror
child::barn
father::far
mother::mor
sister::sÃ¸ster
@@ Latin
and::et
brother::frÄter
father::pater
husband::maritus
mother::mater
sister::soror
wife::uxor
@@ Norwegian
father::far
mother::mor
sister::sÃ¸ster
@@ Spanish
aunt::tia
he::Ã©l
father::padre
is::es
mother::madre
she::ella
__END__
